Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOL
    COLON
    COMMENT_MULTI
    COMMENT_SINGLE
    FOREACH
    NEWLINE
    SELECT
    SWITCH

Grammar

Rule 0     S' -> code
Rule 1     code -> empty
Rule 2     code -> statement
Rule 3     code -> statement terminator code
Rule 4     statement -> controlstructure
Rule 5     statement -> assignment
Rule 6     statement -> binaryexp
Rule 7     statement -> nularexp
Rule 8     statement -> unaryexp
Rule 9     terminator -> SEMI_COLON
Rule 10    terminator -> COMMA
Rule 11    controlstructure -> ifstatement
Rule 12    controlstructure -> whileloop
Rule 13    controlstructure -> forloop
Rule 14    controlstructure -> withstatement
Rule 15    helpertype -> iftype
Rule 16    helpertype -> whiletype
Rule 17    helpertype -> fortype
Rule 18    helpertype -> withtype
Rule 19    iftype -> IF LPAREN booleanexp RPAREN
Rule 20    ifstatement -> iftype THEN bracedexp
Rule 21    ifstatement -> iftype EXITWITH bracedexp
Rule 22    ifstatement -> iftype THEN bracedexp ELSE bracedexp
Rule 23    withtype -> WITH NAMESPACE
Rule 24    withstatementinit -> withtype DO
Rule 25    withstatement -> withstatementinit bracedexp
Rule 26    whiletype -> WHILE LBRACE booleanexp RBRACE
Rule 27    whileloop -> whiletype DO bracedexp
Rule 28    fortype -> FOR new_scope string FROM primaryexp TO primaryexp
Rule 29    fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
Rule 30    fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
Rule 31    forloop -> fortype DO bracedexp_noscope
Rule 32    forloop_condition -> LBRACE booleanexp RBRACE
Rule 33    forloop_condition -> identifier
Rule 34    bracedexp_noscope -> LBRACE code RBRACE
Rule 35    assignment -> assignment_code code RBRACE
Rule 36    assignment -> definition EQUAL primaryexp
Rule 37    assignment -> variable EQUAL primaryexp
Rule 38    assignment_code -> definition EQUAL LBRACE
Rule 39    assignment_code -> variable EQUAL LBRACE
Rule 40    arraydefinition -> PRIVATE stringarray
Rule 41    definition -> PRIVATE PRIVATE_ID
Rule 42    identifier -> PRIVATE_ID
Rule 43    identifier -> GLOBAL_ID
Rule 44    variable -> PRIVATE_ID
Rule 45    variable -> GLOBAL_ID
Rule 46    binaryexp -> primaryexp BINARY_FNC primaryexp
Rule 47    binaryexp -> primaryexp comparisonoperator primaryexp
Rule 48    binaryexp -> primaryexp mathoperator primaryexp
Rule 49    primaryexp -> number
Rule 50    primaryexp -> identifier
Rule 51    primaryexp -> helpertype
Rule 52    primaryexp -> unaryexp
Rule 53    primaryexp -> nularexp
Rule 54    primaryexp -> string
Rule 55    primaryexp -> binaryexp
Rule 56    primaryexp -> bracedexp
Rule 57    primaryexp -> LPAREN binaryexp RPAREN
Rule 58    primaryexp -> array
Rule 59    bracedexp -> LBRACE new_scope code RBRACE
Rule 60    new_scope -> <empty>
Rule 61    array -> LSPAREN RSPAREN
Rule 62    array -> LSPAREN arrayelement RSPAREN
Rule 63    arrayelement -> binaryexp
Rule 64    arrayelement -> binaryexp COMMA arrayelement
Rule 65    stringarray -> LSPAREN RSPAREN
Rule 66    stringarray -> LSPAREN stringarrayelement RSPAREN
Rule 67    stringarrayelement -> string
Rule 68    stringarrayelement -> string COMMA stringarrayelement
Rule 69    nularexp -> NULAR_FNC
Rule 70    nularexp -> identifier
Rule 71    unaryexp -> UNARY_FNC primaryexp
Rule 72    unaryexp -> PLUS primaryexp
Rule 73    unaryexp -> MINUS primaryexp
Rule 74    unaryexp -> NOT primaryexp
Rule 75    unaryexp -> arraydefinition
Rule 76    comparisonoperator -> LT
Rule 77    comparisonoperator -> GT
Rule 78    comparisonoperator -> LTE
Rule 79    comparisonoperator -> GTE
Rule 80    comparisonoperator -> EQUALITY
Rule 81    comparisonoperator -> INEQUALITY
Rule 82    comparisonoperator -> AND
Rule 83    comparisonoperator -> OR
Rule 84    mathoperator -> PLUS
Rule 85    mathoperator -> MINUS
Rule 86    mathoperator -> TIMES
Rule 87    mathoperator -> DIVIDE
Rule 88    mathoperator -> MOD
Rule 89    mathoperator -> POW
Rule 90    booleanexp -> primaryexp
Rule 91    booleanexp -> primaryexp comparisonoperator booleanexp
Rule 92    booleanexp -> primaryexp comparisonoperator LBRACE booleanexp RBRACE
Rule 93    configaccessor -> GT GT
Rule 94    configaccessor -> DIVIDE
Rule 95    number -> NUMBER_REAL
Rule 96    number -> NUMBER_EXP
Rule 97    number -> NUMBER_HEX
Rule 98    string -> STRING_SINGLE
Rule 99    string -> STRING_DOUBLE
Rule 100   empty -> <empty>

Terminals, with rules where they appear

AND                  : 82
BINARY_FNC           : 46
BOOL                 : 
COLON                : 
COMMA                : 10 30 30 64 68
COMMENT_MULTI        : 
COMMENT_SINGLE       : 
DIVIDE               : 87 94
DO                   : 24 27 31
ELSE                 : 22
EQUAL                : 36 37 38 39
EQUALITY             : 80
EXITWITH             : 21
FOR                  : 28 29 30
FOREACH              : 
FROM                 : 28 29
GLOBAL_ID            : 43 45
GT                   : 77 93 93
GTE                  : 79
IF                   : 19
INEQUALITY           : 81
LBRACE               : 26 32 34 38 39 59 92
LPAREN               : 19 57
LSPAREN              : 30 61 62 65 66
LT                   : 76
LTE                  : 78
MINUS                : 73 85
MOD                  : 88
NAMESPACE            : 23
NEWLINE              : 
NOT                  : 74
NULAR_FNC            : 69
NUMBER_EXP           : 96
NUMBER_HEX           : 97
NUMBER_REAL          : 95
OR                   : 83
PLUS                 : 72 84
POW                  : 89
PRIVATE              : 40 41
PRIVATE_ID           : 41 42 44
RBRACE               : 26 32 34 35 59 92
RPAREN               : 19 57
RSPAREN              : 30 61 62 65 66
SELECT               : 
SEMI_COLON           : 9
STEP                 : 29
STRING_DOUBLE        : 99
STRING_SINGLE        : 98
SWITCH               : 
THEN                 : 20 22
TIMES                : 86
TO                   : 28 29
UNARY_FNC            : 71
WHILE                : 26
WITH                 : 23
error                : 

Nonterminals, with rules where they appear

array                : 58
arraydefinition      : 75
arrayelement         : 62 64
assignment           : 5
assignment_code      : 35
binaryexp            : 6 55 57 63 64
booleanexp           : 19 26 32 91 92
bracedexp            : 20 21 22 22 25 27 56
bracedexp_noscope    : 30 30 31
code                 : 3 34 35 59 0
comparisonoperator   : 47 91 92
configaccessor       : 
controlstructure     : 4
definition           : 36 38
empty                : 1
forloop              : 13
forloop_condition    : 30
fortype              : 17 31
helpertype           : 51
identifier           : 33 50 70
ifstatement          : 11
iftype               : 15 20 21 22
mathoperator         : 48
new_scope            : 28 29 30 59
nularexp             : 7 53
number               : 49
primaryexp           : 28 28 29 29 29 36 37 46 46 47 47 48 48 71 72 73 74 90 91 92
statement            : 2 3
string               : 28 29 54 67 68
stringarray          : 40
stringarrayelement   : 66 68
terminator           : 3
unaryexp             : 8 52
variable             : 37 39
whileloop            : 12
whiletype            : 16 27
withstatement        : 14
withstatementinit    : 25
withtype             : 18 24

Parsing method: LALR

state 0

    (0) S' -> . code
    (1) code -> . empty
    (2) code -> . statement
    (3) code -> . statement terminator code
    (100) empty -> .
    (4) statement -> . controlstructure
    (5) statement -> . assignment
    (6) statement -> . binaryexp
    (7) statement -> . nularexp
    (8) statement -> . unaryexp
    (11) controlstructure -> . ifstatement
    (12) controlstructure -> . whileloop
    (13) controlstructure -> . forloop
    (14) controlstructure -> . withstatement
    (35) assignment -> . assignment_code code RBRACE
    (36) assignment -> . definition EQUAL primaryexp
    (37) assignment -> . variable EQUAL primaryexp
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (20) ifstatement -> . iftype THEN bracedexp
    (21) ifstatement -> . iftype EXITWITH bracedexp
    (22) ifstatement -> . iftype THEN bracedexp ELSE bracedexp
    (27) whileloop -> . whiletype DO bracedexp
    (31) forloop -> . fortype DO bracedexp_noscope
    (25) withstatement -> . withstatementinit bracedexp
    (38) assignment_code -> . definition EQUAL LBRACE
    (39) assignment_code -> . variable EQUAL LBRACE
    (41) definition -> . PRIVATE PRIVATE_ID
    (44) variable -> . PRIVATE_ID
    (45) variable -> . GLOBAL_ID
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (40) arraydefinition -> . PRIVATE stringarray
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (24) withstatementinit -> . withtype DO
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (23) withtype -> . WITH NAMESPACE

    $end            reduce using rule 100 (empty -> .)
    NULAR_FNC       shift and go to state 17
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    PRIVATE         shift and go to state 30
    PRIVATE_ID      shift and go to state 31
    GLOBAL_ID       shift and go to state 32
    LPAREN          shift and go to state 36
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 41
    WITH            shift and go to state 48

    code                           shift and go to state 1
    empty                          shift and go to state 2
    statement                      shift and go to state 3
    controlstructure               shift and go to state 4
    assignment                     shift and go to state 5
    binaryexp                      shift and go to state 6
    nularexp                       shift and go to state 7
    unaryexp                       shift and go to state 8
    ifstatement                    shift and go to state 9
    whileloop                      shift and go to state 10
    forloop                        shift and go to state 11
    withstatement                  shift and go to state 12
    assignment_code                shift and go to state 13
    definition                     shift and go to state 14
    primaryexp                     shift and go to state 15
    variable                       shift and go to state 16
    identifier                     shift and go to state 18
    arraydefinition                shift and go to state 23
    iftype                         shift and go to state 24
    bracedexp                      shift and go to state 25
    whiletype                      shift and go to state 26
    fortype                        shift and go to state 27
    withstatementinit              shift and go to state 28
    number                         shift and go to state 33
    helpertype                     shift and go to state 34
    string                         shift and go to state 35
    array                          shift and go to state 37
    withtype                       shift and go to state 42

state 1

    (0) S' -> code .



state 2

    (1) code -> empty .

    $end            reduce using rule 1 (code -> empty .)
    RBRACE          reduce using rule 1 (code -> empty .)


state 3

    (2) code -> statement .
    (3) code -> statement . terminator code
    (9) terminator -> . SEMI_COLON
    (10) terminator -> . COMMA

    $end            reduce using rule 2 (code -> statement .)
    RBRACE          reduce using rule 2 (code -> statement .)
    SEMI_COLON      shift and go to state 50
    COMMA           shift and go to state 51

    terminator                     shift and go to state 49

state 4

    (4) statement -> controlstructure .

    SEMI_COLON      reduce using rule 4 (statement -> controlstructure .)
    COMMA           reduce using rule 4 (statement -> controlstructure .)
    $end            reduce using rule 4 (statement -> controlstructure .)
    RBRACE          reduce using rule 4 (statement -> controlstructure .)


state 5

    (5) statement -> assignment .

    SEMI_COLON      reduce using rule 5 (statement -> assignment .)
    COMMA           reduce using rule 5 (statement -> assignment .)
    $end            reduce using rule 5 (statement -> assignment .)
    RBRACE          reduce using rule 5 (statement -> assignment .)


state 6

    (6) statement -> binaryexp .
    (55) primaryexp -> binaryexp .

    SEMI_COLON      reduce using rule 6 (statement -> binaryexp .)
    COMMA           reduce using rule 6 (statement -> binaryexp .)
    $end            reduce using rule 6 (statement -> binaryexp .)
    RBRACE          reduce using rule 6 (statement -> binaryexp .)
    BINARY_FNC      reduce using rule 55 (primaryexp -> binaryexp .)
    LT              reduce using rule 55 (primaryexp -> binaryexp .)
    GT              reduce using rule 55 (primaryexp -> binaryexp .)
    LTE             reduce using rule 55 (primaryexp -> binaryexp .)
    GTE             reduce using rule 55 (primaryexp -> binaryexp .)
    EQUALITY        reduce using rule 55 (primaryexp -> binaryexp .)
    INEQUALITY      reduce using rule 55 (primaryexp -> binaryexp .)
    AND             reduce using rule 55 (primaryexp -> binaryexp .)
    OR              reduce using rule 55 (primaryexp -> binaryexp .)
    PLUS            reduce using rule 55 (primaryexp -> binaryexp .)
    MINUS           reduce using rule 55 (primaryexp -> binaryexp .)
    TIMES           reduce using rule 55 (primaryexp -> binaryexp .)
    DIVIDE          reduce using rule 55 (primaryexp -> binaryexp .)
    MOD             reduce using rule 55 (primaryexp -> binaryexp .)
    POW             reduce using rule 55 (primaryexp -> binaryexp .)


state 7

    (7) statement -> nularexp .
    (53) primaryexp -> nularexp .

    SEMI_COLON      reduce using rule 7 (statement -> nularexp .)
    COMMA           reduce using rule 7 (statement -> nularexp .)
    $end            reduce using rule 7 (statement -> nularexp .)
    RBRACE          reduce using rule 7 (statement -> nularexp .)
    BINARY_FNC      reduce using rule 53 (primaryexp -> nularexp .)
    LT              reduce using rule 53 (primaryexp -> nularexp .)
    GT              reduce using rule 53 (primaryexp -> nularexp .)
    LTE             reduce using rule 53 (primaryexp -> nularexp .)
    GTE             reduce using rule 53 (primaryexp -> nularexp .)
    EQUALITY        reduce using rule 53 (primaryexp -> nularexp .)
    INEQUALITY      reduce using rule 53 (primaryexp -> nularexp .)
    AND             reduce using rule 53 (primaryexp -> nularexp .)
    OR              reduce using rule 53 (primaryexp -> nularexp .)
    PLUS            reduce using rule 53 (primaryexp -> nularexp .)
    MINUS           reduce using rule 53 (primaryexp -> nularexp .)
    TIMES           reduce using rule 53 (primaryexp -> nularexp .)
    DIVIDE          reduce using rule 53 (primaryexp -> nularexp .)
    MOD             reduce using rule 53 (primaryexp -> nularexp .)
    POW             reduce using rule 53 (primaryexp -> nularexp .)


state 8

    (8) statement -> unaryexp .
    (52) primaryexp -> unaryexp .

    SEMI_COLON      reduce using rule 8 (statement -> unaryexp .)
    COMMA           reduce using rule 8 (statement -> unaryexp .)
    $end            reduce using rule 8 (statement -> unaryexp .)
    RBRACE          reduce using rule 8 (statement -> unaryexp .)
    BINARY_FNC      reduce using rule 52 (primaryexp -> unaryexp .)
    LT              reduce using rule 52 (primaryexp -> unaryexp .)
    GT              reduce using rule 52 (primaryexp -> unaryexp .)
    LTE             reduce using rule 52 (primaryexp -> unaryexp .)
    GTE             reduce using rule 52 (primaryexp -> unaryexp .)
    EQUALITY        reduce using rule 52 (primaryexp -> unaryexp .)
    INEQUALITY      reduce using rule 52 (primaryexp -> unaryexp .)
    AND             reduce using rule 52 (primaryexp -> unaryexp .)
    OR              reduce using rule 52 (primaryexp -> unaryexp .)
    PLUS            reduce using rule 52 (primaryexp -> unaryexp .)
    MINUS           reduce using rule 52 (primaryexp -> unaryexp .)
    TIMES           reduce using rule 52 (primaryexp -> unaryexp .)
    DIVIDE          reduce using rule 52 (primaryexp -> unaryexp .)
    MOD             reduce using rule 52 (primaryexp -> unaryexp .)
    POW             reduce using rule 52 (primaryexp -> unaryexp .)


state 9

    (11) controlstructure -> ifstatement .

    SEMI_COLON      reduce using rule 11 (controlstructure -> ifstatement .)
    COMMA           reduce using rule 11 (controlstructure -> ifstatement .)
    $end            reduce using rule 11 (controlstructure -> ifstatement .)
    RBRACE          reduce using rule 11 (controlstructure -> ifstatement .)


state 10

    (12) controlstructure -> whileloop .

    SEMI_COLON      reduce using rule 12 (controlstructure -> whileloop .)
    COMMA           reduce using rule 12 (controlstructure -> whileloop .)
    $end            reduce using rule 12 (controlstructure -> whileloop .)
    RBRACE          reduce using rule 12 (controlstructure -> whileloop .)


state 11

    (13) controlstructure -> forloop .

    SEMI_COLON      reduce using rule 13 (controlstructure -> forloop .)
    COMMA           reduce using rule 13 (controlstructure -> forloop .)
    $end            reduce using rule 13 (controlstructure -> forloop .)
    RBRACE          reduce using rule 13 (controlstructure -> forloop .)


state 12

    (14) controlstructure -> withstatement .

    SEMI_COLON      reduce using rule 14 (controlstructure -> withstatement .)
    COMMA           reduce using rule 14 (controlstructure -> withstatement .)
    $end            reduce using rule 14 (controlstructure -> withstatement .)
    RBRACE          reduce using rule 14 (controlstructure -> withstatement .)


state 13

    (35) assignment -> assignment_code . code RBRACE
    (1) code -> . empty
    (2) code -> . statement
    (3) code -> . statement terminator code
    (100) empty -> .
    (4) statement -> . controlstructure
    (5) statement -> . assignment
    (6) statement -> . binaryexp
    (7) statement -> . nularexp
    (8) statement -> . unaryexp
    (11) controlstructure -> . ifstatement
    (12) controlstructure -> . whileloop
    (13) controlstructure -> . forloop
    (14) controlstructure -> . withstatement
    (35) assignment -> . assignment_code code RBRACE
    (36) assignment -> . definition EQUAL primaryexp
    (37) assignment -> . variable EQUAL primaryexp
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (20) ifstatement -> . iftype THEN bracedexp
    (21) ifstatement -> . iftype EXITWITH bracedexp
    (22) ifstatement -> . iftype THEN bracedexp ELSE bracedexp
    (27) whileloop -> . whiletype DO bracedexp
    (31) forloop -> . fortype DO bracedexp_noscope
    (25) withstatement -> . withstatementinit bracedexp
    (38) assignment_code -> . definition EQUAL LBRACE
    (39) assignment_code -> . variable EQUAL LBRACE
    (41) definition -> . PRIVATE PRIVATE_ID
    (44) variable -> . PRIVATE_ID
    (45) variable -> . GLOBAL_ID
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (40) arraydefinition -> . PRIVATE stringarray
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (24) withstatementinit -> . withtype DO
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (23) withtype -> . WITH NAMESPACE

    RBRACE          reduce using rule 100 (empty -> .)
    NULAR_FNC       shift and go to state 17
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    PRIVATE         shift and go to state 30
    PRIVATE_ID      shift and go to state 31
    GLOBAL_ID       shift and go to state 32
    LPAREN          shift and go to state 36
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 41
    WITH            shift and go to state 48

    assignment_code                shift and go to state 13
    code                           shift and go to state 52
    empty                          shift and go to state 2
    statement                      shift and go to state 3
    controlstructure               shift and go to state 4
    assignment                     shift and go to state 5
    binaryexp                      shift and go to state 6
    nularexp                       shift and go to state 7
    unaryexp                       shift and go to state 8
    ifstatement                    shift and go to state 9
    whileloop                      shift and go to state 10
    forloop                        shift and go to state 11
    withstatement                  shift and go to state 12
    definition                     shift and go to state 14
    primaryexp                     shift and go to state 15
    variable                       shift and go to state 16
    identifier                     shift and go to state 18
    arraydefinition                shift and go to state 23
    iftype                         shift and go to state 24
    bracedexp                      shift and go to state 25
    whiletype                      shift and go to state 26
    fortype                        shift and go to state 27
    withstatementinit              shift and go to state 28
    number                         shift and go to state 33
    helpertype                     shift and go to state 34
    string                         shift and go to state 35
    array                          shift and go to state 37
    withtype                       shift and go to state 42

state 14

    (36) assignment -> definition . EQUAL primaryexp
    (38) assignment_code -> definition . EQUAL LBRACE

    EQUAL           shift and go to state 53


state 15

    (46) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (47) binaryexp -> primaryexp . comparisonoperator primaryexp
    (48) binaryexp -> primaryexp . mathoperator primaryexp
    (76) comparisonoperator -> . LT
    (77) comparisonoperator -> . GT
    (78) comparisonoperator -> . LTE
    (79) comparisonoperator -> . GTE
    (80) comparisonoperator -> . EQUALITY
    (81) comparisonoperator -> . INEQUALITY
    (82) comparisonoperator -> . AND
    (83) comparisonoperator -> . OR
    (84) mathoperator -> . PLUS
    (85) mathoperator -> . MINUS
    (86) mathoperator -> . TIMES
    (87) mathoperator -> . DIVIDE
    (88) mathoperator -> . MOD
    (89) mathoperator -> . POW

    BINARY_FNC      shift and go to state 54
    LT              shift and go to state 57
    GT              shift and go to state 58
    LTE             shift and go to state 59
    GTE             shift and go to state 60
    EQUALITY        shift and go to state 61
    INEQUALITY      shift and go to state 62
    AND             shift and go to state 63
    OR              shift and go to state 64
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POW             shift and go to state 70

    comparisonoperator             shift and go to state 55
    mathoperator                   shift and go to state 56

state 16

    (37) assignment -> variable . EQUAL primaryexp
    (39) assignment_code -> variable . EQUAL LBRACE

    EQUAL           shift and go to state 71


state 17

    (69) nularexp -> NULAR_FNC .

    SEMI_COLON      reduce using rule 69 (nularexp -> NULAR_FNC .)
    COMMA           reduce using rule 69 (nularexp -> NULAR_FNC .)
    $end            reduce using rule 69 (nularexp -> NULAR_FNC .)
    BINARY_FNC      reduce using rule 69 (nularexp -> NULAR_FNC .)
    LT              reduce using rule 69 (nularexp -> NULAR_FNC .)
    GT              reduce using rule 69 (nularexp -> NULAR_FNC .)
    LTE             reduce using rule 69 (nularexp -> NULAR_FNC .)
    GTE             reduce using rule 69 (nularexp -> NULAR_FNC .)
    EQUALITY        reduce using rule 69 (nularexp -> NULAR_FNC .)
    INEQUALITY      reduce using rule 69 (nularexp -> NULAR_FNC .)
    AND             reduce using rule 69 (nularexp -> NULAR_FNC .)
    OR              reduce using rule 69 (nularexp -> NULAR_FNC .)
    PLUS            reduce using rule 69 (nularexp -> NULAR_FNC .)
    MINUS           reduce using rule 69 (nularexp -> NULAR_FNC .)
    TIMES           reduce using rule 69 (nularexp -> NULAR_FNC .)
    DIVIDE          reduce using rule 69 (nularexp -> NULAR_FNC .)
    MOD             reduce using rule 69 (nularexp -> NULAR_FNC .)
    POW             reduce using rule 69 (nularexp -> NULAR_FNC .)
    RBRACE          reduce using rule 69 (nularexp -> NULAR_FNC .)
    RPAREN          reduce using rule 69 (nularexp -> NULAR_FNC .)
    RSPAREN         reduce using rule 69 (nularexp -> NULAR_FNC .)
    TO              reduce using rule 69 (nularexp -> NULAR_FNC .)
    STEP            reduce using rule 69 (nularexp -> NULAR_FNC .)
    DO              reduce using rule 69 (nularexp -> NULAR_FNC .)


state 18

    (70) nularexp -> identifier .
    (50) primaryexp -> identifier .

  ! reduce/reduce conflict for BINARY_FNC resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for LT resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for GT resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for LTE resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for GTE resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for EQUALITY resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for INEQUALITY resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for AND resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for OR resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for PLUS resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for MINUS resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for TIMES resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for MOD resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for POW resolved using rule 50 (primaryexp -> identifier .)
    SEMI_COLON      reduce using rule 70 (nularexp -> identifier .)
    COMMA           reduce using rule 70 (nularexp -> identifier .)
    $end            reduce using rule 70 (nularexp -> identifier .)
    RBRACE          reduce using rule 70 (nularexp -> identifier .)
    BINARY_FNC      reduce using rule 50 (primaryexp -> identifier .)
    LT              reduce using rule 50 (primaryexp -> identifier .)
    GT              reduce using rule 50 (primaryexp -> identifier .)
    LTE             reduce using rule 50 (primaryexp -> identifier .)
    GTE             reduce using rule 50 (primaryexp -> identifier .)
    EQUALITY        reduce using rule 50 (primaryexp -> identifier .)
    INEQUALITY      reduce using rule 50 (primaryexp -> identifier .)
    AND             reduce using rule 50 (primaryexp -> identifier .)
    OR              reduce using rule 50 (primaryexp -> identifier .)
    PLUS            reduce using rule 50 (primaryexp -> identifier .)
    MINUS           reduce using rule 50 (primaryexp -> identifier .)
    TIMES           reduce using rule 50 (primaryexp -> identifier .)
    DIVIDE          reduce using rule 50 (primaryexp -> identifier .)
    MOD             reduce using rule 50 (primaryexp -> identifier .)
    POW             reduce using rule 50 (primaryexp -> identifier .)

  ! BINARY_FNC      [ reduce using rule 70 (nularexp -> identifier .) ]
  ! LT              [ reduce using rule 70 (nularexp -> identifier .) ]
  ! GT              [ reduce using rule 70 (nularexp -> identifier .) ]
  ! LTE             [ reduce using rule 70 (nularexp -> identifier .) ]
  ! GTE             [ reduce using rule 70 (nularexp -> identifier .) ]
  ! EQUALITY        [ reduce using rule 70 (nularexp -> identifier .) ]
  ! INEQUALITY      [ reduce using rule 70 (nularexp -> identifier .) ]
  ! AND             [ reduce using rule 70 (nularexp -> identifier .) ]
  ! OR              [ reduce using rule 70 (nularexp -> identifier .) ]
  ! PLUS            [ reduce using rule 70 (nularexp -> identifier .) ]
  ! MINUS           [ reduce using rule 70 (nularexp -> identifier .) ]
  ! TIMES           [ reduce using rule 70 (nularexp -> identifier .) ]
  ! DIVIDE          [ reduce using rule 70 (nularexp -> identifier .) ]
  ! MOD             [ reduce using rule 70 (nularexp -> identifier .) ]
  ! POW             [ reduce using rule 70 (nularexp -> identifier .) ]


state 19

    (71) unaryexp -> UNARY_FNC . primaryexp
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (40) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    PRIVATE_ID      shift and go to state 77
    GLOBAL_ID       shift and go to state 78
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 41
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    WITH            shift and go to state 48
    PRIVATE         shift and go to state 83

    primaryexp                     shift and go to state 72
    number                         shift and go to state 33
    identifier                     shift and go to state 73
    helpertype                     shift and go to state 34
    unaryexp                       shift and go to state 74
    nularexp                       shift and go to state 75
    string                         shift and go to state 35
    binaryexp                      shift and go to state 76
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 79
    whiletype                      shift and go to state 80
    fortype                        shift and go to state 81
    withtype                       shift and go to state 82
    arraydefinition                shift and go to state 23

state 20

    (72) unaryexp -> PLUS . primaryexp
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (40) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    PRIVATE_ID      shift and go to state 77
    GLOBAL_ID       shift and go to state 78
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 41
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    WITH            shift and go to state 48
    PRIVATE         shift and go to state 83

    primaryexp                     shift and go to state 84
    number                         shift and go to state 33
    identifier                     shift and go to state 73
    helpertype                     shift and go to state 34
    unaryexp                       shift and go to state 74
    nularexp                       shift and go to state 75
    string                         shift and go to state 35
    binaryexp                      shift and go to state 76
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 79
    whiletype                      shift and go to state 80
    fortype                        shift and go to state 81
    withtype                       shift and go to state 82
    arraydefinition                shift and go to state 23

state 21

    (73) unaryexp -> MINUS . primaryexp
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (40) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    PRIVATE_ID      shift and go to state 77
    GLOBAL_ID       shift and go to state 78
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 41
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    WITH            shift and go to state 48
    PRIVATE         shift and go to state 83

    primaryexp                     shift and go to state 85
    number                         shift and go to state 33
    identifier                     shift and go to state 73
    helpertype                     shift and go to state 34
    unaryexp                       shift and go to state 74
    nularexp                       shift and go to state 75
    string                         shift and go to state 35
    binaryexp                      shift and go to state 76
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 79
    whiletype                      shift and go to state 80
    fortype                        shift and go to state 81
    withtype                       shift and go to state 82
    arraydefinition                shift and go to state 23

state 22

    (74) unaryexp -> NOT . primaryexp
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (40) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    PRIVATE_ID      shift and go to state 77
    GLOBAL_ID       shift and go to state 78
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 41
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    WITH            shift and go to state 48
    PRIVATE         shift and go to state 83

    primaryexp                     shift and go to state 86
    number                         shift and go to state 33
    identifier                     shift and go to state 73
    helpertype                     shift and go to state 34
    unaryexp                       shift and go to state 74
    nularexp                       shift and go to state 75
    string                         shift and go to state 35
    binaryexp                      shift and go to state 76
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 79
    whiletype                      shift and go to state 80
    fortype                        shift and go to state 81
    withtype                       shift and go to state 82
    arraydefinition                shift and go to state 23

state 23

    (75) unaryexp -> arraydefinition .

    SEMI_COLON      reduce using rule 75 (unaryexp -> arraydefinition .)
    COMMA           reduce using rule 75 (unaryexp -> arraydefinition .)
    $end            reduce using rule 75 (unaryexp -> arraydefinition .)
    BINARY_FNC      reduce using rule 75 (unaryexp -> arraydefinition .)
    LT              reduce using rule 75 (unaryexp -> arraydefinition .)
    GT              reduce using rule 75 (unaryexp -> arraydefinition .)
    LTE             reduce using rule 75 (unaryexp -> arraydefinition .)
    GTE             reduce using rule 75 (unaryexp -> arraydefinition .)
    EQUALITY        reduce using rule 75 (unaryexp -> arraydefinition .)
    INEQUALITY      reduce using rule 75 (unaryexp -> arraydefinition .)
    AND             reduce using rule 75 (unaryexp -> arraydefinition .)
    OR              reduce using rule 75 (unaryexp -> arraydefinition .)
    PLUS            reduce using rule 75 (unaryexp -> arraydefinition .)
    MINUS           reduce using rule 75 (unaryexp -> arraydefinition .)
    TIMES           reduce using rule 75 (unaryexp -> arraydefinition .)
    DIVIDE          reduce using rule 75 (unaryexp -> arraydefinition .)
    MOD             reduce using rule 75 (unaryexp -> arraydefinition .)
    POW             reduce using rule 75 (unaryexp -> arraydefinition .)
    RBRACE          reduce using rule 75 (unaryexp -> arraydefinition .)
    RPAREN          reduce using rule 75 (unaryexp -> arraydefinition .)
    RSPAREN         reduce using rule 75 (unaryexp -> arraydefinition .)
    TO              reduce using rule 75 (unaryexp -> arraydefinition .)
    STEP            reduce using rule 75 (unaryexp -> arraydefinition .)
    DO              reduce using rule 75 (unaryexp -> arraydefinition .)


state 24

    (20) ifstatement -> iftype . THEN bracedexp
    (21) ifstatement -> iftype . EXITWITH bracedexp
    (22) ifstatement -> iftype . THEN bracedexp ELSE bracedexp
    (15) helpertype -> iftype .

    THEN            shift and go to state 87
    EXITWITH        shift and go to state 88
    BINARY_FNC      reduce using rule 15 (helpertype -> iftype .)
    LT              reduce using rule 15 (helpertype -> iftype .)
    GT              reduce using rule 15 (helpertype -> iftype .)
    LTE             reduce using rule 15 (helpertype -> iftype .)
    GTE             reduce using rule 15 (helpertype -> iftype .)
    EQUALITY        reduce using rule 15 (helpertype -> iftype .)
    INEQUALITY      reduce using rule 15 (helpertype -> iftype .)
    AND             reduce using rule 15 (helpertype -> iftype .)
    OR              reduce using rule 15 (helpertype -> iftype .)
    PLUS            reduce using rule 15 (helpertype -> iftype .)
    MINUS           reduce using rule 15 (helpertype -> iftype .)
    TIMES           reduce using rule 15 (helpertype -> iftype .)
    DIVIDE          reduce using rule 15 (helpertype -> iftype .)
    MOD             reduce using rule 15 (helpertype -> iftype .)
    POW             reduce using rule 15 (helpertype -> iftype .)


state 25

    (56) primaryexp -> bracedexp .

    BINARY_FNC      reduce using rule 56 (primaryexp -> bracedexp .)
    LT              reduce using rule 56 (primaryexp -> bracedexp .)
    GT              reduce using rule 56 (primaryexp -> bracedexp .)
    LTE             reduce using rule 56 (primaryexp -> bracedexp .)
    GTE             reduce using rule 56 (primaryexp -> bracedexp .)
    EQUALITY        reduce using rule 56 (primaryexp -> bracedexp .)
    INEQUALITY      reduce using rule 56 (primaryexp -> bracedexp .)
    AND             reduce using rule 56 (primaryexp -> bracedexp .)
    OR              reduce using rule 56 (primaryexp -> bracedexp .)
    PLUS            reduce using rule 56 (primaryexp -> bracedexp .)
    MINUS           reduce using rule 56 (primaryexp -> bracedexp .)
    TIMES           reduce using rule 56 (primaryexp -> bracedexp .)
    DIVIDE          reduce using rule 56 (primaryexp -> bracedexp .)
    MOD             reduce using rule 56 (primaryexp -> bracedexp .)
    POW             reduce using rule 56 (primaryexp -> bracedexp .)
    SEMI_COLON      reduce using rule 56 (primaryexp -> bracedexp .)
    COMMA           reduce using rule 56 (primaryexp -> bracedexp .)
    $end            reduce using rule 56 (primaryexp -> bracedexp .)
    RBRACE          reduce using rule 56 (primaryexp -> bracedexp .)
    RPAREN          reduce using rule 56 (primaryexp -> bracedexp .)
    RSPAREN         reduce using rule 56 (primaryexp -> bracedexp .)
    TO              reduce using rule 56 (primaryexp -> bracedexp .)
    STEP            reduce using rule 56 (primaryexp -> bracedexp .)
    DO              reduce using rule 56 (primaryexp -> bracedexp .)


state 26

    (27) whileloop -> whiletype . DO bracedexp
    (16) helpertype -> whiletype .

    DO              shift and go to state 89
    BINARY_FNC      reduce using rule 16 (helpertype -> whiletype .)
    LT              reduce using rule 16 (helpertype -> whiletype .)
    GT              reduce using rule 16 (helpertype -> whiletype .)
    LTE             reduce using rule 16 (helpertype -> whiletype .)
    GTE             reduce using rule 16 (helpertype -> whiletype .)
    EQUALITY        reduce using rule 16 (helpertype -> whiletype .)
    INEQUALITY      reduce using rule 16 (helpertype -> whiletype .)
    AND             reduce using rule 16 (helpertype -> whiletype .)
    OR              reduce using rule 16 (helpertype -> whiletype .)
    PLUS            reduce using rule 16 (helpertype -> whiletype .)
    MINUS           reduce using rule 16 (helpertype -> whiletype .)
    TIMES           reduce using rule 16 (helpertype -> whiletype .)
    DIVIDE          reduce using rule 16 (helpertype -> whiletype .)
    MOD             reduce using rule 16 (helpertype -> whiletype .)
    POW             reduce using rule 16 (helpertype -> whiletype .)


state 27

    (31) forloop -> fortype . DO bracedexp_noscope
    (17) helpertype -> fortype .

    DO              shift and go to state 90
    BINARY_FNC      reduce using rule 17 (helpertype -> fortype .)
    LT              reduce using rule 17 (helpertype -> fortype .)
    GT              reduce using rule 17 (helpertype -> fortype .)
    LTE             reduce using rule 17 (helpertype -> fortype .)
    GTE             reduce using rule 17 (helpertype -> fortype .)
    EQUALITY        reduce using rule 17 (helpertype -> fortype .)
    INEQUALITY      reduce using rule 17 (helpertype -> fortype .)
    AND             reduce using rule 17 (helpertype -> fortype .)
    OR              reduce using rule 17 (helpertype -> fortype .)
    PLUS            reduce using rule 17 (helpertype -> fortype .)
    MINUS           reduce using rule 17 (helpertype -> fortype .)
    TIMES           reduce using rule 17 (helpertype -> fortype .)
    DIVIDE          reduce using rule 17 (helpertype -> fortype .)
    MOD             reduce using rule 17 (helpertype -> fortype .)
    POW             reduce using rule 17 (helpertype -> fortype .)


state 28

    (25) withstatement -> withstatementinit . bracedexp
    (59) bracedexp -> . LBRACE new_scope code RBRACE

    LBRACE          shift and go to state 29

    bracedexp                      shift and go to state 91

state 29

    (59) bracedexp -> LBRACE . new_scope code RBRACE
    (60) new_scope -> .

    NULAR_FNC       reduce using rule 60 (new_scope -> .)
    UNARY_FNC       reduce using rule 60 (new_scope -> .)
    PLUS            reduce using rule 60 (new_scope -> .)
    MINUS           reduce using rule 60 (new_scope -> .)
    NOT             reduce using rule 60 (new_scope -> .)
    PRIVATE         reduce using rule 60 (new_scope -> .)
    PRIVATE_ID      reduce using rule 60 (new_scope -> .)
    GLOBAL_ID       reduce using rule 60 (new_scope -> .)
    LPAREN          reduce using rule 60 (new_scope -> .)
    IF              reduce using rule 60 (new_scope -> .)
    WHILE           reduce using rule 60 (new_scope -> .)
    FOR             reduce using rule 60 (new_scope -> .)
    NUMBER_REAL     reduce using rule 60 (new_scope -> .)
    NUMBER_EXP      reduce using rule 60 (new_scope -> .)
    NUMBER_HEX      reduce using rule 60 (new_scope -> .)
    STRING_SINGLE   reduce using rule 60 (new_scope -> .)
    STRING_DOUBLE   reduce using rule 60 (new_scope -> .)
    LBRACE          reduce using rule 60 (new_scope -> .)
    LSPAREN         reduce using rule 60 (new_scope -> .)
    WITH            reduce using rule 60 (new_scope -> .)
    RBRACE          reduce using rule 60 (new_scope -> .)

    new_scope                      shift and go to state 92

state 30

    (41) definition -> PRIVATE . PRIVATE_ID
    (40) arraydefinition -> PRIVATE . stringarray
    (65) stringarray -> . LSPAREN RSPAREN
    (66) stringarray -> . LSPAREN stringarrayelement RSPAREN

    PRIVATE_ID      shift and go to state 93
    LSPAREN         shift and go to state 95

    stringarray                    shift and go to state 94

state 31

    (44) variable -> PRIVATE_ID .
    (42) identifier -> PRIVATE_ID .

    EQUAL           reduce using rule 44 (variable -> PRIVATE_ID .)
    SEMI_COLON      reduce using rule 42 (identifier -> PRIVATE_ID .)
    COMMA           reduce using rule 42 (identifier -> PRIVATE_ID .)
    $end            reduce using rule 42 (identifier -> PRIVATE_ID .)
    BINARY_FNC      reduce using rule 42 (identifier -> PRIVATE_ID .)
    LT              reduce using rule 42 (identifier -> PRIVATE_ID .)
    GT              reduce using rule 42 (identifier -> PRIVATE_ID .)
    LTE             reduce using rule 42 (identifier -> PRIVATE_ID .)
    GTE             reduce using rule 42 (identifier -> PRIVATE_ID .)
    EQUALITY        reduce using rule 42 (identifier -> PRIVATE_ID .)
    INEQUALITY      reduce using rule 42 (identifier -> PRIVATE_ID .)
    AND             reduce using rule 42 (identifier -> PRIVATE_ID .)
    OR              reduce using rule 42 (identifier -> PRIVATE_ID .)
    PLUS            reduce using rule 42 (identifier -> PRIVATE_ID .)
    MINUS           reduce using rule 42 (identifier -> PRIVATE_ID .)
    TIMES           reduce using rule 42 (identifier -> PRIVATE_ID .)
    DIVIDE          reduce using rule 42 (identifier -> PRIVATE_ID .)
    MOD             reduce using rule 42 (identifier -> PRIVATE_ID .)
    POW             reduce using rule 42 (identifier -> PRIVATE_ID .)
    RBRACE          reduce using rule 42 (identifier -> PRIVATE_ID .)


state 32

    (45) variable -> GLOBAL_ID .
    (43) identifier -> GLOBAL_ID .

    EQUAL           reduce using rule 45 (variable -> GLOBAL_ID .)
    SEMI_COLON      reduce using rule 43 (identifier -> GLOBAL_ID .)
    COMMA           reduce using rule 43 (identifier -> GLOBAL_ID .)
    $end            reduce using rule 43 (identifier -> GLOBAL_ID .)
    BINARY_FNC      reduce using rule 43 (identifier -> GLOBAL_ID .)
    LT              reduce using rule 43 (identifier -> GLOBAL_ID .)
    GT              reduce using rule 43 (identifier -> GLOBAL_ID .)
    LTE             reduce using rule 43 (identifier -> GLOBAL_ID .)
    GTE             reduce using rule 43 (identifier -> GLOBAL_ID .)
    EQUALITY        reduce using rule 43 (identifier -> GLOBAL_ID .)
    INEQUALITY      reduce using rule 43 (identifier -> GLOBAL_ID .)
    AND             reduce using rule 43 (identifier -> GLOBAL_ID .)
    OR              reduce using rule 43 (identifier -> GLOBAL_ID .)
    PLUS            reduce using rule 43 (identifier -> GLOBAL_ID .)
    MINUS           reduce using rule 43 (identifier -> GLOBAL_ID .)
    TIMES           reduce using rule 43 (identifier -> GLOBAL_ID .)
    DIVIDE          reduce using rule 43 (identifier -> GLOBAL_ID .)
    MOD             reduce using rule 43 (identifier -> GLOBAL_ID .)
    POW             reduce using rule 43 (identifier -> GLOBAL_ID .)
    RBRACE          reduce using rule 43 (identifier -> GLOBAL_ID .)


state 33

    (49) primaryexp -> number .

    BINARY_FNC      reduce using rule 49 (primaryexp -> number .)
    LT              reduce using rule 49 (primaryexp -> number .)
    GT              reduce using rule 49 (primaryexp -> number .)
    LTE             reduce using rule 49 (primaryexp -> number .)
    GTE             reduce using rule 49 (primaryexp -> number .)
    EQUALITY        reduce using rule 49 (primaryexp -> number .)
    INEQUALITY      reduce using rule 49 (primaryexp -> number .)
    AND             reduce using rule 49 (primaryexp -> number .)
    OR              reduce using rule 49 (primaryexp -> number .)
    PLUS            reduce using rule 49 (primaryexp -> number .)
    MINUS           reduce using rule 49 (primaryexp -> number .)
    TIMES           reduce using rule 49 (primaryexp -> number .)
    DIVIDE          reduce using rule 49 (primaryexp -> number .)
    MOD             reduce using rule 49 (primaryexp -> number .)
    POW             reduce using rule 49 (primaryexp -> number .)
    SEMI_COLON      reduce using rule 49 (primaryexp -> number .)
    COMMA           reduce using rule 49 (primaryexp -> number .)
    $end            reduce using rule 49 (primaryexp -> number .)
    RBRACE          reduce using rule 49 (primaryexp -> number .)
    RPAREN          reduce using rule 49 (primaryexp -> number .)
    RSPAREN         reduce using rule 49 (primaryexp -> number .)
    TO              reduce using rule 49 (primaryexp -> number .)
    STEP            reduce using rule 49 (primaryexp -> number .)
    DO              reduce using rule 49 (primaryexp -> number .)


state 34

    (51) primaryexp -> helpertype .

    BINARY_FNC      reduce using rule 51 (primaryexp -> helpertype .)
    LT              reduce using rule 51 (primaryexp -> helpertype .)
    GT              reduce using rule 51 (primaryexp -> helpertype .)
    LTE             reduce using rule 51 (primaryexp -> helpertype .)
    GTE             reduce using rule 51 (primaryexp -> helpertype .)
    EQUALITY        reduce using rule 51 (primaryexp -> helpertype .)
    INEQUALITY      reduce using rule 51 (primaryexp -> helpertype .)
    AND             reduce using rule 51 (primaryexp -> helpertype .)
    OR              reduce using rule 51 (primaryexp -> helpertype .)
    PLUS            reduce using rule 51 (primaryexp -> helpertype .)
    MINUS           reduce using rule 51 (primaryexp -> helpertype .)
    TIMES           reduce using rule 51 (primaryexp -> helpertype .)
    DIVIDE          reduce using rule 51 (primaryexp -> helpertype .)
    MOD             reduce using rule 51 (primaryexp -> helpertype .)
    POW             reduce using rule 51 (primaryexp -> helpertype .)
    SEMI_COLON      reduce using rule 51 (primaryexp -> helpertype .)
    COMMA           reduce using rule 51 (primaryexp -> helpertype .)
    $end            reduce using rule 51 (primaryexp -> helpertype .)
    RBRACE          reduce using rule 51 (primaryexp -> helpertype .)
    RPAREN          reduce using rule 51 (primaryexp -> helpertype .)
    RSPAREN         reduce using rule 51 (primaryexp -> helpertype .)
    TO              reduce using rule 51 (primaryexp -> helpertype .)
    STEP            reduce using rule 51 (primaryexp -> helpertype .)
    DO              reduce using rule 51 (primaryexp -> helpertype .)


state 35

    (54) primaryexp -> string .

    BINARY_FNC      reduce using rule 54 (primaryexp -> string .)
    LT              reduce using rule 54 (primaryexp -> string .)
    GT              reduce using rule 54 (primaryexp -> string .)
    LTE             reduce using rule 54 (primaryexp -> string .)
    GTE             reduce using rule 54 (primaryexp -> string .)
    EQUALITY        reduce using rule 54 (primaryexp -> string .)
    INEQUALITY      reduce using rule 54 (primaryexp -> string .)
    AND             reduce using rule 54 (primaryexp -> string .)
    OR              reduce using rule 54 (primaryexp -> string .)
    PLUS            reduce using rule 54 (primaryexp -> string .)
    MINUS           reduce using rule 54 (primaryexp -> string .)
    TIMES           reduce using rule 54 (primaryexp -> string .)
    DIVIDE          reduce using rule 54 (primaryexp -> string .)
    MOD             reduce using rule 54 (primaryexp -> string .)
    POW             reduce using rule 54 (primaryexp -> string .)
    SEMI_COLON      reduce using rule 54 (primaryexp -> string .)
    COMMA           reduce using rule 54 (primaryexp -> string .)
    $end            reduce using rule 54 (primaryexp -> string .)
    RBRACE          reduce using rule 54 (primaryexp -> string .)
    RPAREN          reduce using rule 54 (primaryexp -> string .)
    RSPAREN         reduce using rule 54 (primaryexp -> string .)
    TO              reduce using rule 54 (primaryexp -> string .)
    STEP            reduce using rule 54 (primaryexp -> string .)
    DO              reduce using rule 54 (primaryexp -> string .)


state 36

    (57) primaryexp -> LPAREN . binaryexp RPAREN
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (40) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    PRIVATE_ID      shift and go to state 77
    GLOBAL_ID       shift and go to state 78
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 41
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    WITH            shift and go to state 48
    PRIVATE         shift and go to state 83

    binaryexp                      shift and go to state 96
    primaryexp                     shift and go to state 15
    number                         shift and go to state 33
    identifier                     shift and go to state 73
    helpertype                     shift and go to state 34
    unaryexp                       shift and go to state 74
    nularexp                       shift and go to state 75
    string                         shift and go to state 35
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 79
    whiletype                      shift and go to state 80
    fortype                        shift and go to state 81
    withtype                       shift and go to state 82
    arraydefinition                shift and go to state 23

state 37

    (58) primaryexp -> array .

    BINARY_FNC      reduce using rule 58 (primaryexp -> array .)
    LT              reduce using rule 58 (primaryexp -> array .)
    GT              reduce using rule 58 (primaryexp -> array .)
    LTE             reduce using rule 58 (primaryexp -> array .)
    GTE             reduce using rule 58 (primaryexp -> array .)
    EQUALITY        reduce using rule 58 (primaryexp -> array .)
    INEQUALITY      reduce using rule 58 (primaryexp -> array .)
    AND             reduce using rule 58 (primaryexp -> array .)
    OR              reduce using rule 58 (primaryexp -> array .)
    PLUS            reduce using rule 58 (primaryexp -> array .)
    MINUS           reduce using rule 58 (primaryexp -> array .)
    TIMES           reduce using rule 58 (primaryexp -> array .)
    DIVIDE          reduce using rule 58 (primaryexp -> array .)
    MOD             reduce using rule 58 (primaryexp -> array .)
    POW             reduce using rule 58 (primaryexp -> array .)
    SEMI_COLON      reduce using rule 58 (primaryexp -> array .)
    COMMA           reduce using rule 58 (primaryexp -> array .)
    $end            reduce using rule 58 (primaryexp -> array .)
    RBRACE          reduce using rule 58 (primaryexp -> array .)
    RPAREN          reduce using rule 58 (primaryexp -> array .)
    RSPAREN         reduce using rule 58 (primaryexp -> array .)
    TO              reduce using rule 58 (primaryexp -> array .)
    STEP            reduce using rule 58 (primaryexp -> array .)
    DO              reduce using rule 58 (primaryexp -> array .)


state 38

    (19) iftype -> IF . LPAREN booleanexp RPAREN

    LPAREN          shift and go to state 97


state 39

    (26) whiletype -> WHILE . LBRACE booleanexp RBRACE

    LBRACE          shift and go to state 98


state 40

    (28) fortype -> FOR . new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> FOR . new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> FOR . new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (60) new_scope -> .

    LSPAREN         reduce using rule 60 (new_scope -> .)
    STRING_SINGLE   reduce using rule 60 (new_scope -> .)
    STRING_DOUBLE   reduce using rule 60 (new_scope -> .)

    new_scope                      shift and go to state 99

state 41

    (61) array -> LSPAREN . RSPAREN
    (62) array -> LSPAREN . arrayelement RSPAREN
    (63) arrayelement -> . binaryexp
    (64) arrayelement -> . binaryexp COMMA arrayelement
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (40) arraydefinition -> . PRIVATE stringarray

    RSPAREN         shift and go to state 100
    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    PRIVATE_ID      shift and go to state 77
    GLOBAL_ID       shift and go to state 78
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 41
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    WITH            shift and go to state 48
    PRIVATE         shift and go to state 83

    arrayelement                   shift and go to state 101
    binaryexp                      shift and go to state 102
    primaryexp                     shift and go to state 15
    number                         shift and go to state 33
    identifier                     shift and go to state 73
    helpertype                     shift and go to state 34
    unaryexp                       shift and go to state 74
    nularexp                       shift and go to state 75
    string                         shift and go to state 35
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 79
    whiletype                      shift and go to state 80
    fortype                        shift and go to state 81
    withtype                       shift and go to state 82
    arraydefinition                shift and go to state 23

state 42

    (24) withstatementinit -> withtype . DO
    (18) helpertype -> withtype .

    DO              shift and go to state 103
    BINARY_FNC      reduce using rule 18 (helpertype -> withtype .)
    LT              reduce using rule 18 (helpertype -> withtype .)
    GT              reduce using rule 18 (helpertype -> withtype .)
    LTE             reduce using rule 18 (helpertype -> withtype .)
    GTE             reduce using rule 18 (helpertype -> withtype .)
    EQUALITY        reduce using rule 18 (helpertype -> withtype .)
    INEQUALITY      reduce using rule 18 (helpertype -> withtype .)
    AND             reduce using rule 18 (helpertype -> withtype .)
    OR              reduce using rule 18 (helpertype -> withtype .)
    PLUS            reduce using rule 18 (helpertype -> withtype .)
    MINUS           reduce using rule 18 (helpertype -> withtype .)
    TIMES           reduce using rule 18 (helpertype -> withtype .)
    DIVIDE          reduce using rule 18 (helpertype -> withtype .)
    MOD             reduce using rule 18 (helpertype -> withtype .)
    POW             reduce using rule 18 (helpertype -> withtype .)


state 43

    (95) number -> NUMBER_REAL .

    BINARY_FNC      reduce using rule 95 (number -> NUMBER_REAL .)
    LT              reduce using rule 95 (number -> NUMBER_REAL .)
    GT              reduce using rule 95 (number -> NUMBER_REAL .)
    LTE             reduce using rule 95 (number -> NUMBER_REAL .)
    GTE             reduce using rule 95 (number -> NUMBER_REAL .)
    EQUALITY        reduce using rule 95 (number -> NUMBER_REAL .)
    INEQUALITY      reduce using rule 95 (number -> NUMBER_REAL .)
    AND             reduce using rule 95 (number -> NUMBER_REAL .)
    OR              reduce using rule 95 (number -> NUMBER_REAL .)
    PLUS            reduce using rule 95 (number -> NUMBER_REAL .)
    MINUS           reduce using rule 95 (number -> NUMBER_REAL .)
    TIMES           reduce using rule 95 (number -> NUMBER_REAL .)
    DIVIDE          reduce using rule 95 (number -> NUMBER_REAL .)
    MOD             reduce using rule 95 (number -> NUMBER_REAL .)
    POW             reduce using rule 95 (number -> NUMBER_REAL .)
    SEMI_COLON      reduce using rule 95 (number -> NUMBER_REAL .)
    COMMA           reduce using rule 95 (number -> NUMBER_REAL .)
    $end            reduce using rule 95 (number -> NUMBER_REAL .)
    RBRACE          reduce using rule 95 (number -> NUMBER_REAL .)
    RPAREN          reduce using rule 95 (number -> NUMBER_REAL .)
    RSPAREN         reduce using rule 95 (number -> NUMBER_REAL .)
    TO              reduce using rule 95 (number -> NUMBER_REAL .)
    STEP            reduce using rule 95 (number -> NUMBER_REAL .)
    DO              reduce using rule 95 (number -> NUMBER_REAL .)


state 44

    (96) number -> NUMBER_EXP .

    BINARY_FNC      reduce using rule 96 (number -> NUMBER_EXP .)
    LT              reduce using rule 96 (number -> NUMBER_EXP .)
    GT              reduce using rule 96 (number -> NUMBER_EXP .)
    LTE             reduce using rule 96 (number -> NUMBER_EXP .)
    GTE             reduce using rule 96 (number -> NUMBER_EXP .)
    EQUALITY        reduce using rule 96 (number -> NUMBER_EXP .)
    INEQUALITY      reduce using rule 96 (number -> NUMBER_EXP .)
    AND             reduce using rule 96 (number -> NUMBER_EXP .)
    OR              reduce using rule 96 (number -> NUMBER_EXP .)
    PLUS            reduce using rule 96 (number -> NUMBER_EXP .)
    MINUS           reduce using rule 96 (number -> NUMBER_EXP .)
    TIMES           reduce using rule 96 (number -> NUMBER_EXP .)
    DIVIDE          reduce using rule 96 (number -> NUMBER_EXP .)
    MOD             reduce using rule 96 (number -> NUMBER_EXP .)
    POW             reduce using rule 96 (number -> NUMBER_EXP .)
    SEMI_COLON      reduce using rule 96 (number -> NUMBER_EXP .)
    COMMA           reduce using rule 96 (number -> NUMBER_EXP .)
    $end            reduce using rule 96 (number -> NUMBER_EXP .)
    RBRACE          reduce using rule 96 (number -> NUMBER_EXP .)
    RPAREN          reduce using rule 96 (number -> NUMBER_EXP .)
    RSPAREN         reduce using rule 96 (number -> NUMBER_EXP .)
    TO              reduce using rule 96 (number -> NUMBER_EXP .)
    STEP            reduce using rule 96 (number -> NUMBER_EXP .)
    DO              reduce using rule 96 (number -> NUMBER_EXP .)


state 45

    (97) number -> NUMBER_HEX .

    BINARY_FNC      reduce using rule 97 (number -> NUMBER_HEX .)
    LT              reduce using rule 97 (number -> NUMBER_HEX .)
    GT              reduce using rule 97 (number -> NUMBER_HEX .)
    LTE             reduce using rule 97 (number -> NUMBER_HEX .)
    GTE             reduce using rule 97 (number -> NUMBER_HEX .)
    EQUALITY        reduce using rule 97 (number -> NUMBER_HEX .)
    INEQUALITY      reduce using rule 97 (number -> NUMBER_HEX .)
    AND             reduce using rule 97 (number -> NUMBER_HEX .)
    OR              reduce using rule 97 (number -> NUMBER_HEX .)
    PLUS            reduce using rule 97 (number -> NUMBER_HEX .)
    MINUS           reduce using rule 97 (number -> NUMBER_HEX .)
    TIMES           reduce using rule 97 (number -> NUMBER_HEX .)
    DIVIDE          reduce using rule 97 (number -> NUMBER_HEX .)
    MOD             reduce using rule 97 (number -> NUMBER_HEX .)
    POW             reduce using rule 97 (number -> NUMBER_HEX .)
    SEMI_COLON      reduce using rule 97 (number -> NUMBER_HEX .)
    COMMA           reduce using rule 97 (number -> NUMBER_HEX .)
    $end            reduce using rule 97 (number -> NUMBER_HEX .)
    RBRACE          reduce using rule 97 (number -> NUMBER_HEX .)
    RPAREN          reduce using rule 97 (number -> NUMBER_HEX .)
    RSPAREN         reduce using rule 97 (number -> NUMBER_HEX .)
    TO              reduce using rule 97 (number -> NUMBER_HEX .)
    STEP            reduce using rule 97 (number -> NUMBER_HEX .)
    DO              reduce using rule 97 (number -> NUMBER_HEX .)


state 46

    (98) string -> STRING_SINGLE .

    BINARY_FNC      reduce using rule 98 (string -> STRING_SINGLE .)
    LT              reduce using rule 98 (string -> STRING_SINGLE .)
    GT              reduce using rule 98 (string -> STRING_SINGLE .)
    LTE             reduce using rule 98 (string -> STRING_SINGLE .)
    GTE             reduce using rule 98 (string -> STRING_SINGLE .)
    EQUALITY        reduce using rule 98 (string -> STRING_SINGLE .)
    INEQUALITY      reduce using rule 98 (string -> STRING_SINGLE .)
    AND             reduce using rule 98 (string -> STRING_SINGLE .)
    OR              reduce using rule 98 (string -> STRING_SINGLE .)
    PLUS            reduce using rule 98 (string -> STRING_SINGLE .)
    MINUS           reduce using rule 98 (string -> STRING_SINGLE .)
    TIMES           reduce using rule 98 (string -> STRING_SINGLE .)
    DIVIDE          reduce using rule 98 (string -> STRING_SINGLE .)
    MOD             reduce using rule 98 (string -> STRING_SINGLE .)
    POW             reduce using rule 98 (string -> STRING_SINGLE .)
    SEMI_COLON      reduce using rule 98 (string -> STRING_SINGLE .)
    COMMA           reduce using rule 98 (string -> STRING_SINGLE .)
    $end            reduce using rule 98 (string -> STRING_SINGLE .)
    RBRACE          reduce using rule 98 (string -> STRING_SINGLE .)
    RPAREN          reduce using rule 98 (string -> STRING_SINGLE .)
    RSPAREN         reduce using rule 98 (string -> STRING_SINGLE .)
    TO              reduce using rule 98 (string -> STRING_SINGLE .)
    STEP            reduce using rule 98 (string -> STRING_SINGLE .)
    DO              reduce using rule 98 (string -> STRING_SINGLE .)
    FROM            reduce using rule 98 (string -> STRING_SINGLE .)


state 47

    (99) string -> STRING_DOUBLE .

    BINARY_FNC      reduce using rule 99 (string -> STRING_DOUBLE .)
    LT              reduce using rule 99 (string -> STRING_DOUBLE .)
    GT              reduce using rule 99 (string -> STRING_DOUBLE .)
    LTE             reduce using rule 99 (string -> STRING_DOUBLE .)
    GTE             reduce using rule 99 (string -> STRING_DOUBLE .)
    EQUALITY        reduce using rule 99 (string -> STRING_DOUBLE .)
    INEQUALITY      reduce using rule 99 (string -> STRING_DOUBLE .)
    AND             reduce using rule 99 (string -> STRING_DOUBLE .)
    OR              reduce using rule 99 (string -> STRING_DOUBLE .)
    PLUS            reduce using rule 99 (string -> STRING_DOUBLE .)
    MINUS           reduce using rule 99 (string -> STRING_DOUBLE .)
    TIMES           reduce using rule 99 (string -> STRING_DOUBLE .)
    DIVIDE          reduce using rule 99 (string -> STRING_DOUBLE .)
    MOD             reduce using rule 99 (string -> STRING_DOUBLE .)
    POW             reduce using rule 99 (string -> STRING_DOUBLE .)
    SEMI_COLON      reduce using rule 99 (string -> STRING_DOUBLE .)
    COMMA           reduce using rule 99 (string -> STRING_DOUBLE .)
    $end            reduce using rule 99 (string -> STRING_DOUBLE .)
    RBRACE          reduce using rule 99 (string -> STRING_DOUBLE .)
    RPAREN          reduce using rule 99 (string -> STRING_DOUBLE .)
    RSPAREN         reduce using rule 99 (string -> STRING_DOUBLE .)
    TO              reduce using rule 99 (string -> STRING_DOUBLE .)
    STEP            reduce using rule 99 (string -> STRING_DOUBLE .)
    DO              reduce using rule 99 (string -> STRING_DOUBLE .)
    FROM            reduce using rule 99 (string -> STRING_DOUBLE .)


state 48

    (23) withtype -> WITH . NAMESPACE

    NAMESPACE       shift and go to state 104


state 49

    (3) code -> statement terminator . code
    (1) code -> . empty
    (2) code -> . statement
    (3) code -> . statement terminator code
    (100) empty -> .
    (4) statement -> . controlstructure
    (5) statement -> . assignment
    (6) statement -> . binaryexp
    (7) statement -> . nularexp
    (8) statement -> . unaryexp
    (11) controlstructure -> . ifstatement
    (12) controlstructure -> . whileloop
    (13) controlstructure -> . forloop
    (14) controlstructure -> . withstatement
    (35) assignment -> . assignment_code code RBRACE
    (36) assignment -> . definition EQUAL primaryexp
    (37) assignment -> . variable EQUAL primaryexp
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (20) ifstatement -> . iftype THEN bracedexp
    (21) ifstatement -> . iftype EXITWITH bracedexp
    (22) ifstatement -> . iftype THEN bracedexp ELSE bracedexp
    (27) whileloop -> . whiletype DO bracedexp
    (31) forloop -> . fortype DO bracedexp_noscope
    (25) withstatement -> . withstatementinit bracedexp
    (38) assignment_code -> . definition EQUAL LBRACE
    (39) assignment_code -> . variable EQUAL LBRACE
    (41) definition -> . PRIVATE PRIVATE_ID
    (44) variable -> . PRIVATE_ID
    (45) variable -> . GLOBAL_ID
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (40) arraydefinition -> . PRIVATE stringarray
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (24) withstatementinit -> . withtype DO
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (23) withtype -> . WITH NAMESPACE

    $end            reduce using rule 100 (empty -> .)
    RBRACE          reduce using rule 100 (empty -> .)
    NULAR_FNC       shift and go to state 17
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    PRIVATE         shift and go to state 30
    PRIVATE_ID      shift and go to state 31
    GLOBAL_ID       shift and go to state 32
    LPAREN          shift and go to state 36
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 41
    WITH            shift and go to state 48

    statement                      shift and go to state 3
    code                           shift and go to state 105
    empty                          shift and go to state 2
    controlstructure               shift and go to state 4
    assignment                     shift and go to state 5
    binaryexp                      shift and go to state 6
    nularexp                       shift and go to state 7
    unaryexp                       shift and go to state 8
    ifstatement                    shift and go to state 9
    whileloop                      shift and go to state 10
    forloop                        shift and go to state 11
    withstatement                  shift and go to state 12
    assignment_code                shift and go to state 13
    definition                     shift and go to state 14
    primaryexp                     shift and go to state 15
    variable                       shift and go to state 16
    identifier                     shift and go to state 18
    arraydefinition                shift and go to state 23
    iftype                         shift and go to state 24
    bracedexp                      shift and go to state 25
    whiletype                      shift and go to state 26
    fortype                        shift and go to state 27
    withstatementinit              shift and go to state 28
    number                         shift and go to state 33
    helpertype                     shift and go to state 34
    string                         shift and go to state 35
    array                          shift and go to state 37
    withtype                       shift and go to state 42

state 50

    (9) terminator -> SEMI_COLON .

    NULAR_FNC       reduce using rule 9 (terminator -> SEMI_COLON .)
    UNARY_FNC       reduce using rule 9 (terminator -> SEMI_COLON .)
    PLUS            reduce using rule 9 (terminator -> SEMI_COLON .)
    MINUS           reduce using rule 9 (terminator -> SEMI_COLON .)
    NOT             reduce using rule 9 (terminator -> SEMI_COLON .)
    PRIVATE         reduce using rule 9 (terminator -> SEMI_COLON .)
    PRIVATE_ID      reduce using rule 9 (terminator -> SEMI_COLON .)
    GLOBAL_ID       reduce using rule 9 (terminator -> SEMI_COLON .)
    LPAREN          reduce using rule 9 (terminator -> SEMI_COLON .)
    IF              reduce using rule 9 (terminator -> SEMI_COLON .)
    WHILE           reduce using rule 9 (terminator -> SEMI_COLON .)
    FOR             reduce using rule 9 (terminator -> SEMI_COLON .)
    NUMBER_REAL     reduce using rule 9 (terminator -> SEMI_COLON .)
    NUMBER_EXP      reduce using rule 9 (terminator -> SEMI_COLON .)
    NUMBER_HEX      reduce using rule 9 (terminator -> SEMI_COLON .)
    STRING_SINGLE   reduce using rule 9 (terminator -> SEMI_COLON .)
    STRING_DOUBLE   reduce using rule 9 (terminator -> SEMI_COLON .)
    LBRACE          reduce using rule 9 (terminator -> SEMI_COLON .)
    LSPAREN         reduce using rule 9 (terminator -> SEMI_COLON .)
    WITH            reduce using rule 9 (terminator -> SEMI_COLON .)
    $end            reduce using rule 9 (terminator -> SEMI_COLON .)
    RBRACE          reduce using rule 9 (terminator -> SEMI_COLON .)


state 51

    (10) terminator -> COMMA .

    NULAR_FNC       reduce using rule 10 (terminator -> COMMA .)
    UNARY_FNC       reduce using rule 10 (terminator -> COMMA .)
    PLUS            reduce using rule 10 (terminator -> COMMA .)
    MINUS           reduce using rule 10 (terminator -> COMMA .)
    NOT             reduce using rule 10 (terminator -> COMMA .)
    PRIVATE         reduce using rule 10 (terminator -> COMMA .)
    PRIVATE_ID      reduce using rule 10 (terminator -> COMMA .)
    GLOBAL_ID       reduce using rule 10 (terminator -> COMMA .)
    LPAREN          reduce using rule 10 (terminator -> COMMA .)
    IF              reduce using rule 10 (terminator -> COMMA .)
    WHILE           reduce using rule 10 (terminator -> COMMA .)
    FOR             reduce using rule 10 (terminator -> COMMA .)
    NUMBER_REAL     reduce using rule 10 (terminator -> COMMA .)
    NUMBER_EXP      reduce using rule 10 (terminator -> COMMA .)
    NUMBER_HEX      reduce using rule 10 (terminator -> COMMA .)
    STRING_SINGLE   reduce using rule 10 (terminator -> COMMA .)
    STRING_DOUBLE   reduce using rule 10 (terminator -> COMMA .)
    LBRACE          reduce using rule 10 (terminator -> COMMA .)
    LSPAREN         reduce using rule 10 (terminator -> COMMA .)
    WITH            reduce using rule 10 (terminator -> COMMA .)
    $end            reduce using rule 10 (terminator -> COMMA .)
    RBRACE          reduce using rule 10 (terminator -> COMMA .)


state 52

    (35) assignment -> assignment_code code . RBRACE

    RBRACE          shift and go to state 106


state 53

    (36) assignment -> definition EQUAL . primaryexp
    (38) assignment_code -> definition EQUAL . LBRACE
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (40) arraydefinition -> . PRIVATE stringarray

    LBRACE          shift and go to state 108
    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    PRIVATE_ID      shift and go to state 77
    GLOBAL_ID       shift and go to state 78
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LSPAREN         shift and go to state 41
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    WITH            shift and go to state 48
    PRIVATE         shift and go to state 83

    primaryexp                     shift and go to state 107
    number                         shift and go to state 33
    identifier                     shift and go to state 73
    helpertype                     shift and go to state 34
    unaryexp                       shift and go to state 74
    nularexp                       shift and go to state 75
    string                         shift and go to state 35
    binaryexp                      shift and go to state 76
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 79
    whiletype                      shift and go to state 80
    fortype                        shift and go to state 81
    withtype                       shift and go to state 82
    arraydefinition                shift and go to state 23

state 54

    (46) binaryexp -> primaryexp BINARY_FNC . primaryexp
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (40) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    PRIVATE_ID      shift and go to state 77
    GLOBAL_ID       shift and go to state 78
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 41
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    WITH            shift and go to state 48
    PRIVATE         shift and go to state 83

    primaryexp                     shift and go to state 109
    number                         shift and go to state 33
    identifier                     shift and go to state 73
    helpertype                     shift and go to state 34
    unaryexp                       shift and go to state 74
    nularexp                       shift and go to state 75
    string                         shift and go to state 35
    binaryexp                      shift and go to state 76
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 79
    whiletype                      shift and go to state 80
    fortype                        shift and go to state 81
    withtype                       shift and go to state 82
    arraydefinition                shift and go to state 23

state 55

    (47) binaryexp -> primaryexp comparisonoperator . primaryexp
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (40) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    PRIVATE_ID      shift and go to state 77
    GLOBAL_ID       shift and go to state 78
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 41
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    WITH            shift and go to state 48
    PRIVATE         shift and go to state 83

    primaryexp                     shift and go to state 110
    number                         shift and go to state 33
    identifier                     shift and go to state 73
    helpertype                     shift and go to state 34
    unaryexp                       shift and go to state 74
    nularexp                       shift and go to state 75
    string                         shift and go to state 35
    binaryexp                      shift and go to state 76
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 79
    whiletype                      shift and go to state 80
    fortype                        shift and go to state 81
    withtype                       shift and go to state 82
    arraydefinition                shift and go to state 23

state 56

    (48) binaryexp -> primaryexp mathoperator . primaryexp
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (40) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    PRIVATE_ID      shift and go to state 77
    GLOBAL_ID       shift and go to state 78
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 41
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    WITH            shift and go to state 48
    PRIVATE         shift and go to state 83

    primaryexp                     shift and go to state 111
    number                         shift and go to state 33
    identifier                     shift and go to state 73
    helpertype                     shift and go to state 34
    unaryexp                       shift and go to state 74
    nularexp                       shift and go to state 75
    string                         shift and go to state 35
    binaryexp                      shift and go to state 76
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 79
    whiletype                      shift and go to state 80
    fortype                        shift and go to state 81
    withtype                       shift and go to state 82
    arraydefinition                shift and go to state 23

state 57

    (76) comparisonoperator -> LT .

    LPAREN          reduce using rule 76 (comparisonoperator -> LT .)
    NUMBER_REAL     reduce using rule 76 (comparisonoperator -> LT .)
    NUMBER_EXP      reduce using rule 76 (comparisonoperator -> LT .)
    NUMBER_HEX      reduce using rule 76 (comparisonoperator -> LT .)
    PRIVATE_ID      reduce using rule 76 (comparisonoperator -> LT .)
    GLOBAL_ID       reduce using rule 76 (comparisonoperator -> LT .)
    UNARY_FNC       reduce using rule 76 (comparisonoperator -> LT .)
    PLUS            reduce using rule 76 (comparisonoperator -> LT .)
    MINUS           reduce using rule 76 (comparisonoperator -> LT .)
    NOT             reduce using rule 76 (comparisonoperator -> LT .)
    NULAR_FNC       reduce using rule 76 (comparisonoperator -> LT .)
    STRING_SINGLE   reduce using rule 76 (comparisonoperator -> LT .)
    STRING_DOUBLE   reduce using rule 76 (comparisonoperator -> LT .)
    LBRACE          reduce using rule 76 (comparisonoperator -> LT .)
    LSPAREN         reduce using rule 76 (comparisonoperator -> LT .)
    IF              reduce using rule 76 (comparisonoperator -> LT .)
    WHILE           reduce using rule 76 (comparisonoperator -> LT .)
    FOR             reduce using rule 76 (comparisonoperator -> LT .)
    WITH            reduce using rule 76 (comparisonoperator -> LT .)
    PRIVATE         reduce using rule 76 (comparisonoperator -> LT .)


state 58

    (77) comparisonoperator -> GT .

    LPAREN          reduce using rule 77 (comparisonoperator -> GT .)
    NUMBER_REAL     reduce using rule 77 (comparisonoperator -> GT .)
    NUMBER_EXP      reduce using rule 77 (comparisonoperator -> GT .)
    NUMBER_HEX      reduce using rule 77 (comparisonoperator -> GT .)
    PRIVATE_ID      reduce using rule 77 (comparisonoperator -> GT .)
    GLOBAL_ID       reduce using rule 77 (comparisonoperator -> GT .)
    UNARY_FNC       reduce using rule 77 (comparisonoperator -> GT .)
    PLUS            reduce using rule 77 (comparisonoperator -> GT .)
    MINUS           reduce using rule 77 (comparisonoperator -> GT .)
    NOT             reduce using rule 77 (comparisonoperator -> GT .)
    NULAR_FNC       reduce using rule 77 (comparisonoperator -> GT .)
    STRING_SINGLE   reduce using rule 77 (comparisonoperator -> GT .)
    STRING_DOUBLE   reduce using rule 77 (comparisonoperator -> GT .)
    LBRACE          reduce using rule 77 (comparisonoperator -> GT .)
    LSPAREN         reduce using rule 77 (comparisonoperator -> GT .)
    IF              reduce using rule 77 (comparisonoperator -> GT .)
    WHILE           reduce using rule 77 (comparisonoperator -> GT .)
    FOR             reduce using rule 77 (comparisonoperator -> GT .)
    WITH            reduce using rule 77 (comparisonoperator -> GT .)
    PRIVATE         reduce using rule 77 (comparisonoperator -> GT .)


state 59

    (78) comparisonoperator -> LTE .

    LPAREN          reduce using rule 78 (comparisonoperator -> LTE .)
    NUMBER_REAL     reduce using rule 78 (comparisonoperator -> LTE .)
    NUMBER_EXP      reduce using rule 78 (comparisonoperator -> LTE .)
    NUMBER_HEX      reduce using rule 78 (comparisonoperator -> LTE .)
    PRIVATE_ID      reduce using rule 78 (comparisonoperator -> LTE .)
    GLOBAL_ID       reduce using rule 78 (comparisonoperator -> LTE .)
    UNARY_FNC       reduce using rule 78 (comparisonoperator -> LTE .)
    PLUS            reduce using rule 78 (comparisonoperator -> LTE .)
    MINUS           reduce using rule 78 (comparisonoperator -> LTE .)
    NOT             reduce using rule 78 (comparisonoperator -> LTE .)
    NULAR_FNC       reduce using rule 78 (comparisonoperator -> LTE .)
    STRING_SINGLE   reduce using rule 78 (comparisonoperator -> LTE .)
    STRING_DOUBLE   reduce using rule 78 (comparisonoperator -> LTE .)
    LBRACE          reduce using rule 78 (comparisonoperator -> LTE .)
    LSPAREN         reduce using rule 78 (comparisonoperator -> LTE .)
    IF              reduce using rule 78 (comparisonoperator -> LTE .)
    WHILE           reduce using rule 78 (comparisonoperator -> LTE .)
    FOR             reduce using rule 78 (comparisonoperator -> LTE .)
    WITH            reduce using rule 78 (comparisonoperator -> LTE .)
    PRIVATE         reduce using rule 78 (comparisonoperator -> LTE .)


state 60

    (79) comparisonoperator -> GTE .

    LPAREN          reduce using rule 79 (comparisonoperator -> GTE .)
    NUMBER_REAL     reduce using rule 79 (comparisonoperator -> GTE .)
    NUMBER_EXP      reduce using rule 79 (comparisonoperator -> GTE .)
    NUMBER_HEX      reduce using rule 79 (comparisonoperator -> GTE .)
    PRIVATE_ID      reduce using rule 79 (comparisonoperator -> GTE .)
    GLOBAL_ID       reduce using rule 79 (comparisonoperator -> GTE .)
    UNARY_FNC       reduce using rule 79 (comparisonoperator -> GTE .)
    PLUS            reduce using rule 79 (comparisonoperator -> GTE .)
    MINUS           reduce using rule 79 (comparisonoperator -> GTE .)
    NOT             reduce using rule 79 (comparisonoperator -> GTE .)
    NULAR_FNC       reduce using rule 79 (comparisonoperator -> GTE .)
    STRING_SINGLE   reduce using rule 79 (comparisonoperator -> GTE .)
    STRING_DOUBLE   reduce using rule 79 (comparisonoperator -> GTE .)
    LBRACE          reduce using rule 79 (comparisonoperator -> GTE .)
    LSPAREN         reduce using rule 79 (comparisonoperator -> GTE .)
    IF              reduce using rule 79 (comparisonoperator -> GTE .)
    WHILE           reduce using rule 79 (comparisonoperator -> GTE .)
    FOR             reduce using rule 79 (comparisonoperator -> GTE .)
    WITH            reduce using rule 79 (comparisonoperator -> GTE .)
    PRIVATE         reduce using rule 79 (comparisonoperator -> GTE .)


state 61

    (80) comparisonoperator -> EQUALITY .

    LPAREN          reduce using rule 80 (comparisonoperator -> EQUALITY .)
    NUMBER_REAL     reduce using rule 80 (comparisonoperator -> EQUALITY .)
    NUMBER_EXP      reduce using rule 80 (comparisonoperator -> EQUALITY .)
    NUMBER_HEX      reduce using rule 80 (comparisonoperator -> EQUALITY .)
    PRIVATE_ID      reduce using rule 80 (comparisonoperator -> EQUALITY .)
    GLOBAL_ID       reduce using rule 80 (comparisonoperator -> EQUALITY .)
    UNARY_FNC       reduce using rule 80 (comparisonoperator -> EQUALITY .)
    PLUS            reduce using rule 80 (comparisonoperator -> EQUALITY .)
    MINUS           reduce using rule 80 (comparisonoperator -> EQUALITY .)
    NOT             reduce using rule 80 (comparisonoperator -> EQUALITY .)
    NULAR_FNC       reduce using rule 80 (comparisonoperator -> EQUALITY .)
    STRING_SINGLE   reduce using rule 80 (comparisonoperator -> EQUALITY .)
    STRING_DOUBLE   reduce using rule 80 (comparisonoperator -> EQUALITY .)
    LBRACE          reduce using rule 80 (comparisonoperator -> EQUALITY .)
    LSPAREN         reduce using rule 80 (comparisonoperator -> EQUALITY .)
    IF              reduce using rule 80 (comparisonoperator -> EQUALITY .)
    WHILE           reduce using rule 80 (comparisonoperator -> EQUALITY .)
    FOR             reduce using rule 80 (comparisonoperator -> EQUALITY .)
    WITH            reduce using rule 80 (comparisonoperator -> EQUALITY .)
    PRIVATE         reduce using rule 80 (comparisonoperator -> EQUALITY .)


state 62

    (81) comparisonoperator -> INEQUALITY .

    LPAREN          reduce using rule 81 (comparisonoperator -> INEQUALITY .)
    NUMBER_REAL     reduce using rule 81 (comparisonoperator -> INEQUALITY .)
    NUMBER_EXP      reduce using rule 81 (comparisonoperator -> INEQUALITY .)
    NUMBER_HEX      reduce using rule 81 (comparisonoperator -> INEQUALITY .)
    PRIVATE_ID      reduce using rule 81 (comparisonoperator -> INEQUALITY .)
    GLOBAL_ID       reduce using rule 81 (comparisonoperator -> INEQUALITY .)
    UNARY_FNC       reduce using rule 81 (comparisonoperator -> INEQUALITY .)
    PLUS            reduce using rule 81 (comparisonoperator -> INEQUALITY .)
    MINUS           reduce using rule 81 (comparisonoperator -> INEQUALITY .)
    NOT             reduce using rule 81 (comparisonoperator -> INEQUALITY .)
    NULAR_FNC       reduce using rule 81 (comparisonoperator -> INEQUALITY .)
    STRING_SINGLE   reduce using rule 81 (comparisonoperator -> INEQUALITY .)
    STRING_DOUBLE   reduce using rule 81 (comparisonoperator -> INEQUALITY .)
    LBRACE          reduce using rule 81 (comparisonoperator -> INEQUALITY .)
    LSPAREN         reduce using rule 81 (comparisonoperator -> INEQUALITY .)
    IF              reduce using rule 81 (comparisonoperator -> INEQUALITY .)
    WHILE           reduce using rule 81 (comparisonoperator -> INEQUALITY .)
    FOR             reduce using rule 81 (comparisonoperator -> INEQUALITY .)
    WITH            reduce using rule 81 (comparisonoperator -> INEQUALITY .)
    PRIVATE         reduce using rule 81 (comparisonoperator -> INEQUALITY .)


state 63

    (82) comparisonoperator -> AND .

    LPAREN          reduce using rule 82 (comparisonoperator -> AND .)
    NUMBER_REAL     reduce using rule 82 (comparisonoperator -> AND .)
    NUMBER_EXP      reduce using rule 82 (comparisonoperator -> AND .)
    NUMBER_HEX      reduce using rule 82 (comparisonoperator -> AND .)
    PRIVATE_ID      reduce using rule 82 (comparisonoperator -> AND .)
    GLOBAL_ID       reduce using rule 82 (comparisonoperator -> AND .)
    UNARY_FNC       reduce using rule 82 (comparisonoperator -> AND .)
    PLUS            reduce using rule 82 (comparisonoperator -> AND .)
    MINUS           reduce using rule 82 (comparisonoperator -> AND .)
    NOT             reduce using rule 82 (comparisonoperator -> AND .)
    NULAR_FNC       reduce using rule 82 (comparisonoperator -> AND .)
    STRING_SINGLE   reduce using rule 82 (comparisonoperator -> AND .)
    STRING_DOUBLE   reduce using rule 82 (comparisonoperator -> AND .)
    LBRACE          reduce using rule 82 (comparisonoperator -> AND .)
    LSPAREN         reduce using rule 82 (comparisonoperator -> AND .)
    IF              reduce using rule 82 (comparisonoperator -> AND .)
    WHILE           reduce using rule 82 (comparisonoperator -> AND .)
    FOR             reduce using rule 82 (comparisonoperator -> AND .)
    WITH            reduce using rule 82 (comparisonoperator -> AND .)
    PRIVATE         reduce using rule 82 (comparisonoperator -> AND .)


state 64

    (83) comparisonoperator -> OR .

    LPAREN          reduce using rule 83 (comparisonoperator -> OR .)
    NUMBER_REAL     reduce using rule 83 (comparisonoperator -> OR .)
    NUMBER_EXP      reduce using rule 83 (comparisonoperator -> OR .)
    NUMBER_HEX      reduce using rule 83 (comparisonoperator -> OR .)
    PRIVATE_ID      reduce using rule 83 (comparisonoperator -> OR .)
    GLOBAL_ID       reduce using rule 83 (comparisonoperator -> OR .)
    UNARY_FNC       reduce using rule 83 (comparisonoperator -> OR .)
    PLUS            reduce using rule 83 (comparisonoperator -> OR .)
    MINUS           reduce using rule 83 (comparisonoperator -> OR .)
    NOT             reduce using rule 83 (comparisonoperator -> OR .)
    NULAR_FNC       reduce using rule 83 (comparisonoperator -> OR .)
    STRING_SINGLE   reduce using rule 83 (comparisonoperator -> OR .)
    STRING_DOUBLE   reduce using rule 83 (comparisonoperator -> OR .)
    LBRACE          reduce using rule 83 (comparisonoperator -> OR .)
    LSPAREN         reduce using rule 83 (comparisonoperator -> OR .)
    IF              reduce using rule 83 (comparisonoperator -> OR .)
    WHILE           reduce using rule 83 (comparisonoperator -> OR .)
    FOR             reduce using rule 83 (comparisonoperator -> OR .)
    WITH            reduce using rule 83 (comparisonoperator -> OR .)
    PRIVATE         reduce using rule 83 (comparisonoperator -> OR .)


state 65

    (84) mathoperator -> PLUS .

    LPAREN          reduce using rule 84 (mathoperator -> PLUS .)
    NUMBER_REAL     reduce using rule 84 (mathoperator -> PLUS .)
    NUMBER_EXP      reduce using rule 84 (mathoperator -> PLUS .)
    NUMBER_HEX      reduce using rule 84 (mathoperator -> PLUS .)
    PRIVATE_ID      reduce using rule 84 (mathoperator -> PLUS .)
    GLOBAL_ID       reduce using rule 84 (mathoperator -> PLUS .)
    UNARY_FNC       reduce using rule 84 (mathoperator -> PLUS .)
    PLUS            reduce using rule 84 (mathoperator -> PLUS .)
    MINUS           reduce using rule 84 (mathoperator -> PLUS .)
    NOT             reduce using rule 84 (mathoperator -> PLUS .)
    NULAR_FNC       reduce using rule 84 (mathoperator -> PLUS .)
    STRING_SINGLE   reduce using rule 84 (mathoperator -> PLUS .)
    STRING_DOUBLE   reduce using rule 84 (mathoperator -> PLUS .)
    LBRACE          reduce using rule 84 (mathoperator -> PLUS .)
    LSPAREN         reduce using rule 84 (mathoperator -> PLUS .)
    IF              reduce using rule 84 (mathoperator -> PLUS .)
    WHILE           reduce using rule 84 (mathoperator -> PLUS .)
    FOR             reduce using rule 84 (mathoperator -> PLUS .)
    WITH            reduce using rule 84 (mathoperator -> PLUS .)
    PRIVATE         reduce using rule 84 (mathoperator -> PLUS .)


state 66

    (85) mathoperator -> MINUS .

    LPAREN          reduce using rule 85 (mathoperator -> MINUS .)
    NUMBER_REAL     reduce using rule 85 (mathoperator -> MINUS .)
    NUMBER_EXP      reduce using rule 85 (mathoperator -> MINUS .)
    NUMBER_HEX      reduce using rule 85 (mathoperator -> MINUS .)
    PRIVATE_ID      reduce using rule 85 (mathoperator -> MINUS .)
    GLOBAL_ID       reduce using rule 85 (mathoperator -> MINUS .)
    UNARY_FNC       reduce using rule 85 (mathoperator -> MINUS .)
    PLUS            reduce using rule 85 (mathoperator -> MINUS .)
    MINUS           reduce using rule 85 (mathoperator -> MINUS .)
    NOT             reduce using rule 85 (mathoperator -> MINUS .)
    NULAR_FNC       reduce using rule 85 (mathoperator -> MINUS .)
    STRING_SINGLE   reduce using rule 85 (mathoperator -> MINUS .)
    STRING_DOUBLE   reduce using rule 85 (mathoperator -> MINUS .)
    LBRACE          reduce using rule 85 (mathoperator -> MINUS .)
    LSPAREN         reduce using rule 85 (mathoperator -> MINUS .)
    IF              reduce using rule 85 (mathoperator -> MINUS .)
    WHILE           reduce using rule 85 (mathoperator -> MINUS .)
    FOR             reduce using rule 85 (mathoperator -> MINUS .)
    WITH            reduce using rule 85 (mathoperator -> MINUS .)
    PRIVATE         reduce using rule 85 (mathoperator -> MINUS .)


state 67

    (86) mathoperator -> TIMES .

    LPAREN          reduce using rule 86 (mathoperator -> TIMES .)
    NUMBER_REAL     reduce using rule 86 (mathoperator -> TIMES .)
    NUMBER_EXP      reduce using rule 86 (mathoperator -> TIMES .)
    NUMBER_HEX      reduce using rule 86 (mathoperator -> TIMES .)
    PRIVATE_ID      reduce using rule 86 (mathoperator -> TIMES .)
    GLOBAL_ID       reduce using rule 86 (mathoperator -> TIMES .)
    UNARY_FNC       reduce using rule 86 (mathoperator -> TIMES .)
    PLUS            reduce using rule 86 (mathoperator -> TIMES .)
    MINUS           reduce using rule 86 (mathoperator -> TIMES .)
    NOT             reduce using rule 86 (mathoperator -> TIMES .)
    NULAR_FNC       reduce using rule 86 (mathoperator -> TIMES .)
    STRING_SINGLE   reduce using rule 86 (mathoperator -> TIMES .)
    STRING_DOUBLE   reduce using rule 86 (mathoperator -> TIMES .)
    LBRACE          reduce using rule 86 (mathoperator -> TIMES .)
    LSPAREN         reduce using rule 86 (mathoperator -> TIMES .)
    IF              reduce using rule 86 (mathoperator -> TIMES .)
    WHILE           reduce using rule 86 (mathoperator -> TIMES .)
    FOR             reduce using rule 86 (mathoperator -> TIMES .)
    WITH            reduce using rule 86 (mathoperator -> TIMES .)
    PRIVATE         reduce using rule 86 (mathoperator -> TIMES .)


state 68

    (87) mathoperator -> DIVIDE .

    LPAREN          reduce using rule 87 (mathoperator -> DIVIDE .)
    NUMBER_REAL     reduce using rule 87 (mathoperator -> DIVIDE .)
    NUMBER_EXP      reduce using rule 87 (mathoperator -> DIVIDE .)
    NUMBER_HEX      reduce using rule 87 (mathoperator -> DIVIDE .)
    PRIVATE_ID      reduce using rule 87 (mathoperator -> DIVIDE .)
    GLOBAL_ID       reduce using rule 87 (mathoperator -> DIVIDE .)
    UNARY_FNC       reduce using rule 87 (mathoperator -> DIVIDE .)
    PLUS            reduce using rule 87 (mathoperator -> DIVIDE .)
    MINUS           reduce using rule 87 (mathoperator -> DIVIDE .)
    NOT             reduce using rule 87 (mathoperator -> DIVIDE .)
    NULAR_FNC       reduce using rule 87 (mathoperator -> DIVIDE .)
    STRING_SINGLE   reduce using rule 87 (mathoperator -> DIVIDE .)
    STRING_DOUBLE   reduce using rule 87 (mathoperator -> DIVIDE .)
    LBRACE          reduce using rule 87 (mathoperator -> DIVIDE .)
    LSPAREN         reduce using rule 87 (mathoperator -> DIVIDE .)
    IF              reduce using rule 87 (mathoperator -> DIVIDE .)
    WHILE           reduce using rule 87 (mathoperator -> DIVIDE .)
    FOR             reduce using rule 87 (mathoperator -> DIVIDE .)
    WITH            reduce using rule 87 (mathoperator -> DIVIDE .)
    PRIVATE         reduce using rule 87 (mathoperator -> DIVIDE .)


state 69

    (88) mathoperator -> MOD .

    LPAREN          reduce using rule 88 (mathoperator -> MOD .)
    NUMBER_REAL     reduce using rule 88 (mathoperator -> MOD .)
    NUMBER_EXP      reduce using rule 88 (mathoperator -> MOD .)
    NUMBER_HEX      reduce using rule 88 (mathoperator -> MOD .)
    PRIVATE_ID      reduce using rule 88 (mathoperator -> MOD .)
    GLOBAL_ID       reduce using rule 88 (mathoperator -> MOD .)
    UNARY_FNC       reduce using rule 88 (mathoperator -> MOD .)
    PLUS            reduce using rule 88 (mathoperator -> MOD .)
    MINUS           reduce using rule 88 (mathoperator -> MOD .)
    NOT             reduce using rule 88 (mathoperator -> MOD .)
    NULAR_FNC       reduce using rule 88 (mathoperator -> MOD .)
    STRING_SINGLE   reduce using rule 88 (mathoperator -> MOD .)
    STRING_DOUBLE   reduce using rule 88 (mathoperator -> MOD .)
    LBRACE          reduce using rule 88 (mathoperator -> MOD .)
    LSPAREN         reduce using rule 88 (mathoperator -> MOD .)
    IF              reduce using rule 88 (mathoperator -> MOD .)
    WHILE           reduce using rule 88 (mathoperator -> MOD .)
    FOR             reduce using rule 88 (mathoperator -> MOD .)
    WITH            reduce using rule 88 (mathoperator -> MOD .)
    PRIVATE         reduce using rule 88 (mathoperator -> MOD .)


state 70

    (89) mathoperator -> POW .

    LPAREN          reduce using rule 89 (mathoperator -> POW .)
    NUMBER_REAL     reduce using rule 89 (mathoperator -> POW .)
    NUMBER_EXP      reduce using rule 89 (mathoperator -> POW .)
    NUMBER_HEX      reduce using rule 89 (mathoperator -> POW .)
    PRIVATE_ID      reduce using rule 89 (mathoperator -> POW .)
    GLOBAL_ID       reduce using rule 89 (mathoperator -> POW .)
    UNARY_FNC       reduce using rule 89 (mathoperator -> POW .)
    PLUS            reduce using rule 89 (mathoperator -> POW .)
    MINUS           reduce using rule 89 (mathoperator -> POW .)
    NOT             reduce using rule 89 (mathoperator -> POW .)
    NULAR_FNC       reduce using rule 89 (mathoperator -> POW .)
    STRING_SINGLE   reduce using rule 89 (mathoperator -> POW .)
    STRING_DOUBLE   reduce using rule 89 (mathoperator -> POW .)
    LBRACE          reduce using rule 89 (mathoperator -> POW .)
    LSPAREN         reduce using rule 89 (mathoperator -> POW .)
    IF              reduce using rule 89 (mathoperator -> POW .)
    WHILE           reduce using rule 89 (mathoperator -> POW .)
    FOR             reduce using rule 89 (mathoperator -> POW .)
    WITH            reduce using rule 89 (mathoperator -> POW .)
    PRIVATE         reduce using rule 89 (mathoperator -> POW .)


state 71

    (37) assignment -> variable EQUAL . primaryexp
    (39) assignment_code -> variable EQUAL . LBRACE
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (40) arraydefinition -> . PRIVATE stringarray

    LBRACE          shift and go to state 113
    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    PRIVATE_ID      shift and go to state 77
    GLOBAL_ID       shift and go to state 78
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LSPAREN         shift and go to state 41
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    WITH            shift and go to state 48
    PRIVATE         shift and go to state 83

    primaryexp                     shift and go to state 112
    number                         shift and go to state 33
    identifier                     shift and go to state 73
    helpertype                     shift and go to state 34
    unaryexp                       shift and go to state 74
    nularexp                       shift and go to state 75
    string                         shift and go to state 35
    binaryexp                      shift and go to state 76
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 79
    whiletype                      shift and go to state 80
    fortype                        shift and go to state 81
    withtype                       shift and go to state 82
    arraydefinition                shift and go to state 23

state 72

    (71) unaryexp -> UNARY_FNC primaryexp .
    (46) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (47) binaryexp -> primaryexp . comparisonoperator primaryexp
    (48) binaryexp -> primaryexp . mathoperator primaryexp
    (76) comparisonoperator -> . LT
    (77) comparisonoperator -> . GT
    (78) comparisonoperator -> . LTE
    (79) comparisonoperator -> . GTE
    (80) comparisonoperator -> . EQUALITY
    (81) comparisonoperator -> . INEQUALITY
    (82) comparisonoperator -> . AND
    (83) comparisonoperator -> . OR
    (84) mathoperator -> . PLUS
    (85) mathoperator -> . MINUS
    (86) mathoperator -> . TIMES
    (87) mathoperator -> . DIVIDE
    (88) mathoperator -> . MOD
    (89) mathoperator -> . POW

    SEMI_COLON      reduce using rule 71 (unaryexp -> UNARY_FNC primaryexp .)
    COMMA           reduce using rule 71 (unaryexp -> UNARY_FNC primaryexp .)
    $end            reduce using rule 71 (unaryexp -> UNARY_FNC primaryexp .)
    BINARY_FNC      reduce using rule 71 (unaryexp -> UNARY_FNC primaryexp .)
    LT              reduce using rule 71 (unaryexp -> UNARY_FNC primaryexp .)
    GT              reduce using rule 71 (unaryexp -> UNARY_FNC primaryexp .)
    LTE             reduce using rule 71 (unaryexp -> UNARY_FNC primaryexp .)
    GTE             reduce using rule 71 (unaryexp -> UNARY_FNC primaryexp .)
    EQUALITY        reduce using rule 71 (unaryexp -> UNARY_FNC primaryexp .)
    INEQUALITY      reduce using rule 71 (unaryexp -> UNARY_FNC primaryexp .)
    AND             reduce using rule 71 (unaryexp -> UNARY_FNC primaryexp .)
    OR              reduce using rule 71 (unaryexp -> UNARY_FNC primaryexp .)
    PLUS            reduce using rule 71 (unaryexp -> UNARY_FNC primaryexp .)
    MINUS           reduce using rule 71 (unaryexp -> UNARY_FNC primaryexp .)
    TIMES           reduce using rule 71 (unaryexp -> UNARY_FNC primaryexp .)
    DIVIDE          reduce using rule 71 (unaryexp -> UNARY_FNC primaryexp .)
    MOD             reduce using rule 71 (unaryexp -> UNARY_FNC primaryexp .)
    POW             reduce using rule 71 (unaryexp -> UNARY_FNC primaryexp .)
    RBRACE          reduce using rule 71 (unaryexp -> UNARY_FNC primaryexp .)
    RPAREN          reduce using rule 71 (unaryexp -> UNARY_FNC primaryexp .)
    RSPAREN         reduce using rule 71 (unaryexp -> UNARY_FNC primaryexp .)
    TO              reduce using rule 71 (unaryexp -> UNARY_FNC primaryexp .)
    STEP            reduce using rule 71 (unaryexp -> UNARY_FNC primaryexp .)
    DO              reduce using rule 71 (unaryexp -> UNARY_FNC primaryexp .)

  ! BINARY_FNC      [ shift and go to state 54 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! LTE             [ shift and go to state 59 ]
  ! GTE             [ shift and go to state 60 ]
  ! EQUALITY        [ shift and go to state 61 ]
  ! INEQUALITY      [ shift and go to state 62 ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 64 ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 66 ]
  ! TIMES           [ shift and go to state 67 ]
  ! DIVIDE          [ shift and go to state 68 ]
  ! MOD             [ shift and go to state 69 ]
  ! POW             [ shift and go to state 70 ]

    comparisonoperator             shift and go to state 55
    mathoperator                   shift and go to state 56

state 73

    (50) primaryexp -> identifier .
    (70) nularexp -> identifier .

  ! reduce/reduce conflict for BINARY_FNC resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for LT resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for GT resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for LTE resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for GTE resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for EQUALITY resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for INEQUALITY resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for AND resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for OR resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for PLUS resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for MINUS resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for TIMES resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for MOD resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for POW resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for SEMI_COLON resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for COMMA resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for $end resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for RBRACE resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for RPAREN resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for RSPAREN resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for TO resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for STEP resolved using rule 50 (primaryexp -> identifier .)
  ! reduce/reduce conflict for DO resolved using rule 50 (primaryexp -> identifier .)
    BINARY_FNC      reduce using rule 50 (primaryexp -> identifier .)
    LT              reduce using rule 50 (primaryexp -> identifier .)
    GT              reduce using rule 50 (primaryexp -> identifier .)
    LTE             reduce using rule 50 (primaryexp -> identifier .)
    GTE             reduce using rule 50 (primaryexp -> identifier .)
    EQUALITY        reduce using rule 50 (primaryexp -> identifier .)
    INEQUALITY      reduce using rule 50 (primaryexp -> identifier .)
    AND             reduce using rule 50 (primaryexp -> identifier .)
    OR              reduce using rule 50 (primaryexp -> identifier .)
    PLUS            reduce using rule 50 (primaryexp -> identifier .)
    MINUS           reduce using rule 50 (primaryexp -> identifier .)
    TIMES           reduce using rule 50 (primaryexp -> identifier .)
    DIVIDE          reduce using rule 50 (primaryexp -> identifier .)
    MOD             reduce using rule 50 (primaryexp -> identifier .)
    POW             reduce using rule 50 (primaryexp -> identifier .)
    SEMI_COLON      reduce using rule 50 (primaryexp -> identifier .)
    COMMA           reduce using rule 50 (primaryexp -> identifier .)
    $end            reduce using rule 50 (primaryexp -> identifier .)
    RBRACE          reduce using rule 50 (primaryexp -> identifier .)
    RPAREN          reduce using rule 50 (primaryexp -> identifier .)
    RSPAREN         reduce using rule 50 (primaryexp -> identifier .)
    TO              reduce using rule 50 (primaryexp -> identifier .)
    STEP            reduce using rule 50 (primaryexp -> identifier .)
    DO              reduce using rule 50 (primaryexp -> identifier .)

  ! BINARY_FNC      [ reduce using rule 70 (nularexp -> identifier .) ]
  ! LT              [ reduce using rule 70 (nularexp -> identifier .) ]
  ! GT              [ reduce using rule 70 (nularexp -> identifier .) ]
  ! LTE             [ reduce using rule 70 (nularexp -> identifier .) ]
  ! GTE             [ reduce using rule 70 (nularexp -> identifier .) ]
  ! EQUALITY        [ reduce using rule 70 (nularexp -> identifier .) ]
  ! INEQUALITY      [ reduce using rule 70 (nularexp -> identifier .) ]
  ! AND             [ reduce using rule 70 (nularexp -> identifier .) ]
  ! OR              [ reduce using rule 70 (nularexp -> identifier .) ]
  ! PLUS            [ reduce using rule 70 (nularexp -> identifier .) ]
  ! MINUS           [ reduce using rule 70 (nularexp -> identifier .) ]
  ! TIMES           [ reduce using rule 70 (nularexp -> identifier .) ]
  ! DIVIDE          [ reduce using rule 70 (nularexp -> identifier .) ]
  ! MOD             [ reduce using rule 70 (nularexp -> identifier .) ]
  ! POW             [ reduce using rule 70 (nularexp -> identifier .) ]
  ! SEMI_COLON      [ reduce using rule 70 (nularexp -> identifier .) ]
  ! COMMA           [ reduce using rule 70 (nularexp -> identifier .) ]
  ! $end            [ reduce using rule 70 (nularexp -> identifier .) ]
  ! RBRACE          [ reduce using rule 70 (nularexp -> identifier .) ]
  ! RPAREN          [ reduce using rule 70 (nularexp -> identifier .) ]
  ! RSPAREN         [ reduce using rule 70 (nularexp -> identifier .) ]
  ! TO              [ reduce using rule 70 (nularexp -> identifier .) ]
  ! STEP            [ reduce using rule 70 (nularexp -> identifier .) ]
  ! DO              [ reduce using rule 70 (nularexp -> identifier .) ]


state 74

    (52) primaryexp -> unaryexp .

    BINARY_FNC      reduce using rule 52 (primaryexp -> unaryexp .)
    LT              reduce using rule 52 (primaryexp -> unaryexp .)
    GT              reduce using rule 52 (primaryexp -> unaryexp .)
    LTE             reduce using rule 52 (primaryexp -> unaryexp .)
    GTE             reduce using rule 52 (primaryexp -> unaryexp .)
    EQUALITY        reduce using rule 52 (primaryexp -> unaryexp .)
    INEQUALITY      reduce using rule 52 (primaryexp -> unaryexp .)
    AND             reduce using rule 52 (primaryexp -> unaryexp .)
    OR              reduce using rule 52 (primaryexp -> unaryexp .)
    PLUS            reduce using rule 52 (primaryexp -> unaryexp .)
    MINUS           reduce using rule 52 (primaryexp -> unaryexp .)
    TIMES           reduce using rule 52 (primaryexp -> unaryexp .)
    DIVIDE          reduce using rule 52 (primaryexp -> unaryexp .)
    MOD             reduce using rule 52 (primaryexp -> unaryexp .)
    POW             reduce using rule 52 (primaryexp -> unaryexp .)
    SEMI_COLON      reduce using rule 52 (primaryexp -> unaryexp .)
    COMMA           reduce using rule 52 (primaryexp -> unaryexp .)
    $end            reduce using rule 52 (primaryexp -> unaryexp .)
    RBRACE          reduce using rule 52 (primaryexp -> unaryexp .)
    RPAREN          reduce using rule 52 (primaryexp -> unaryexp .)
    RSPAREN         reduce using rule 52 (primaryexp -> unaryexp .)
    TO              reduce using rule 52 (primaryexp -> unaryexp .)
    STEP            reduce using rule 52 (primaryexp -> unaryexp .)
    DO              reduce using rule 52 (primaryexp -> unaryexp .)


state 75

    (53) primaryexp -> nularexp .

    BINARY_FNC      reduce using rule 53 (primaryexp -> nularexp .)
    LT              reduce using rule 53 (primaryexp -> nularexp .)
    GT              reduce using rule 53 (primaryexp -> nularexp .)
    LTE             reduce using rule 53 (primaryexp -> nularexp .)
    GTE             reduce using rule 53 (primaryexp -> nularexp .)
    EQUALITY        reduce using rule 53 (primaryexp -> nularexp .)
    INEQUALITY      reduce using rule 53 (primaryexp -> nularexp .)
    AND             reduce using rule 53 (primaryexp -> nularexp .)
    OR              reduce using rule 53 (primaryexp -> nularexp .)
    PLUS            reduce using rule 53 (primaryexp -> nularexp .)
    MINUS           reduce using rule 53 (primaryexp -> nularexp .)
    TIMES           reduce using rule 53 (primaryexp -> nularexp .)
    DIVIDE          reduce using rule 53 (primaryexp -> nularexp .)
    MOD             reduce using rule 53 (primaryexp -> nularexp .)
    POW             reduce using rule 53 (primaryexp -> nularexp .)
    SEMI_COLON      reduce using rule 53 (primaryexp -> nularexp .)
    COMMA           reduce using rule 53 (primaryexp -> nularexp .)
    $end            reduce using rule 53 (primaryexp -> nularexp .)
    RBRACE          reduce using rule 53 (primaryexp -> nularexp .)
    RPAREN          reduce using rule 53 (primaryexp -> nularexp .)
    RSPAREN         reduce using rule 53 (primaryexp -> nularexp .)
    TO              reduce using rule 53 (primaryexp -> nularexp .)
    STEP            reduce using rule 53 (primaryexp -> nularexp .)
    DO              reduce using rule 53 (primaryexp -> nularexp .)


state 76

    (55) primaryexp -> binaryexp .

    BINARY_FNC      reduce using rule 55 (primaryexp -> binaryexp .)
    LT              reduce using rule 55 (primaryexp -> binaryexp .)
    GT              reduce using rule 55 (primaryexp -> binaryexp .)
    LTE             reduce using rule 55 (primaryexp -> binaryexp .)
    GTE             reduce using rule 55 (primaryexp -> binaryexp .)
    EQUALITY        reduce using rule 55 (primaryexp -> binaryexp .)
    INEQUALITY      reduce using rule 55 (primaryexp -> binaryexp .)
    AND             reduce using rule 55 (primaryexp -> binaryexp .)
    OR              reduce using rule 55 (primaryexp -> binaryexp .)
    PLUS            reduce using rule 55 (primaryexp -> binaryexp .)
    MINUS           reduce using rule 55 (primaryexp -> binaryexp .)
    TIMES           reduce using rule 55 (primaryexp -> binaryexp .)
    DIVIDE          reduce using rule 55 (primaryexp -> binaryexp .)
    MOD             reduce using rule 55 (primaryexp -> binaryexp .)
    POW             reduce using rule 55 (primaryexp -> binaryexp .)
    SEMI_COLON      reduce using rule 55 (primaryexp -> binaryexp .)
    COMMA           reduce using rule 55 (primaryexp -> binaryexp .)
    $end            reduce using rule 55 (primaryexp -> binaryexp .)
    RBRACE          reduce using rule 55 (primaryexp -> binaryexp .)
    RPAREN          reduce using rule 55 (primaryexp -> binaryexp .)
    RSPAREN         reduce using rule 55 (primaryexp -> binaryexp .)
    TO              reduce using rule 55 (primaryexp -> binaryexp .)
    STEP            reduce using rule 55 (primaryexp -> binaryexp .)
    DO              reduce using rule 55 (primaryexp -> binaryexp .)


state 77

    (42) identifier -> PRIVATE_ID .

    BINARY_FNC      reduce using rule 42 (identifier -> PRIVATE_ID .)
    LT              reduce using rule 42 (identifier -> PRIVATE_ID .)
    GT              reduce using rule 42 (identifier -> PRIVATE_ID .)
    LTE             reduce using rule 42 (identifier -> PRIVATE_ID .)
    GTE             reduce using rule 42 (identifier -> PRIVATE_ID .)
    EQUALITY        reduce using rule 42 (identifier -> PRIVATE_ID .)
    INEQUALITY      reduce using rule 42 (identifier -> PRIVATE_ID .)
    AND             reduce using rule 42 (identifier -> PRIVATE_ID .)
    OR              reduce using rule 42 (identifier -> PRIVATE_ID .)
    PLUS            reduce using rule 42 (identifier -> PRIVATE_ID .)
    MINUS           reduce using rule 42 (identifier -> PRIVATE_ID .)
    TIMES           reduce using rule 42 (identifier -> PRIVATE_ID .)
    DIVIDE          reduce using rule 42 (identifier -> PRIVATE_ID .)
    MOD             reduce using rule 42 (identifier -> PRIVATE_ID .)
    POW             reduce using rule 42 (identifier -> PRIVATE_ID .)
    SEMI_COLON      reduce using rule 42 (identifier -> PRIVATE_ID .)
    COMMA           reduce using rule 42 (identifier -> PRIVATE_ID .)
    $end            reduce using rule 42 (identifier -> PRIVATE_ID .)
    RBRACE          reduce using rule 42 (identifier -> PRIVATE_ID .)
    RPAREN          reduce using rule 42 (identifier -> PRIVATE_ID .)
    RSPAREN         reduce using rule 42 (identifier -> PRIVATE_ID .)
    TO              reduce using rule 42 (identifier -> PRIVATE_ID .)
    STEP            reduce using rule 42 (identifier -> PRIVATE_ID .)
    DO              reduce using rule 42 (identifier -> PRIVATE_ID .)


state 78

    (43) identifier -> GLOBAL_ID .

    BINARY_FNC      reduce using rule 43 (identifier -> GLOBAL_ID .)
    LT              reduce using rule 43 (identifier -> GLOBAL_ID .)
    GT              reduce using rule 43 (identifier -> GLOBAL_ID .)
    LTE             reduce using rule 43 (identifier -> GLOBAL_ID .)
    GTE             reduce using rule 43 (identifier -> GLOBAL_ID .)
    EQUALITY        reduce using rule 43 (identifier -> GLOBAL_ID .)
    INEQUALITY      reduce using rule 43 (identifier -> GLOBAL_ID .)
    AND             reduce using rule 43 (identifier -> GLOBAL_ID .)
    OR              reduce using rule 43 (identifier -> GLOBAL_ID .)
    PLUS            reduce using rule 43 (identifier -> GLOBAL_ID .)
    MINUS           reduce using rule 43 (identifier -> GLOBAL_ID .)
    TIMES           reduce using rule 43 (identifier -> GLOBAL_ID .)
    DIVIDE          reduce using rule 43 (identifier -> GLOBAL_ID .)
    MOD             reduce using rule 43 (identifier -> GLOBAL_ID .)
    POW             reduce using rule 43 (identifier -> GLOBAL_ID .)
    SEMI_COLON      reduce using rule 43 (identifier -> GLOBAL_ID .)
    COMMA           reduce using rule 43 (identifier -> GLOBAL_ID .)
    $end            reduce using rule 43 (identifier -> GLOBAL_ID .)
    RBRACE          reduce using rule 43 (identifier -> GLOBAL_ID .)
    RPAREN          reduce using rule 43 (identifier -> GLOBAL_ID .)
    RSPAREN         reduce using rule 43 (identifier -> GLOBAL_ID .)
    TO              reduce using rule 43 (identifier -> GLOBAL_ID .)
    STEP            reduce using rule 43 (identifier -> GLOBAL_ID .)
    DO              reduce using rule 43 (identifier -> GLOBAL_ID .)


state 79

    (15) helpertype -> iftype .

    BINARY_FNC      reduce using rule 15 (helpertype -> iftype .)
    LT              reduce using rule 15 (helpertype -> iftype .)
    GT              reduce using rule 15 (helpertype -> iftype .)
    LTE             reduce using rule 15 (helpertype -> iftype .)
    GTE             reduce using rule 15 (helpertype -> iftype .)
    EQUALITY        reduce using rule 15 (helpertype -> iftype .)
    INEQUALITY      reduce using rule 15 (helpertype -> iftype .)
    AND             reduce using rule 15 (helpertype -> iftype .)
    OR              reduce using rule 15 (helpertype -> iftype .)
    PLUS            reduce using rule 15 (helpertype -> iftype .)
    MINUS           reduce using rule 15 (helpertype -> iftype .)
    TIMES           reduce using rule 15 (helpertype -> iftype .)
    DIVIDE          reduce using rule 15 (helpertype -> iftype .)
    MOD             reduce using rule 15 (helpertype -> iftype .)
    POW             reduce using rule 15 (helpertype -> iftype .)
    SEMI_COLON      reduce using rule 15 (helpertype -> iftype .)
    COMMA           reduce using rule 15 (helpertype -> iftype .)
    $end            reduce using rule 15 (helpertype -> iftype .)
    RBRACE          reduce using rule 15 (helpertype -> iftype .)
    RPAREN          reduce using rule 15 (helpertype -> iftype .)
    RSPAREN         reduce using rule 15 (helpertype -> iftype .)
    TO              reduce using rule 15 (helpertype -> iftype .)
    STEP            reduce using rule 15 (helpertype -> iftype .)
    DO              reduce using rule 15 (helpertype -> iftype .)


state 80

    (16) helpertype -> whiletype .

    BINARY_FNC      reduce using rule 16 (helpertype -> whiletype .)
    LT              reduce using rule 16 (helpertype -> whiletype .)
    GT              reduce using rule 16 (helpertype -> whiletype .)
    LTE             reduce using rule 16 (helpertype -> whiletype .)
    GTE             reduce using rule 16 (helpertype -> whiletype .)
    EQUALITY        reduce using rule 16 (helpertype -> whiletype .)
    INEQUALITY      reduce using rule 16 (helpertype -> whiletype .)
    AND             reduce using rule 16 (helpertype -> whiletype .)
    OR              reduce using rule 16 (helpertype -> whiletype .)
    PLUS            reduce using rule 16 (helpertype -> whiletype .)
    MINUS           reduce using rule 16 (helpertype -> whiletype .)
    TIMES           reduce using rule 16 (helpertype -> whiletype .)
    DIVIDE          reduce using rule 16 (helpertype -> whiletype .)
    MOD             reduce using rule 16 (helpertype -> whiletype .)
    POW             reduce using rule 16 (helpertype -> whiletype .)
    SEMI_COLON      reduce using rule 16 (helpertype -> whiletype .)
    COMMA           reduce using rule 16 (helpertype -> whiletype .)
    $end            reduce using rule 16 (helpertype -> whiletype .)
    RBRACE          reduce using rule 16 (helpertype -> whiletype .)
    RPAREN          reduce using rule 16 (helpertype -> whiletype .)
    RSPAREN         reduce using rule 16 (helpertype -> whiletype .)
    TO              reduce using rule 16 (helpertype -> whiletype .)
    STEP            reduce using rule 16 (helpertype -> whiletype .)
    DO              reduce using rule 16 (helpertype -> whiletype .)


state 81

    (17) helpertype -> fortype .

    BINARY_FNC      reduce using rule 17 (helpertype -> fortype .)
    LT              reduce using rule 17 (helpertype -> fortype .)
    GT              reduce using rule 17 (helpertype -> fortype .)
    LTE             reduce using rule 17 (helpertype -> fortype .)
    GTE             reduce using rule 17 (helpertype -> fortype .)
    EQUALITY        reduce using rule 17 (helpertype -> fortype .)
    INEQUALITY      reduce using rule 17 (helpertype -> fortype .)
    AND             reduce using rule 17 (helpertype -> fortype .)
    OR              reduce using rule 17 (helpertype -> fortype .)
    PLUS            reduce using rule 17 (helpertype -> fortype .)
    MINUS           reduce using rule 17 (helpertype -> fortype .)
    TIMES           reduce using rule 17 (helpertype -> fortype .)
    DIVIDE          reduce using rule 17 (helpertype -> fortype .)
    MOD             reduce using rule 17 (helpertype -> fortype .)
    POW             reduce using rule 17 (helpertype -> fortype .)
    SEMI_COLON      reduce using rule 17 (helpertype -> fortype .)
    COMMA           reduce using rule 17 (helpertype -> fortype .)
    $end            reduce using rule 17 (helpertype -> fortype .)
    RBRACE          reduce using rule 17 (helpertype -> fortype .)
    RPAREN          reduce using rule 17 (helpertype -> fortype .)
    RSPAREN         reduce using rule 17 (helpertype -> fortype .)
    TO              reduce using rule 17 (helpertype -> fortype .)
    STEP            reduce using rule 17 (helpertype -> fortype .)
    DO              reduce using rule 17 (helpertype -> fortype .)


state 82

    (18) helpertype -> withtype .

    BINARY_FNC      reduce using rule 18 (helpertype -> withtype .)
    LT              reduce using rule 18 (helpertype -> withtype .)
    GT              reduce using rule 18 (helpertype -> withtype .)
    LTE             reduce using rule 18 (helpertype -> withtype .)
    GTE             reduce using rule 18 (helpertype -> withtype .)
    EQUALITY        reduce using rule 18 (helpertype -> withtype .)
    INEQUALITY      reduce using rule 18 (helpertype -> withtype .)
    AND             reduce using rule 18 (helpertype -> withtype .)
    OR              reduce using rule 18 (helpertype -> withtype .)
    PLUS            reduce using rule 18 (helpertype -> withtype .)
    MINUS           reduce using rule 18 (helpertype -> withtype .)
    TIMES           reduce using rule 18 (helpertype -> withtype .)
    DIVIDE          reduce using rule 18 (helpertype -> withtype .)
    MOD             reduce using rule 18 (helpertype -> withtype .)
    POW             reduce using rule 18 (helpertype -> withtype .)
    SEMI_COLON      reduce using rule 18 (helpertype -> withtype .)
    COMMA           reduce using rule 18 (helpertype -> withtype .)
    $end            reduce using rule 18 (helpertype -> withtype .)
    RBRACE          reduce using rule 18 (helpertype -> withtype .)
    RPAREN          reduce using rule 18 (helpertype -> withtype .)
    RSPAREN         reduce using rule 18 (helpertype -> withtype .)
    TO              reduce using rule 18 (helpertype -> withtype .)
    STEP            reduce using rule 18 (helpertype -> withtype .)
    DO              reduce using rule 18 (helpertype -> withtype .)


state 83

    (40) arraydefinition -> PRIVATE . stringarray
    (65) stringarray -> . LSPAREN RSPAREN
    (66) stringarray -> . LSPAREN stringarrayelement RSPAREN

    LSPAREN         shift and go to state 95

    stringarray                    shift and go to state 94

state 84

    (72) unaryexp -> PLUS primaryexp .
    (46) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (47) binaryexp -> primaryexp . comparisonoperator primaryexp
    (48) binaryexp -> primaryexp . mathoperator primaryexp
    (76) comparisonoperator -> . LT
    (77) comparisonoperator -> . GT
    (78) comparisonoperator -> . LTE
    (79) comparisonoperator -> . GTE
    (80) comparisonoperator -> . EQUALITY
    (81) comparisonoperator -> . INEQUALITY
    (82) comparisonoperator -> . AND
    (83) comparisonoperator -> . OR
    (84) mathoperator -> . PLUS
    (85) mathoperator -> . MINUS
    (86) mathoperator -> . TIMES
    (87) mathoperator -> . DIVIDE
    (88) mathoperator -> . MOD
    (89) mathoperator -> . POW

    SEMI_COLON      reduce using rule 72 (unaryexp -> PLUS primaryexp .)
    COMMA           reduce using rule 72 (unaryexp -> PLUS primaryexp .)
    $end            reduce using rule 72 (unaryexp -> PLUS primaryexp .)
    BINARY_FNC      reduce using rule 72 (unaryexp -> PLUS primaryexp .)
    LT              reduce using rule 72 (unaryexp -> PLUS primaryexp .)
    GT              reduce using rule 72 (unaryexp -> PLUS primaryexp .)
    LTE             reduce using rule 72 (unaryexp -> PLUS primaryexp .)
    GTE             reduce using rule 72 (unaryexp -> PLUS primaryexp .)
    EQUALITY        reduce using rule 72 (unaryexp -> PLUS primaryexp .)
    INEQUALITY      reduce using rule 72 (unaryexp -> PLUS primaryexp .)
    AND             reduce using rule 72 (unaryexp -> PLUS primaryexp .)
    OR              reduce using rule 72 (unaryexp -> PLUS primaryexp .)
    PLUS            reduce using rule 72 (unaryexp -> PLUS primaryexp .)
    MINUS           reduce using rule 72 (unaryexp -> PLUS primaryexp .)
    TIMES           reduce using rule 72 (unaryexp -> PLUS primaryexp .)
    DIVIDE          reduce using rule 72 (unaryexp -> PLUS primaryexp .)
    MOD             reduce using rule 72 (unaryexp -> PLUS primaryexp .)
    POW             reduce using rule 72 (unaryexp -> PLUS primaryexp .)
    RBRACE          reduce using rule 72 (unaryexp -> PLUS primaryexp .)
    RPAREN          reduce using rule 72 (unaryexp -> PLUS primaryexp .)
    RSPAREN         reduce using rule 72 (unaryexp -> PLUS primaryexp .)
    TO              reduce using rule 72 (unaryexp -> PLUS primaryexp .)
    STEP            reduce using rule 72 (unaryexp -> PLUS primaryexp .)
    DO              reduce using rule 72 (unaryexp -> PLUS primaryexp .)

  ! BINARY_FNC      [ shift and go to state 54 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! LTE             [ shift and go to state 59 ]
  ! GTE             [ shift and go to state 60 ]
  ! EQUALITY        [ shift and go to state 61 ]
  ! INEQUALITY      [ shift and go to state 62 ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 64 ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 66 ]
  ! TIMES           [ shift and go to state 67 ]
  ! DIVIDE          [ shift and go to state 68 ]
  ! MOD             [ shift and go to state 69 ]
  ! POW             [ shift and go to state 70 ]

    comparisonoperator             shift and go to state 55
    mathoperator                   shift and go to state 56

state 85

    (73) unaryexp -> MINUS primaryexp .
    (46) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (47) binaryexp -> primaryexp . comparisonoperator primaryexp
    (48) binaryexp -> primaryexp . mathoperator primaryexp
    (76) comparisonoperator -> . LT
    (77) comparisonoperator -> . GT
    (78) comparisonoperator -> . LTE
    (79) comparisonoperator -> . GTE
    (80) comparisonoperator -> . EQUALITY
    (81) comparisonoperator -> . INEQUALITY
    (82) comparisonoperator -> . AND
    (83) comparisonoperator -> . OR
    (84) mathoperator -> . PLUS
    (85) mathoperator -> . MINUS
    (86) mathoperator -> . TIMES
    (87) mathoperator -> . DIVIDE
    (88) mathoperator -> . MOD
    (89) mathoperator -> . POW

    SEMI_COLON      reduce using rule 73 (unaryexp -> MINUS primaryexp .)
    COMMA           reduce using rule 73 (unaryexp -> MINUS primaryexp .)
    $end            reduce using rule 73 (unaryexp -> MINUS primaryexp .)
    BINARY_FNC      reduce using rule 73 (unaryexp -> MINUS primaryexp .)
    LT              reduce using rule 73 (unaryexp -> MINUS primaryexp .)
    GT              reduce using rule 73 (unaryexp -> MINUS primaryexp .)
    LTE             reduce using rule 73 (unaryexp -> MINUS primaryexp .)
    GTE             reduce using rule 73 (unaryexp -> MINUS primaryexp .)
    EQUALITY        reduce using rule 73 (unaryexp -> MINUS primaryexp .)
    INEQUALITY      reduce using rule 73 (unaryexp -> MINUS primaryexp .)
    AND             reduce using rule 73 (unaryexp -> MINUS primaryexp .)
    OR              reduce using rule 73 (unaryexp -> MINUS primaryexp .)
    PLUS            reduce using rule 73 (unaryexp -> MINUS primaryexp .)
    MINUS           reduce using rule 73 (unaryexp -> MINUS primaryexp .)
    TIMES           reduce using rule 73 (unaryexp -> MINUS primaryexp .)
    DIVIDE          reduce using rule 73 (unaryexp -> MINUS primaryexp .)
    MOD             reduce using rule 73 (unaryexp -> MINUS primaryexp .)
    POW             reduce using rule 73 (unaryexp -> MINUS primaryexp .)
    RBRACE          reduce using rule 73 (unaryexp -> MINUS primaryexp .)
    RPAREN          reduce using rule 73 (unaryexp -> MINUS primaryexp .)
    RSPAREN         reduce using rule 73 (unaryexp -> MINUS primaryexp .)
    TO              reduce using rule 73 (unaryexp -> MINUS primaryexp .)
    STEP            reduce using rule 73 (unaryexp -> MINUS primaryexp .)
    DO              reduce using rule 73 (unaryexp -> MINUS primaryexp .)

  ! BINARY_FNC      [ shift and go to state 54 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! LTE             [ shift and go to state 59 ]
  ! GTE             [ shift and go to state 60 ]
  ! EQUALITY        [ shift and go to state 61 ]
  ! INEQUALITY      [ shift and go to state 62 ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 64 ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 66 ]
  ! TIMES           [ shift and go to state 67 ]
  ! DIVIDE          [ shift and go to state 68 ]
  ! MOD             [ shift and go to state 69 ]
  ! POW             [ shift and go to state 70 ]

    comparisonoperator             shift and go to state 55
    mathoperator                   shift and go to state 56

state 86

    (74) unaryexp -> NOT primaryexp .
    (46) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (47) binaryexp -> primaryexp . comparisonoperator primaryexp
    (48) binaryexp -> primaryexp . mathoperator primaryexp
    (76) comparisonoperator -> . LT
    (77) comparisonoperator -> . GT
    (78) comparisonoperator -> . LTE
    (79) comparisonoperator -> . GTE
    (80) comparisonoperator -> . EQUALITY
    (81) comparisonoperator -> . INEQUALITY
    (82) comparisonoperator -> . AND
    (83) comparisonoperator -> . OR
    (84) mathoperator -> . PLUS
    (85) mathoperator -> . MINUS
    (86) mathoperator -> . TIMES
    (87) mathoperator -> . DIVIDE
    (88) mathoperator -> . MOD
    (89) mathoperator -> . POW

    SEMI_COLON      reduce using rule 74 (unaryexp -> NOT primaryexp .)
    COMMA           reduce using rule 74 (unaryexp -> NOT primaryexp .)
    $end            reduce using rule 74 (unaryexp -> NOT primaryexp .)
    BINARY_FNC      reduce using rule 74 (unaryexp -> NOT primaryexp .)
    LT              reduce using rule 74 (unaryexp -> NOT primaryexp .)
    GT              reduce using rule 74 (unaryexp -> NOT primaryexp .)
    LTE             reduce using rule 74 (unaryexp -> NOT primaryexp .)
    GTE             reduce using rule 74 (unaryexp -> NOT primaryexp .)
    EQUALITY        reduce using rule 74 (unaryexp -> NOT primaryexp .)
    INEQUALITY      reduce using rule 74 (unaryexp -> NOT primaryexp .)
    AND             reduce using rule 74 (unaryexp -> NOT primaryexp .)
    OR              reduce using rule 74 (unaryexp -> NOT primaryexp .)
    PLUS            reduce using rule 74 (unaryexp -> NOT primaryexp .)
    MINUS           reduce using rule 74 (unaryexp -> NOT primaryexp .)
    TIMES           reduce using rule 74 (unaryexp -> NOT primaryexp .)
    DIVIDE          reduce using rule 74 (unaryexp -> NOT primaryexp .)
    MOD             reduce using rule 74 (unaryexp -> NOT primaryexp .)
    POW             reduce using rule 74 (unaryexp -> NOT primaryexp .)
    RBRACE          reduce using rule 74 (unaryexp -> NOT primaryexp .)
    RPAREN          reduce using rule 74 (unaryexp -> NOT primaryexp .)
    RSPAREN         reduce using rule 74 (unaryexp -> NOT primaryexp .)
    TO              reduce using rule 74 (unaryexp -> NOT primaryexp .)
    STEP            reduce using rule 74 (unaryexp -> NOT primaryexp .)
    DO              reduce using rule 74 (unaryexp -> NOT primaryexp .)

  ! BINARY_FNC      [ shift and go to state 54 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! LTE             [ shift and go to state 59 ]
  ! GTE             [ shift and go to state 60 ]
  ! EQUALITY        [ shift and go to state 61 ]
  ! INEQUALITY      [ shift and go to state 62 ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 64 ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 66 ]
  ! TIMES           [ shift and go to state 67 ]
  ! DIVIDE          [ shift and go to state 68 ]
  ! MOD             [ shift and go to state 69 ]
  ! POW             [ shift and go to state 70 ]

    comparisonoperator             shift and go to state 55
    mathoperator                   shift and go to state 56

state 87

    (20) ifstatement -> iftype THEN . bracedexp
    (22) ifstatement -> iftype THEN . bracedexp ELSE bracedexp
    (59) bracedexp -> . LBRACE new_scope code RBRACE

    LBRACE          shift and go to state 29

    bracedexp                      shift and go to state 114

state 88

    (21) ifstatement -> iftype EXITWITH . bracedexp
    (59) bracedexp -> . LBRACE new_scope code RBRACE

    LBRACE          shift and go to state 29

    bracedexp                      shift and go to state 115

state 89

    (27) whileloop -> whiletype DO . bracedexp
    (59) bracedexp -> . LBRACE new_scope code RBRACE

    LBRACE          shift and go to state 29

    bracedexp                      shift and go to state 116

state 90

    (31) forloop -> fortype DO . bracedexp_noscope
    (34) bracedexp_noscope -> . LBRACE code RBRACE

    LBRACE          shift and go to state 118

    bracedexp_noscope              shift and go to state 117

state 91

    (25) withstatement -> withstatementinit bracedexp .

    SEMI_COLON      reduce using rule 25 (withstatement -> withstatementinit bracedexp .)
    COMMA           reduce using rule 25 (withstatement -> withstatementinit bracedexp .)
    $end            reduce using rule 25 (withstatement -> withstatementinit bracedexp .)
    RBRACE          reduce using rule 25 (withstatement -> withstatementinit bracedexp .)


state 92

    (59) bracedexp -> LBRACE new_scope . code RBRACE
    (1) code -> . empty
    (2) code -> . statement
    (3) code -> . statement terminator code
    (100) empty -> .
    (4) statement -> . controlstructure
    (5) statement -> . assignment
    (6) statement -> . binaryexp
    (7) statement -> . nularexp
    (8) statement -> . unaryexp
    (11) controlstructure -> . ifstatement
    (12) controlstructure -> . whileloop
    (13) controlstructure -> . forloop
    (14) controlstructure -> . withstatement
    (35) assignment -> . assignment_code code RBRACE
    (36) assignment -> . definition EQUAL primaryexp
    (37) assignment -> . variable EQUAL primaryexp
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (20) ifstatement -> . iftype THEN bracedexp
    (21) ifstatement -> . iftype EXITWITH bracedexp
    (22) ifstatement -> . iftype THEN bracedexp ELSE bracedexp
    (27) whileloop -> . whiletype DO bracedexp
    (31) forloop -> . fortype DO bracedexp_noscope
    (25) withstatement -> . withstatementinit bracedexp
    (38) assignment_code -> . definition EQUAL LBRACE
    (39) assignment_code -> . variable EQUAL LBRACE
    (41) definition -> . PRIVATE PRIVATE_ID
    (44) variable -> . PRIVATE_ID
    (45) variable -> . GLOBAL_ID
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (40) arraydefinition -> . PRIVATE stringarray
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (24) withstatementinit -> . withtype DO
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (23) withtype -> . WITH NAMESPACE

    RBRACE          reduce using rule 100 (empty -> .)
    NULAR_FNC       shift and go to state 17
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    PRIVATE         shift and go to state 30
    PRIVATE_ID      shift and go to state 31
    GLOBAL_ID       shift and go to state 32
    LPAREN          shift and go to state 36
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 41
    WITH            shift and go to state 48

    code                           shift and go to state 119
    empty                          shift and go to state 2
    statement                      shift and go to state 3
    controlstructure               shift and go to state 4
    assignment                     shift and go to state 5
    binaryexp                      shift and go to state 6
    nularexp                       shift and go to state 7
    unaryexp                       shift and go to state 8
    ifstatement                    shift and go to state 9
    whileloop                      shift and go to state 10
    forloop                        shift and go to state 11
    withstatement                  shift and go to state 12
    assignment_code                shift and go to state 13
    definition                     shift and go to state 14
    primaryexp                     shift and go to state 15
    variable                       shift and go to state 16
    identifier                     shift and go to state 18
    arraydefinition                shift and go to state 23
    iftype                         shift and go to state 24
    bracedexp                      shift and go to state 25
    whiletype                      shift and go to state 26
    fortype                        shift and go to state 27
    withstatementinit              shift and go to state 28
    number                         shift and go to state 33
    helpertype                     shift and go to state 34
    string                         shift and go to state 35
    array                          shift and go to state 37
    withtype                       shift and go to state 42

state 93

    (41) definition -> PRIVATE PRIVATE_ID .

    EQUAL           reduce using rule 41 (definition -> PRIVATE PRIVATE_ID .)


state 94

    (40) arraydefinition -> PRIVATE stringarray .

    SEMI_COLON      reduce using rule 40 (arraydefinition -> PRIVATE stringarray .)
    COMMA           reduce using rule 40 (arraydefinition -> PRIVATE stringarray .)
    $end            reduce using rule 40 (arraydefinition -> PRIVATE stringarray .)
    BINARY_FNC      reduce using rule 40 (arraydefinition -> PRIVATE stringarray .)
    LT              reduce using rule 40 (arraydefinition -> PRIVATE stringarray .)
    GT              reduce using rule 40 (arraydefinition -> PRIVATE stringarray .)
    LTE             reduce using rule 40 (arraydefinition -> PRIVATE stringarray .)
    GTE             reduce using rule 40 (arraydefinition -> PRIVATE stringarray .)
    EQUALITY        reduce using rule 40 (arraydefinition -> PRIVATE stringarray .)
    INEQUALITY      reduce using rule 40 (arraydefinition -> PRIVATE stringarray .)
    AND             reduce using rule 40 (arraydefinition -> PRIVATE stringarray .)
    OR              reduce using rule 40 (arraydefinition -> PRIVATE stringarray .)
    PLUS            reduce using rule 40 (arraydefinition -> PRIVATE stringarray .)
    MINUS           reduce using rule 40 (arraydefinition -> PRIVATE stringarray .)
    TIMES           reduce using rule 40 (arraydefinition -> PRIVATE stringarray .)
    DIVIDE          reduce using rule 40 (arraydefinition -> PRIVATE stringarray .)
    MOD             reduce using rule 40 (arraydefinition -> PRIVATE stringarray .)
    POW             reduce using rule 40 (arraydefinition -> PRIVATE stringarray .)
    RBRACE          reduce using rule 40 (arraydefinition -> PRIVATE stringarray .)
    RPAREN          reduce using rule 40 (arraydefinition -> PRIVATE stringarray .)
    RSPAREN         reduce using rule 40 (arraydefinition -> PRIVATE stringarray .)
    TO              reduce using rule 40 (arraydefinition -> PRIVATE stringarray .)
    STEP            reduce using rule 40 (arraydefinition -> PRIVATE stringarray .)
    DO              reduce using rule 40 (arraydefinition -> PRIVATE stringarray .)


state 95

    (65) stringarray -> LSPAREN . RSPAREN
    (66) stringarray -> LSPAREN . stringarrayelement RSPAREN
    (67) stringarrayelement -> . string
    (68) stringarrayelement -> . string COMMA stringarrayelement
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE

    RSPAREN         shift and go to state 120
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47

    stringarrayelement             shift and go to state 121
    string                         shift and go to state 122

state 96

    (57) primaryexp -> LPAREN binaryexp . RPAREN
    (55) primaryexp -> binaryexp .

    RPAREN          shift and go to state 123
    BINARY_FNC      reduce using rule 55 (primaryexp -> binaryexp .)
    LT              reduce using rule 55 (primaryexp -> binaryexp .)
    GT              reduce using rule 55 (primaryexp -> binaryexp .)
    LTE             reduce using rule 55 (primaryexp -> binaryexp .)
    GTE             reduce using rule 55 (primaryexp -> binaryexp .)
    EQUALITY        reduce using rule 55 (primaryexp -> binaryexp .)
    INEQUALITY      reduce using rule 55 (primaryexp -> binaryexp .)
    AND             reduce using rule 55 (primaryexp -> binaryexp .)
    OR              reduce using rule 55 (primaryexp -> binaryexp .)
    PLUS            reduce using rule 55 (primaryexp -> binaryexp .)
    MINUS           reduce using rule 55 (primaryexp -> binaryexp .)
    TIMES           reduce using rule 55 (primaryexp -> binaryexp .)
    DIVIDE          reduce using rule 55 (primaryexp -> binaryexp .)
    MOD             reduce using rule 55 (primaryexp -> binaryexp .)
    POW             reduce using rule 55 (primaryexp -> binaryexp .)


state 97

    (19) iftype -> IF LPAREN . booleanexp RPAREN
    (90) booleanexp -> . primaryexp
    (91) booleanexp -> . primaryexp comparisonoperator booleanexp
    (92) booleanexp -> . primaryexp comparisonoperator LBRACE booleanexp RBRACE
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (40) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    PRIVATE_ID      shift and go to state 77
    GLOBAL_ID       shift and go to state 78
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 41
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    WITH            shift and go to state 48
    PRIVATE         shift and go to state 83

    booleanexp                     shift and go to state 124
    primaryexp                     shift and go to state 125
    number                         shift and go to state 33
    identifier                     shift and go to state 73
    helpertype                     shift and go to state 34
    unaryexp                       shift and go to state 74
    nularexp                       shift and go to state 75
    string                         shift and go to state 35
    binaryexp                      shift and go to state 76
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 79
    whiletype                      shift and go to state 80
    fortype                        shift and go to state 81
    withtype                       shift and go to state 82
    arraydefinition                shift and go to state 23

state 98

    (26) whiletype -> WHILE LBRACE . booleanexp RBRACE
    (90) booleanexp -> . primaryexp
    (91) booleanexp -> . primaryexp comparisonoperator booleanexp
    (92) booleanexp -> . primaryexp comparisonoperator LBRACE booleanexp RBRACE
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (40) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    PRIVATE_ID      shift and go to state 77
    GLOBAL_ID       shift and go to state 78
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 41
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    WITH            shift and go to state 48
    PRIVATE         shift and go to state 83

    booleanexp                     shift and go to state 126
    primaryexp                     shift and go to state 125
    number                         shift and go to state 33
    identifier                     shift and go to state 73
    helpertype                     shift and go to state 34
    unaryexp                       shift and go to state 74
    nularexp                       shift and go to state 75
    string                         shift and go to state 35
    binaryexp                      shift and go to state 76
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 79
    whiletype                      shift and go to state 80
    fortype                        shift and go to state 81
    withtype                       shift and go to state 82
    arraydefinition                shift and go to state 23

state 99

    (28) fortype -> FOR new_scope . string FROM primaryexp TO primaryexp
    (29) fortype -> FOR new_scope . string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> FOR new_scope . LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE

    LSPAREN         shift and go to state 128
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47

    string                         shift and go to state 127

state 100

    (61) array -> LSPAREN RSPAREN .

    BINARY_FNC      reduce using rule 61 (array -> LSPAREN RSPAREN .)
    LT              reduce using rule 61 (array -> LSPAREN RSPAREN .)
    GT              reduce using rule 61 (array -> LSPAREN RSPAREN .)
    LTE             reduce using rule 61 (array -> LSPAREN RSPAREN .)
    GTE             reduce using rule 61 (array -> LSPAREN RSPAREN .)
    EQUALITY        reduce using rule 61 (array -> LSPAREN RSPAREN .)
    INEQUALITY      reduce using rule 61 (array -> LSPAREN RSPAREN .)
    AND             reduce using rule 61 (array -> LSPAREN RSPAREN .)
    OR              reduce using rule 61 (array -> LSPAREN RSPAREN .)
    PLUS            reduce using rule 61 (array -> LSPAREN RSPAREN .)
    MINUS           reduce using rule 61 (array -> LSPAREN RSPAREN .)
    TIMES           reduce using rule 61 (array -> LSPAREN RSPAREN .)
    DIVIDE          reduce using rule 61 (array -> LSPAREN RSPAREN .)
    MOD             reduce using rule 61 (array -> LSPAREN RSPAREN .)
    POW             reduce using rule 61 (array -> LSPAREN RSPAREN .)
    SEMI_COLON      reduce using rule 61 (array -> LSPAREN RSPAREN .)
    COMMA           reduce using rule 61 (array -> LSPAREN RSPAREN .)
    $end            reduce using rule 61 (array -> LSPAREN RSPAREN .)
    RBRACE          reduce using rule 61 (array -> LSPAREN RSPAREN .)
    RPAREN          reduce using rule 61 (array -> LSPAREN RSPAREN .)
    RSPAREN         reduce using rule 61 (array -> LSPAREN RSPAREN .)
    TO              reduce using rule 61 (array -> LSPAREN RSPAREN .)
    STEP            reduce using rule 61 (array -> LSPAREN RSPAREN .)
    DO              reduce using rule 61 (array -> LSPAREN RSPAREN .)


state 101

    (62) array -> LSPAREN arrayelement . RSPAREN

    RSPAREN         shift and go to state 129


state 102

    (63) arrayelement -> binaryexp .
    (64) arrayelement -> binaryexp . COMMA arrayelement
    (55) primaryexp -> binaryexp .

    RSPAREN         reduce using rule 63 (arrayelement -> binaryexp .)
    COMMA           shift and go to state 130
    BINARY_FNC      reduce using rule 55 (primaryexp -> binaryexp .)
    LT              reduce using rule 55 (primaryexp -> binaryexp .)
    GT              reduce using rule 55 (primaryexp -> binaryexp .)
    LTE             reduce using rule 55 (primaryexp -> binaryexp .)
    GTE             reduce using rule 55 (primaryexp -> binaryexp .)
    EQUALITY        reduce using rule 55 (primaryexp -> binaryexp .)
    INEQUALITY      reduce using rule 55 (primaryexp -> binaryexp .)
    AND             reduce using rule 55 (primaryexp -> binaryexp .)
    OR              reduce using rule 55 (primaryexp -> binaryexp .)
    PLUS            reduce using rule 55 (primaryexp -> binaryexp .)
    MINUS           reduce using rule 55 (primaryexp -> binaryexp .)
    TIMES           reduce using rule 55 (primaryexp -> binaryexp .)
    DIVIDE          reduce using rule 55 (primaryexp -> binaryexp .)
    MOD             reduce using rule 55 (primaryexp -> binaryexp .)
    POW             reduce using rule 55 (primaryexp -> binaryexp .)


state 103

    (24) withstatementinit -> withtype DO .

    LBRACE          reduce using rule 24 (withstatementinit -> withtype DO .)


state 104

    (23) withtype -> WITH NAMESPACE .

    DO              reduce using rule 23 (withtype -> WITH NAMESPACE .)
    BINARY_FNC      reduce using rule 23 (withtype -> WITH NAMESPACE .)
    LT              reduce using rule 23 (withtype -> WITH NAMESPACE .)
    GT              reduce using rule 23 (withtype -> WITH NAMESPACE .)
    LTE             reduce using rule 23 (withtype -> WITH NAMESPACE .)
    GTE             reduce using rule 23 (withtype -> WITH NAMESPACE .)
    EQUALITY        reduce using rule 23 (withtype -> WITH NAMESPACE .)
    INEQUALITY      reduce using rule 23 (withtype -> WITH NAMESPACE .)
    AND             reduce using rule 23 (withtype -> WITH NAMESPACE .)
    OR              reduce using rule 23 (withtype -> WITH NAMESPACE .)
    PLUS            reduce using rule 23 (withtype -> WITH NAMESPACE .)
    MINUS           reduce using rule 23 (withtype -> WITH NAMESPACE .)
    TIMES           reduce using rule 23 (withtype -> WITH NAMESPACE .)
    DIVIDE          reduce using rule 23 (withtype -> WITH NAMESPACE .)
    MOD             reduce using rule 23 (withtype -> WITH NAMESPACE .)
    POW             reduce using rule 23 (withtype -> WITH NAMESPACE .)
    SEMI_COLON      reduce using rule 23 (withtype -> WITH NAMESPACE .)
    COMMA           reduce using rule 23 (withtype -> WITH NAMESPACE .)
    $end            reduce using rule 23 (withtype -> WITH NAMESPACE .)
    RBRACE          reduce using rule 23 (withtype -> WITH NAMESPACE .)
    RPAREN          reduce using rule 23 (withtype -> WITH NAMESPACE .)
    RSPAREN         reduce using rule 23 (withtype -> WITH NAMESPACE .)
    TO              reduce using rule 23 (withtype -> WITH NAMESPACE .)
    STEP            reduce using rule 23 (withtype -> WITH NAMESPACE .)


state 105

    (3) code -> statement terminator code .

    $end            reduce using rule 3 (code -> statement terminator code .)
    RBRACE          reduce using rule 3 (code -> statement terminator code .)


state 106

    (35) assignment -> assignment_code code RBRACE .

    SEMI_COLON      reduce using rule 35 (assignment -> assignment_code code RBRACE .)
    COMMA           reduce using rule 35 (assignment -> assignment_code code RBRACE .)
    $end            reduce using rule 35 (assignment -> assignment_code code RBRACE .)
    RBRACE          reduce using rule 35 (assignment -> assignment_code code RBRACE .)


state 107

    (36) assignment -> definition EQUAL primaryexp .
    (46) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (47) binaryexp -> primaryexp . comparisonoperator primaryexp
    (48) binaryexp -> primaryexp . mathoperator primaryexp
    (76) comparisonoperator -> . LT
    (77) comparisonoperator -> . GT
    (78) comparisonoperator -> . LTE
    (79) comparisonoperator -> . GTE
    (80) comparisonoperator -> . EQUALITY
    (81) comparisonoperator -> . INEQUALITY
    (82) comparisonoperator -> . AND
    (83) comparisonoperator -> . OR
    (84) mathoperator -> . PLUS
    (85) mathoperator -> . MINUS
    (86) mathoperator -> . TIMES
    (87) mathoperator -> . DIVIDE
    (88) mathoperator -> . MOD
    (89) mathoperator -> . POW

    SEMI_COLON      reduce using rule 36 (assignment -> definition EQUAL primaryexp .)
    COMMA           reduce using rule 36 (assignment -> definition EQUAL primaryexp .)
    $end            reduce using rule 36 (assignment -> definition EQUAL primaryexp .)
    RBRACE          reduce using rule 36 (assignment -> definition EQUAL primaryexp .)
    BINARY_FNC      shift and go to state 54
    LT              shift and go to state 57
    GT              shift and go to state 58
    LTE             shift and go to state 59
    GTE             shift and go to state 60
    EQUALITY        shift and go to state 61
    INEQUALITY      shift and go to state 62
    AND             shift and go to state 63
    OR              shift and go to state 64
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POW             shift and go to state 70

    comparisonoperator             shift and go to state 55
    mathoperator                   shift and go to state 56

state 108

    (38) assignment_code -> definition EQUAL LBRACE .
    (59) bracedexp -> LBRACE . new_scope code RBRACE
    (60) new_scope -> .

  ! reduce/reduce conflict for NULAR_FNC resolved using rule 38 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for UNARY_FNC resolved using rule 38 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for PLUS resolved using rule 38 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for MINUS resolved using rule 38 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for NOT resolved using rule 38 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for PRIVATE resolved using rule 38 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for PRIVATE_ID resolved using rule 38 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for GLOBAL_ID resolved using rule 38 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for LPAREN resolved using rule 38 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for IF resolved using rule 38 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for WHILE resolved using rule 38 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for FOR resolved using rule 38 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for NUMBER_REAL resolved using rule 38 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for NUMBER_EXP resolved using rule 38 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for NUMBER_HEX resolved using rule 38 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for STRING_SINGLE resolved using rule 38 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for STRING_DOUBLE resolved using rule 38 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for LBRACE resolved using rule 38 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for LSPAREN resolved using rule 38 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for WITH resolved using rule 38 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for RBRACE resolved using rule 38 (assignment_code -> definition EQUAL LBRACE .)
    NULAR_FNC       reduce using rule 38 (assignment_code -> definition EQUAL LBRACE .)
    UNARY_FNC       reduce using rule 38 (assignment_code -> definition EQUAL LBRACE .)
    PLUS            reduce using rule 38 (assignment_code -> definition EQUAL LBRACE .)
    MINUS           reduce using rule 38 (assignment_code -> definition EQUAL LBRACE .)
    NOT             reduce using rule 38 (assignment_code -> definition EQUAL LBRACE .)
    PRIVATE         reduce using rule 38 (assignment_code -> definition EQUAL LBRACE .)
    PRIVATE_ID      reduce using rule 38 (assignment_code -> definition EQUAL LBRACE .)
    GLOBAL_ID       reduce using rule 38 (assignment_code -> definition EQUAL LBRACE .)
    LPAREN          reduce using rule 38 (assignment_code -> definition EQUAL LBRACE .)
    IF              reduce using rule 38 (assignment_code -> definition EQUAL LBRACE .)
    WHILE           reduce using rule 38 (assignment_code -> definition EQUAL LBRACE .)
    FOR             reduce using rule 38 (assignment_code -> definition EQUAL LBRACE .)
    NUMBER_REAL     reduce using rule 38 (assignment_code -> definition EQUAL LBRACE .)
    NUMBER_EXP      reduce using rule 38 (assignment_code -> definition EQUAL LBRACE .)
    NUMBER_HEX      reduce using rule 38 (assignment_code -> definition EQUAL LBRACE .)
    STRING_SINGLE   reduce using rule 38 (assignment_code -> definition EQUAL LBRACE .)
    STRING_DOUBLE   reduce using rule 38 (assignment_code -> definition EQUAL LBRACE .)
    LBRACE          reduce using rule 38 (assignment_code -> definition EQUAL LBRACE .)
    LSPAREN         reduce using rule 38 (assignment_code -> definition EQUAL LBRACE .)
    WITH            reduce using rule 38 (assignment_code -> definition EQUAL LBRACE .)
    RBRACE          reduce using rule 38 (assignment_code -> definition EQUAL LBRACE .)

  ! NULAR_FNC       [ reduce using rule 60 (new_scope -> .) ]
  ! UNARY_FNC       [ reduce using rule 60 (new_scope -> .) ]
  ! PLUS            [ reduce using rule 60 (new_scope -> .) ]
  ! MINUS           [ reduce using rule 60 (new_scope -> .) ]
  ! NOT             [ reduce using rule 60 (new_scope -> .) ]
  ! PRIVATE         [ reduce using rule 60 (new_scope -> .) ]
  ! PRIVATE_ID      [ reduce using rule 60 (new_scope -> .) ]
  ! GLOBAL_ID       [ reduce using rule 60 (new_scope -> .) ]
  ! LPAREN          [ reduce using rule 60 (new_scope -> .) ]
  ! IF              [ reduce using rule 60 (new_scope -> .) ]
  ! WHILE           [ reduce using rule 60 (new_scope -> .) ]
  ! FOR             [ reduce using rule 60 (new_scope -> .) ]
  ! NUMBER_REAL     [ reduce using rule 60 (new_scope -> .) ]
  ! NUMBER_EXP      [ reduce using rule 60 (new_scope -> .) ]
  ! NUMBER_HEX      [ reduce using rule 60 (new_scope -> .) ]
  ! STRING_SINGLE   [ reduce using rule 60 (new_scope -> .) ]
  ! STRING_DOUBLE   [ reduce using rule 60 (new_scope -> .) ]
  ! LBRACE          [ reduce using rule 60 (new_scope -> .) ]
  ! LSPAREN         [ reduce using rule 60 (new_scope -> .) ]
  ! WITH            [ reduce using rule 60 (new_scope -> .) ]
  ! RBRACE          [ reduce using rule 60 (new_scope -> .) ]

    new_scope                      shift and go to state 92

state 109

    (46) binaryexp -> primaryexp BINARY_FNC primaryexp .
    (46) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (47) binaryexp -> primaryexp . comparisonoperator primaryexp
    (48) binaryexp -> primaryexp . mathoperator primaryexp
    (76) comparisonoperator -> . LT
    (77) comparisonoperator -> . GT
    (78) comparisonoperator -> . LTE
    (79) comparisonoperator -> . GTE
    (80) comparisonoperator -> . EQUALITY
    (81) comparisonoperator -> . INEQUALITY
    (82) comparisonoperator -> . AND
    (83) comparisonoperator -> . OR
    (84) mathoperator -> . PLUS
    (85) mathoperator -> . MINUS
    (86) mathoperator -> . TIMES
    (87) mathoperator -> . DIVIDE
    (88) mathoperator -> . MOD
    (89) mathoperator -> . POW

    SEMI_COLON      reduce using rule 46 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    COMMA           reduce using rule 46 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    $end            reduce using rule 46 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    BINARY_FNC      reduce using rule 46 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    LT              reduce using rule 46 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    GT              reduce using rule 46 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    LTE             reduce using rule 46 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    GTE             reduce using rule 46 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    EQUALITY        reduce using rule 46 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    INEQUALITY      reduce using rule 46 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    AND             reduce using rule 46 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    OR              reduce using rule 46 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    RBRACE          reduce using rule 46 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    RPAREN          reduce using rule 46 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    RSPAREN         reduce using rule 46 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    TO              reduce using rule 46 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    STEP            reduce using rule 46 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    DO              reduce using rule 46 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POW             shift and go to state 70

  ! PLUS            [ reduce using rule 46 (binaryexp -> primaryexp BINARY_FNC primaryexp .) ]
  ! MINUS           [ reduce using rule 46 (binaryexp -> primaryexp BINARY_FNC primaryexp .) ]
  ! TIMES           [ reduce using rule 46 (binaryexp -> primaryexp BINARY_FNC primaryexp .) ]
  ! DIVIDE          [ reduce using rule 46 (binaryexp -> primaryexp BINARY_FNC primaryexp .) ]
  ! MOD             [ reduce using rule 46 (binaryexp -> primaryexp BINARY_FNC primaryexp .) ]
  ! POW             [ reduce using rule 46 (binaryexp -> primaryexp BINARY_FNC primaryexp .) ]
  ! BINARY_FNC      [ shift and go to state 54 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! LTE             [ shift and go to state 59 ]
  ! GTE             [ shift and go to state 60 ]
  ! EQUALITY        [ shift and go to state 61 ]
  ! INEQUALITY      [ shift and go to state 62 ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 64 ]

    comparisonoperator             shift and go to state 55
    mathoperator                   shift and go to state 56

state 110

    (47) binaryexp -> primaryexp comparisonoperator primaryexp .
    (46) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (47) binaryexp -> primaryexp . comparisonoperator primaryexp
    (48) binaryexp -> primaryexp . mathoperator primaryexp
    (76) comparisonoperator -> . LT
    (77) comparisonoperator -> . GT
    (78) comparisonoperator -> . LTE
    (79) comparisonoperator -> . GTE
    (80) comparisonoperator -> . EQUALITY
    (81) comparisonoperator -> . INEQUALITY
    (82) comparisonoperator -> . AND
    (83) comparisonoperator -> . OR
    (84) mathoperator -> . PLUS
    (85) mathoperator -> . MINUS
    (86) mathoperator -> . TIMES
    (87) mathoperator -> . DIVIDE
    (88) mathoperator -> . MOD
    (89) mathoperator -> . POW

    SEMI_COLON      reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    COMMA           reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    $end            reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    BINARY_FNC      reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    LT              reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    GT              reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    LTE             reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    GTE             reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    EQUALITY        reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    INEQUALITY      reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    AND             reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    OR              reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    RBRACE          reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    RPAREN          reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    RSPAREN         reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    TO              reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    STEP            reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    DO              reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POW             shift and go to state 70

  ! PLUS            [ reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! MINUS           [ reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! TIMES           [ reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! DIVIDE          [ reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! MOD             [ reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! POW             [ reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! BINARY_FNC      [ shift and go to state 54 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! LTE             [ shift and go to state 59 ]
  ! GTE             [ shift and go to state 60 ]
  ! EQUALITY        [ shift and go to state 61 ]
  ! INEQUALITY      [ shift and go to state 62 ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 64 ]

    comparisonoperator             shift and go to state 55
    mathoperator                   shift and go to state 56

state 111

    (48) binaryexp -> primaryexp mathoperator primaryexp .
    (46) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (47) binaryexp -> primaryexp . comparisonoperator primaryexp
    (48) binaryexp -> primaryexp . mathoperator primaryexp
    (76) comparisonoperator -> . LT
    (77) comparisonoperator -> . GT
    (78) comparisonoperator -> . LTE
    (79) comparisonoperator -> . GTE
    (80) comparisonoperator -> . EQUALITY
    (81) comparisonoperator -> . INEQUALITY
    (82) comparisonoperator -> . AND
    (83) comparisonoperator -> . OR
    (84) mathoperator -> . PLUS
    (85) mathoperator -> . MINUS
    (86) mathoperator -> . TIMES
    (87) mathoperator -> . DIVIDE
    (88) mathoperator -> . MOD
    (89) mathoperator -> . POW

    SEMI_COLON      reduce using rule 48 (binaryexp -> primaryexp mathoperator primaryexp .)
    COMMA           reduce using rule 48 (binaryexp -> primaryexp mathoperator primaryexp .)
    $end            reduce using rule 48 (binaryexp -> primaryexp mathoperator primaryexp .)
    BINARY_FNC      reduce using rule 48 (binaryexp -> primaryexp mathoperator primaryexp .)
    LT              reduce using rule 48 (binaryexp -> primaryexp mathoperator primaryexp .)
    GT              reduce using rule 48 (binaryexp -> primaryexp mathoperator primaryexp .)
    LTE             reduce using rule 48 (binaryexp -> primaryexp mathoperator primaryexp .)
    GTE             reduce using rule 48 (binaryexp -> primaryexp mathoperator primaryexp .)
    EQUALITY        reduce using rule 48 (binaryexp -> primaryexp mathoperator primaryexp .)
    INEQUALITY      reduce using rule 48 (binaryexp -> primaryexp mathoperator primaryexp .)
    AND             reduce using rule 48 (binaryexp -> primaryexp mathoperator primaryexp .)
    OR              reduce using rule 48 (binaryexp -> primaryexp mathoperator primaryexp .)
    RBRACE          reduce using rule 48 (binaryexp -> primaryexp mathoperator primaryexp .)
    RPAREN          reduce using rule 48 (binaryexp -> primaryexp mathoperator primaryexp .)
    RSPAREN         reduce using rule 48 (binaryexp -> primaryexp mathoperator primaryexp .)
    TO              reduce using rule 48 (binaryexp -> primaryexp mathoperator primaryexp .)
    STEP            reduce using rule 48 (binaryexp -> primaryexp mathoperator primaryexp .)
    DO              reduce using rule 48 (binaryexp -> primaryexp mathoperator primaryexp .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POW             shift and go to state 70

  ! PLUS            [ reduce using rule 48 (binaryexp -> primaryexp mathoperator primaryexp .) ]
  ! MINUS           [ reduce using rule 48 (binaryexp -> primaryexp mathoperator primaryexp .) ]
  ! TIMES           [ reduce using rule 48 (binaryexp -> primaryexp mathoperator primaryexp .) ]
  ! DIVIDE          [ reduce using rule 48 (binaryexp -> primaryexp mathoperator primaryexp .) ]
  ! MOD             [ reduce using rule 48 (binaryexp -> primaryexp mathoperator primaryexp .) ]
  ! POW             [ reduce using rule 48 (binaryexp -> primaryexp mathoperator primaryexp .) ]
  ! BINARY_FNC      [ shift and go to state 54 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! LTE             [ shift and go to state 59 ]
  ! GTE             [ shift and go to state 60 ]
  ! EQUALITY        [ shift and go to state 61 ]
  ! INEQUALITY      [ shift and go to state 62 ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 64 ]

    mathoperator                   shift and go to state 56
    comparisonoperator             shift and go to state 55

state 112

    (37) assignment -> variable EQUAL primaryexp .
    (46) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (47) binaryexp -> primaryexp . comparisonoperator primaryexp
    (48) binaryexp -> primaryexp . mathoperator primaryexp
    (76) comparisonoperator -> . LT
    (77) comparisonoperator -> . GT
    (78) comparisonoperator -> . LTE
    (79) comparisonoperator -> . GTE
    (80) comparisonoperator -> . EQUALITY
    (81) comparisonoperator -> . INEQUALITY
    (82) comparisonoperator -> . AND
    (83) comparisonoperator -> . OR
    (84) mathoperator -> . PLUS
    (85) mathoperator -> . MINUS
    (86) mathoperator -> . TIMES
    (87) mathoperator -> . DIVIDE
    (88) mathoperator -> . MOD
    (89) mathoperator -> . POW

    SEMI_COLON      reduce using rule 37 (assignment -> variable EQUAL primaryexp .)
    COMMA           reduce using rule 37 (assignment -> variable EQUAL primaryexp .)
    $end            reduce using rule 37 (assignment -> variable EQUAL primaryexp .)
    RBRACE          reduce using rule 37 (assignment -> variable EQUAL primaryexp .)
    BINARY_FNC      shift and go to state 54
    LT              shift and go to state 57
    GT              shift and go to state 58
    LTE             shift and go to state 59
    GTE             shift and go to state 60
    EQUALITY        shift and go to state 61
    INEQUALITY      shift and go to state 62
    AND             shift and go to state 63
    OR              shift and go to state 64
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POW             shift and go to state 70

    comparisonoperator             shift and go to state 55
    mathoperator                   shift and go to state 56

state 113

    (39) assignment_code -> variable EQUAL LBRACE .
    (59) bracedexp -> LBRACE . new_scope code RBRACE
    (60) new_scope -> .

  ! reduce/reduce conflict for NULAR_FNC resolved using rule 39 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for UNARY_FNC resolved using rule 39 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for PLUS resolved using rule 39 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for MINUS resolved using rule 39 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for NOT resolved using rule 39 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for PRIVATE resolved using rule 39 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for PRIVATE_ID resolved using rule 39 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for GLOBAL_ID resolved using rule 39 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for LPAREN resolved using rule 39 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for IF resolved using rule 39 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for WHILE resolved using rule 39 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for FOR resolved using rule 39 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for NUMBER_REAL resolved using rule 39 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for NUMBER_EXP resolved using rule 39 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for NUMBER_HEX resolved using rule 39 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for STRING_SINGLE resolved using rule 39 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for STRING_DOUBLE resolved using rule 39 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for LBRACE resolved using rule 39 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for LSPAREN resolved using rule 39 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for WITH resolved using rule 39 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for RBRACE resolved using rule 39 (assignment_code -> variable EQUAL LBRACE .)
    NULAR_FNC       reduce using rule 39 (assignment_code -> variable EQUAL LBRACE .)
    UNARY_FNC       reduce using rule 39 (assignment_code -> variable EQUAL LBRACE .)
    PLUS            reduce using rule 39 (assignment_code -> variable EQUAL LBRACE .)
    MINUS           reduce using rule 39 (assignment_code -> variable EQUAL LBRACE .)
    NOT             reduce using rule 39 (assignment_code -> variable EQUAL LBRACE .)
    PRIVATE         reduce using rule 39 (assignment_code -> variable EQUAL LBRACE .)
    PRIVATE_ID      reduce using rule 39 (assignment_code -> variable EQUAL LBRACE .)
    GLOBAL_ID       reduce using rule 39 (assignment_code -> variable EQUAL LBRACE .)
    LPAREN          reduce using rule 39 (assignment_code -> variable EQUAL LBRACE .)
    IF              reduce using rule 39 (assignment_code -> variable EQUAL LBRACE .)
    WHILE           reduce using rule 39 (assignment_code -> variable EQUAL LBRACE .)
    FOR             reduce using rule 39 (assignment_code -> variable EQUAL LBRACE .)
    NUMBER_REAL     reduce using rule 39 (assignment_code -> variable EQUAL LBRACE .)
    NUMBER_EXP      reduce using rule 39 (assignment_code -> variable EQUAL LBRACE .)
    NUMBER_HEX      reduce using rule 39 (assignment_code -> variable EQUAL LBRACE .)
    STRING_SINGLE   reduce using rule 39 (assignment_code -> variable EQUAL LBRACE .)
    STRING_DOUBLE   reduce using rule 39 (assignment_code -> variable EQUAL LBRACE .)
    LBRACE          reduce using rule 39 (assignment_code -> variable EQUAL LBRACE .)
    LSPAREN         reduce using rule 39 (assignment_code -> variable EQUAL LBRACE .)
    WITH            reduce using rule 39 (assignment_code -> variable EQUAL LBRACE .)
    RBRACE          reduce using rule 39 (assignment_code -> variable EQUAL LBRACE .)

  ! NULAR_FNC       [ reduce using rule 60 (new_scope -> .) ]
  ! UNARY_FNC       [ reduce using rule 60 (new_scope -> .) ]
  ! PLUS            [ reduce using rule 60 (new_scope -> .) ]
  ! MINUS           [ reduce using rule 60 (new_scope -> .) ]
  ! NOT             [ reduce using rule 60 (new_scope -> .) ]
  ! PRIVATE         [ reduce using rule 60 (new_scope -> .) ]
  ! PRIVATE_ID      [ reduce using rule 60 (new_scope -> .) ]
  ! GLOBAL_ID       [ reduce using rule 60 (new_scope -> .) ]
  ! LPAREN          [ reduce using rule 60 (new_scope -> .) ]
  ! IF              [ reduce using rule 60 (new_scope -> .) ]
  ! WHILE           [ reduce using rule 60 (new_scope -> .) ]
  ! FOR             [ reduce using rule 60 (new_scope -> .) ]
  ! NUMBER_REAL     [ reduce using rule 60 (new_scope -> .) ]
  ! NUMBER_EXP      [ reduce using rule 60 (new_scope -> .) ]
  ! NUMBER_HEX      [ reduce using rule 60 (new_scope -> .) ]
  ! STRING_SINGLE   [ reduce using rule 60 (new_scope -> .) ]
  ! STRING_DOUBLE   [ reduce using rule 60 (new_scope -> .) ]
  ! LBRACE          [ reduce using rule 60 (new_scope -> .) ]
  ! LSPAREN         [ reduce using rule 60 (new_scope -> .) ]
  ! WITH            [ reduce using rule 60 (new_scope -> .) ]
  ! RBRACE          [ reduce using rule 60 (new_scope -> .) ]

    new_scope                      shift and go to state 92

state 114

    (20) ifstatement -> iftype THEN bracedexp .
    (22) ifstatement -> iftype THEN bracedexp . ELSE bracedexp

    SEMI_COLON      reduce using rule 20 (ifstatement -> iftype THEN bracedexp .)
    COMMA           reduce using rule 20 (ifstatement -> iftype THEN bracedexp .)
    $end            reduce using rule 20 (ifstatement -> iftype THEN bracedexp .)
    RBRACE          reduce using rule 20 (ifstatement -> iftype THEN bracedexp .)
    ELSE            shift and go to state 131


state 115

    (21) ifstatement -> iftype EXITWITH bracedexp .

    SEMI_COLON      reduce using rule 21 (ifstatement -> iftype EXITWITH bracedexp .)
    COMMA           reduce using rule 21 (ifstatement -> iftype EXITWITH bracedexp .)
    $end            reduce using rule 21 (ifstatement -> iftype EXITWITH bracedexp .)
    RBRACE          reduce using rule 21 (ifstatement -> iftype EXITWITH bracedexp .)


state 116

    (27) whileloop -> whiletype DO bracedexp .

    SEMI_COLON      reduce using rule 27 (whileloop -> whiletype DO bracedexp .)
    COMMA           reduce using rule 27 (whileloop -> whiletype DO bracedexp .)
    $end            reduce using rule 27 (whileloop -> whiletype DO bracedexp .)
    RBRACE          reduce using rule 27 (whileloop -> whiletype DO bracedexp .)


state 117

    (31) forloop -> fortype DO bracedexp_noscope .

    SEMI_COLON      reduce using rule 31 (forloop -> fortype DO bracedexp_noscope .)
    COMMA           reduce using rule 31 (forloop -> fortype DO bracedexp_noscope .)
    $end            reduce using rule 31 (forloop -> fortype DO bracedexp_noscope .)
    RBRACE          reduce using rule 31 (forloop -> fortype DO bracedexp_noscope .)


state 118

    (34) bracedexp_noscope -> LBRACE . code RBRACE
    (1) code -> . empty
    (2) code -> . statement
    (3) code -> . statement terminator code
    (100) empty -> .
    (4) statement -> . controlstructure
    (5) statement -> . assignment
    (6) statement -> . binaryexp
    (7) statement -> . nularexp
    (8) statement -> . unaryexp
    (11) controlstructure -> . ifstatement
    (12) controlstructure -> . whileloop
    (13) controlstructure -> . forloop
    (14) controlstructure -> . withstatement
    (35) assignment -> . assignment_code code RBRACE
    (36) assignment -> . definition EQUAL primaryexp
    (37) assignment -> . variable EQUAL primaryexp
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (20) ifstatement -> . iftype THEN bracedexp
    (21) ifstatement -> . iftype EXITWITH bracedexp
    (22) ifstatement -> . iftype THEN bracedexp ELSE bracedexp
    (27) whileloop -> . whiletype DO bracedexp
    (31) forloop -> . fortype DO bracedexp_noscope
    (25) withstatement -> . withstatementinit bracedexp
    (38) assignment_code -> . definition EQUAL LBRACE
    (39) assignment_code -> . variable EQUAL LBRACE
    (41) definition -> . PRIVATE PRIVATE_ID
    (44) variable -> . PRIVATE_ID
    (45) variable -> . GLOBAL_ID
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (40) arraydefinition -> . PRIVATE stringarray
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (24) withstatementinit -> . withtype DO
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (23) withtype -> . WITH NAMESPACE

    RBRACE          reduce using rule 100 (empty -> .)
    NULAR_FNC       shift and go to state 17
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    PRIVATE         shift and go to state 30
    PRIVATE_ID      shift and go to state 31
    GLOBAL_ID       shift and go to state 32
    LPAREN          shift and go to state 36
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 41
    WITH            shift and go to state 48

    code                           shift and go to state 132
    empty                          shift and go to state 2
    statement                      shift and go to state 3
    controlstructure               shift and go to state 4
    assignment                     shift and go to state 5
    binaryexp                      shift and go to state 6
    nularexp                       shift and go to state 7
    unaryexp                       shift and go to state 8
    ifstatement                    shift and go to state 9
    whileloop                      shift and go to state 10
    forloop                        shift and go to state 11
    withstatement                  shift and go to state 12
    assignment_code                shift and go to state 13
    definition                     shift and go to state 14
    primaryexp                     shift and go to state 15
    variable                       shift and go to state 16
    identifier                     shift and go to state 18
    arraydefinition                shift and go to state 23
    iftype                         shift and go to state 24
    bracedexp                      shift and go to state 25
    whiletype                      shift and go to state 26
    fortype                        shift and go to state 27
    withstatementinit              shift and go to state 28
    number                         shift and go to state 33
    helpertype                     shift and go to state 34
    string                         shift and go to state 35
    array                          shift and go to state 37
    withtype                       shift and go to state 42

state 119

    (59) bracedexp -> LBRACE new_scope code . RBRACE

    RBRACE          shift and go to state 133


state 120

    (65) stringarray -> LSPAREN RSPAREN .

    SEMI_COLON      reduce using rule 65 (stringarray -> LSPAREN RSPAREN .)
    COMMA           reduce using rule 65 (stringarray -> LSPAREN RSPAREN .)
    $end            reduce using rule 65 (stringarray -> LSPAREN RSPAREN .)
    BINARY_FNC      reduce using rule 65 (stringarray -> LSPAREN RSPAREN .)
    LT              reduce using rule 65 (stringarray -> LSPAREN RSPAREN .)
    GT              reduce using rule 65 (stringarray -> LSPAREN RSPAREN .)
    LTE             reduce using rule 65 (stringarray -> LSPAREN RSPAREN .)
    GTE             reduce using rule 65 (stringarray -> LSPAREN RSPAREN .)
    EQUALITY        reduce using rule 65 (stringarray -> LSPAREN RSPAREN .)
    INEQUALITY      reduce using rule 65 (stringarray -> LSPAREN RSPAREN .)
    AND             reduce using rule 65 (stringarray -> LSPAREN RSPAREN .)
    OR              reduce using rule 65 (stringarray -> LSPAREN RSPAREN .)
    PLUS            reduce using rule 65 (stringarray -> LSPAREN RSPAREN .)
    MINUS           reduce using rule 65 (stringarray -> LSPAREN RSPAREN .)
    TIMES           reduce using rule 65 (stringarray -> LSPAREN RSPAREN .)
    DIVIDE          reduce using rule 65 (stringarray -> LSPAREN RSPAREN .)
    MOD             reduce using rule 65 (stringarray -> LSPAREN RSPAREN .)
    POW             reduce using rule 65 (stringarray -> LSPAREN RSPAREN .)
    RBRACE          reduce using rule 65 (stringarray -> LSPAREN RSPAREN .)
    RPAREN          reduce using rule 65 (stringarray -> LSPAREN RSPAREN .)
    RSPAREN         reduce using rule 65 (stringarray -> LSPAREN RSPAREN .)
    TO              reduce using rule 65 (stringarray -> LSPAREN RSPAREN .)
    STEP            reduce using rule 65 (stringarray -> LSPAREN RSPAREN .)
    DO              reduce using rule 65 (stringarray -> LSPAREN RSPAREN .)


state 121

    (66) stringarray -> LSPAREN stringarrayelement . RSPAREN

    RSPAREN         shift and go to state 134


state 122

    (67) stringarrayelement -> string .
    (68) stringarrayelement -> string . COMMA stringarrayelement

    RSPAREN         reduce using rule 67 (stringarrayelement -> string .)
    COMMA           shift and go to state 135


state 123

    (57) primaryexp -> LPAREN binaryexp RPAREN .

    BINARY_FNC      reduce using rule 57 (primaryexp -> LPAREN binaryexp RPAREN .)
    LT              reduce using rule 57 (primaryexp -> LPAREN binaryexp RPAREN .)
    GT              reduce using rule 57 (primaryexp -> LPAREN binaryexp RPAREN .)
    LTE             reduce using rule 57 (primaryexp -> LPAREN binaryexp RPAREN .)
    GTE             reduce using rule 57 (primaryexp -> LPAREN binaryexp RPAREN .)
    EQUALITY        reduce using rule 57 (primaryexp -> LPAREN binaryexp RPAREN .)
    INEQUALITY      reduce using rule 57 (primaryexp -> LPAREN binaryexp RPAREN .)
    AND             reduce using rule 57 (primaryexp -> LPAREN binaryexp RPAREN .)
    OR              reduce using rule 57 (primaryexp -> LPAREN binaryexp RPAREN .)
    PLUS            reduce using rule 57 (primaryexp -> LPAREN binaryexp RPAREN .)
    MINUS           reduce using rule 57 (primaryexp -> LPAREN binaryexp RPAREN .)
    TIMES           reduce using rule 57 (primaryexp -> LPAREN binaryexp RPAREN .)
    DIVIDE          reduce using rule 57 (primaryexp -> LPAREN binaryexp RPAREN .)
    MOD             reduce using rule 57 (primaryexp -> LPAREN binaryexp RPAREN .)
    POW             reduce using rule 57 (primaryexp -> LPAREN binaryexp RPAREN .)
    SEMI_COLON      reduce using rule 57 (primaryexp -> LPAREN binaryexp RPAREN .)
    COMMA           reduce using rule 57 (primaryexp -> LPAREN binaryexp RPAREN .)
    $end            reduce using rule 57 (primaryexp -> LPAREN binaryexp RPAREN .)
    RBRACE          reduce using rule 57 (primaryexp -> LPAREN binaryexp RPAREN .)
    RPAREN          reduce using rule 57 (primaryexp -> LPAREN binaryexp RPAREN .)
    RSPAREN         reduce using rule 57 (primaryexp -> LPAREN binaryexp RPAREN .)
    TO              reduce using rule 57 (primaryexp -> LPAREN binaryexp RPAREN .)
    STEP            reduce using rule 57 (primaryexp -> LPAREN binaryexp RPAREN .)
    DO              reduce using rule 57 (primaryexp -> LPAREN binaryexp RPAREN .)


state 124

    (19) iftype -> IF LPAREN booleanexp . RPAREN

    RPAREN          shift and go to state 136


state 125

    (90) booleanexp -> primaryexp .
    (91) booleanexp -> primaryexp . comparisonoperator booleanexp
    (92) booleanexp -> primaryexp . comparisonoperator LBRACE booleanexp RBRACE
    (46) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (47) binaryexp -> primaryexp . comparisonoperator primaryexp
    (48) binaryexp -> primaryexp . mathoperator primaryexp
    (76) comparisonoperator -> . LT
    (77) comparisonoperator -> . GT
    (78) comparisonoperator -> . LTE
    (79) comparisonoperator -> . GTE
    (80) comparisonoperator -> . EQUALITY
    (81) comparisonoperator -> . INEQUALITY
    (82) comparisonoperator -> . AND
    (83) comparisonoperator -> . OR
    (84) mathoperator -> . PLUS
    (85) mathoperator -> . MINUS
    (86) mathoperator -> . TIMES
    (87) mathoperator -> . DIVIDE
    (88) mathoperator -> . MOD
    (89) mathoperator -> . POW

    RPAREN          reduce using rule 90 (booleanexp -> primaryexp .)
    RBRACE          reduce using rule 90 (booleanexp -> primaryexp .)
    BINARY_FNC      shift and go to state 54
    LT              shift and go to state 57
    GT              shift and go to state 58
    LTE             shift and go to state 59
    GTE             shift and go to state 60
    EQUALITY        shift and go to state 61
    INEQUALITY      shift and go to state 62
    AND             shift and go to state 63
    OR              shift and go to state 64
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POW             shift and go to state 70

    comparisonoperator             shift and go to state 137
    mathoperator                   shift and go to state 56

state 126

    (26) whiletype -> WHILE LBRACE booleanexp . RBRACE

    RBRACE          shift and go to state 138


state 127

    (28) fortype -> FOR new_scope string . FROM primaryexp TO primaryexp
    (29) fortype -> FOR new_scope string . FROM primaryexp TO primaryexp STEP primaryexp

    FROM            shift and go to state 139


state 128

    (30) fortype -> FOR new_scope LSPAREN . bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (34) bracedexp_noscope -> . LBRACE code RBRACE

    LBRACE          shift and go to state 118

    bracedexp_noscope              shift and go to state 140

state 129

    (62) array -> LSPAREN arrayelement RSPAREN .

    BINARY_FNC      reduce using rule 62 (array -> LSPAREN arrayelement RSPAREN .)
    LT              reduce using rule 62 (array -> LSPAREN arrayelement RSPAREN .)
    GT              reduce using rule 62 (array -> LSPAREN arrayelement RSPAREN .)
    LTE             reduce using rule 62 (array -> LSPAREN arrayelement RSPAREN .)
    GTE             reduce using rule 62 (array -> LSPAREN arrayelement RSPAREN .)
    EQUALITY        reduce using rule 62 (array -> LSPAREN arrayelement RSPAREN .)
    INEQUALITY      reduce using rule 62 (array -> LSPAREN arrayelement RSPAREN .)
    AND             reduce using rule 62 (array -> LSPAREN arrayelement RSPAREN .)
    OR              reduce using rule 62 (array -> LSPAREN arrayelement RSPAREN .)
    PLUS            reduce using rule 62 (array -> LSPAREN arrayelement RSPAREN .)
    MINUS           reduce using rule 62 (array -> LSPAREN arrayelement RSPAREN .)
    TIMES           reduce using rule 62 (array -> LSPAREN arrayelement RSPAREN .)
    DIVIDE          reduce using rule 62 (array -> LSPAREN arrayelement RSPAREN .)
    MOD             reduce using rule 62 (array -> LSPAREN arrayelement RSPAREN .)
    POW             reduce using rule 62 (array -> LSPAREN arrayelement RSPAREN .)
    SEMI_COLON      reduce using rule 62 (array -> LSPAREN arrayelement RSPAREN .)
    COMMA           reduce using rule 62 (array -> LSPAREN arrayelement RSPAREN .)
    $end            reduce using rule 62 (array -> LSPAREN arrayelement RSPAREN .)
    RBRACE          reduce using rule 62 (array -> LSPAREN arrayelement RSPAREN .)
    RPAREN          reduce using rule 62 (array -> LSPAREN arrayelement RSPAREN .)
    RSPAREN         reduce using rule 62 (array -> LSPAREN arrayelement RSPAREN .)
    TO              reduce using rule 62 (array -> LSPAREN arrayelement RSPAREN .)
    STEP            reduce using rule 62 (array -> LSPAREN arrayelement RSPAREN .)
    DO              reduce using rule 62 (array -> LSPAREN arrayelement RSPAREN .)


state 130

    (64) arrayelement -> binaryexp COMMA . arrayelement
    (63) arrayelement -> . binaryexp
    (64) arrayelement -> . binaryexp COMMA arrayelement
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (40) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    PRIVATE_ID      shift and go to state 77
    GLOBAL_ID       shift and go to state 78
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 41
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    WITH            shift and go to state 48
    PRIVATE         shift and go to state 83

    binaryexp                      shift and go to state 102
    arrayelement                   shift and go to state 141
    primaryexp                     shift and go to state 15
    number                         shift and go to state 33
    identifier                     shift and go to state 73
    helpertype                     shift and go to state 34
    unaryexp                       shift and go to state 74
    nularexp                       shift and go to state 75
    string                         shift and go to state 35
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 79
    whiletype                      shift and go to state 80
    fortype                        shift and go to state 81
    withtype                       shift and go to state 82
    arraydefinition                shift and go to state 23

state 131

    (22) ifstatement -> iftype THEN bracedexp ELSE . bracedexp
    (59) bracedexp -> . LBRACE new_scope code RBRACE

    LBRACE          shift and go to state 29

    bracedexp                      shift and go to state 142

state 132

    (34) bracedexp_noscope -> LBRACE code . RBRACE

    RBRACE          shift and go to state 143


state 133

    (59) bracedexp -> LBRACE new_scope code RBRACE .

    BINARY_FNC      reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)
    LT              reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)
    GT              reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)
    LTE             reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)
    GTE             reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)
    EQUALITY        reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)
    INEQUALITY      reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)
    AND             reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)
    OR              reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)
    PLUS            reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)
    MINUS           reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)
    TIMES           reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)
    DIVIDE          reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)
    MOD             reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)
    POW             reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)
    SEMI_COLON      reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)
    COMMA           reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)
    $end            reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)
    RBRACE          reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)
    RPAREN          reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)
    RSPAREN         reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)
    TO              reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)
    STEP            reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)
    DO              reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)
    ELSE            reduce using rule 59 (bracedexp -> LBRACE new_scope code RBRACE .)


state 134

    (66) stringarray -> LSPAREN stringarrayelement RSPAREN .

    SEMI_COLON      reduce using rule 66 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    COMMA           reduce using rule 66 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    $end            reduce using rule 66 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    BINARY_FNC      reduce using rule 66 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    LT              reduce using rule 66 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    GT              reduce using rule 66 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    LTE             reduce using rule 66 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    GTE             reduce using rule 66 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    EQUALITY        reduce using rule 66 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    INEQUALITY      reduce using rule 66 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    AND             reduce using rule 66 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    OR              reduce using rule 66 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    PLUS            reduce using rule 66 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    MINUS           reduce using rule 66 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    TIMES           reduce using rule 66 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    DIVIDE          reduce using rule 66 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    MOD             reduce using rule 66 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    POW             reduce using rule 66 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    RBRACE          reduce using rule 66 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    RPAREN          reduce using rule 66 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    RSPAREN         reduce using rule 66 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    TO              reduce using rule 66 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    STEP            reduce using rule 66 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    DO              reduce using rule 66 (stringarray -> LSPAREN stringarrayelement RSPAREN .)


state 135

    (68) stringarrayelement -> string COMMA . stringarrayelement
    (67) stringarrayelement -> . string
    (68) stringarrayelement -> . string COMMA stringarrayelement
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE

    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47

    string                         shift and go to state 122
    stringarrayelement             shift and go to state 144

state 136

    (19) iftype -> IF LPAREN booleanexp RPAREN .

    THEN            reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    EXITWITH        reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    BINARY_FNC      reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    LT              reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    GT              reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    LTE             reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    GTE             reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    EQUALITY        reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    INEQUALITY      reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    AND             reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    OR              reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    PLUS            reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    MINUS           reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    TIMES           reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    DIVIDE          reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    MOD             reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    POW             reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    SEMI_COLON      reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    COMMA           reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    $end            reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    RBRACE          reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    RPAREN          reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    RSPAREN         reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    TO              reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    STEP            reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)
    DO              reduce using rule 19 (iftype -> IF LPAREN booleanexp RPAREN .)


state 137

    (91) booleanexp -> primaryexp comparisonoperator . booleanexp
    (92) booleanexp -> primaryexp comparisonoperator . LBRACE booleanexp RBRACE
    (47) binaryexp -> primaryexp comparisonoperator . primaryexp
    (90) booleanexp -> . primaryexp
    (91) booleanexp -> . primaryexp comparisonoperator booleanexp
    (92) booleanexp -> . primaryexp comparisonoperator LBRACE booleanexp RBRACE
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (40) arraydefinition -> . PRIVATE stringarray

    LBRACE          shift and go to state 147
    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    PRIVATE_ID      shift and go to state 77
    GLOBAL_ID       shift and go to state 78
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LSPAREN         shift and go to state 41
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    WITH            shift and go to state 48
    PRIVATE         shift and go to state 83

    primaryexp                     shift and go to state 145
    booleanexp                     shift and go to state 146
    number                         shift and go to state 33
    identifier                     shift and go to state 73
    helpertype                     shift and go to state 34
    unaryexp                       shift and go to state 74
    nularexp                       shift and go to state 75
    string                         shift and go to state 35
    binaryexp                      shift and go to state 76
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 79
    whiletype                      shift and go to state 80
    fortype                        shift and go to state 81
    withtype                       shift and go to state 82
    arraydefinition                shift and go to state 23

state 138

    (26) whiletype -> WHILE LBRACE booleanexp RBRACE .

    DO              reduce using rule 26 (whiletype -> WHILE LBRACE booleanexp RBRACE .)
    BINARY_FNC      reduce using rule 26 (whiletype -> WHILE LBRACE booleanexp RBRACE .)
    LT              reduce using rule 26 (whiletype -> WHILE LBRACE booleanexp RBRACE .)
    GT              reduce using rule 26 (whiletype -> WHILE LBRACE booleanexp RBRACE .)
    LTE             reduce using rule 26 (whiletype -> WHILE LBRACE booleanexp RBRACE .)
    GTE             reduce using rule 26 (whiletype -> WHILE LBRACE booleanexp RBRACE .)
    EQUALITY        reduce using rule 26 (whiletype -> WHILE LBRACE booleanexp RBRACE .)
    INEQUALITY      reduce using rule 26 (whiletype -> WHILE LBRACE booleanexp RBRACE .)
    AND             reduce using rule 26 (whiletype -> WHILE LBRACE booleanexp RBRACE .)
    OR              reduce using rule 26 (whiletype -> WHILE LBRACE booleanexp RBRACE .)
    PLUS            reduce using rule 26 (whiletype -> WHILE LBRACE booleanexp RBRACE .)
    MINUS           reduce using rule 26 (whiletype -> WHILE LBRACE booleanexp RBRACE .)
    TIMES           reduce using rule 26 (whiletype -> WHILE LBRACE booleanexp RBRACE .)
    DIVIDE          reduce using rule 26 (whiletype -> WHILE LBRACE booleanexp RBRACE .)
    MOD             reduce using rule 26 (whiletype -> WHILE LBRACE booleanexp RBRACE .)
    POW             reduce using rule 26 (whiletype -> WHILE LBRACE booleanexp RBRACE .)
    SEMI_COLON      reduce using rule 26 (whiletype -> WHILE LBRACE booleanexp RBRACE .)
    COMMA           reduce using rule 26 (whiletype -> WHILE LBRACE booleanexp RBRACE .)
    $end            reduce using rule 26 (whiletype -> WHILE LBRACE booleanexp RBRACE .)
    RBRACE          reduce using rule 26 (whiletype -> WHILE LBRACE booleanexp RBRACE .)
    RPAREN          reduce using rule 26 (whiletype -> WHILE LBRACE booleanexp RBRACE .)
    RSPAREN         reduce using rule 26 (whiletype -> WHILE LBRACE booleanexp RBRACE .)
    TO              reduce using rule 26 (whiletype -> WHILE LBRACE booleanexp RBRACE .)
    STEP            reduce using rule 26 (whiletype -> WHILE LBRACE booleanexp RBRACE .)


state 139

    (28) fortype -> FOR new_scope string FROM . primaryexp TO primaryexp
    (29) fortype -> FOR new_scope string FROM . primaryexp TO primaryexp STEP primaryexp
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (40) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    PRIVATE_ID      shift and go to state 77
    GLOBAL_ID       shift and go to state 78
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 41
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    WITH            shift and go to state 48
    PRIVATE         shift and go to state 83

    string                         shift and go to state 35
    primaryexp                     shift and go to state 148
    number                         shift and go to state 33
    identifier                     shift and go to state 73
    helpertype                     shift and go to state 34
    unaryexp                       shift and go to state 74
    nularexp                       shift and go to state 75
    binaryexp                      shift and go to state 76
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 79
    whiletype                      shift and go to state 80
    fortype                        shift and go to state 81
    withtype                       shift and go to state 82
    arraydefinition                shift and go to state 23

state 140

    (30) fortype -> FOR new_scope LSPAREN bracedexp_noscope . COMMA forloop_condition COMMA bracedexp_noscope RSPAREN

    COMMA           shift and go to state 149


state 141

    (64) arrayelement -> binaryexp COMMA arrayelement .

    RSPAREN         reduce using rule 64 (arrayelement -> binaryexp COMMA arrayelement .)


state 142

    (22) ifstatement -> iftype THEN bracedexp ELSE bracedexp .

    SEMI_COLON      reduce using rule 22 (ifstatement -> iftype THEN bracedexp ELSE bracedexp .)
    COMMA           reduce using rule 22 (ifstatement -> iftype THEN bracedexp ELSE bracedexp .)
    $end            reduce using rule 22 (ifstatement -> iftype THEN bracedexp ELSE bracedexp .)
    RBRACE          reduce using rule 22 (ifstatement -> iftype THEN bracedexp ELSE bracedexp .)


state 143

    (34) bracedexp_noscope -> LBRACE code RBRACE .

    SEMI_COLON      reduce using rule 34 (bracedexp_noscope -> LBRACE code RBRACE .)
    COMMA           reduce using rule 34 (bracedexp_noscope -> LBRACE code RBRACE .)
    $end            reduce using rule 34 (bracedexp_noscope -> LBRACE code RBRACE .)
    RBRACE          reduce using rule 34 (bracedexp_noscope -> LBRACE code RBRACE .)
    RSPAREN         reduce using rule 34 (bracedexp_noscope -> LBRACE code RBRACE .)


state 144

    (68) stringarrayelement -> string COMMA stringarrayelement .

    RSPAREN         reduce using rule 68 (stringarrayelement -> string COMMA stringarrayelement .)


state 145

    (47) binaryexp -> primaryexp comparisonoperator primaryexp .
    (90) booleanexp -> primaryexp .
    (91) booleanexp -> primaryexp . comparisonoperator booleanexp
    (92) booleanexp -> primaryexp . comparisonoperator LBRACE booleanexp RBRACE
    (46) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (47) binaryexp -> primaryexp . comparisonoperator primaryexp
    (48) binaryexp -> primaryexp . mathoperator primaryexp
    (76) comparisonoperator -> . LT
    (77) comparisonoperator -> . GT
    (78) comparisonoperator -> . LTE
    (79) comparisonoperator -> . GTE
    (80) comparisonoperator -> . EQUALITY
    (81) comparisonoperator -> . INEQUALITY
    (82) comparisonoperator -> . AND
    (83) comparisonoperator -> . OR
    (84) mathoperator -> . PLUS
    (85) mathoperator -> . MINUS
    (86) mathoperator -> . TIMES
    (87) mathoperator -> . DIVIDE
    (88) mathoperator -> . MOD
    (89) mathoperator -> . POW

  ! reduce/reduce conflict for RPAREN resolved using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
  ! reduce/reduce conflict for RBRACE resolved using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    BINARY_FNC      reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    LT              reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    GT              reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    LTE             reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    GTE             reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    EQUALITY        reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    INEQUALITY      reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    AND             reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    OR              reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    RPAREN          reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    RBRACE          reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POW             shift and go to state 70

  ! PLUS            [ reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! MINUS           [ reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! TIMES           [ reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! DIVIDE          [ reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! MOD             [ reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! POW             [ reduce using rule 47 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! RPAREN          [ reduce using rule 90 (booleanexp -> primaryexp .) ]
  ! RBRACE          [ reduce using rule 90 (booleanexp -> primaryexp .) ]
  ! BINARY_FNC      [ shift and go to state 54 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! LTE             [ shift and go to state 59 ]
  ! GTE             [ shift and go to state 60 ]
  ! EQUALITY        [ shift and go to state 61 ]
  ! INEQUALITY      [ shift and go to state 62 ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 64 ]

    comparisonoperator             shift and go to state 137
    mathoperator                   shift and go to state 56

state 146

    (91) booleanexp -> primaryexp comparisonoperator booleanexp .

    RPAREN          reduce using rule 91 (booleanexp -> primaryexp comparisonoperator booleanexp .)
    RBRACE          reduce using rule 91 (booleanexp -> primaryexp comparisonoperator booleanexp .)


state 147

    (92) booleanexp -> primaryexp comparisonoperator LBRACE . booleanexp RBRACE
    (59) bracedexp -> LBRACE . new_scope code RBRACE
    (90) booleanexp -> . primaryexp
    (91) booleanexp -> . primaryexp comparisonoperator booleanexp
    (92) booleanexp -> . primaryexp comparisonoperator LBRACE booleanexp RBRACE
    (60) new_scope -> .
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (40) arraydefinition -> . PRIVATE stringarray

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NUMBER_REAL resolved as shift
  ! shift/reduce conflict for NUMBER_EXP resolved as shift
  ! shift/reduce conflict for NUMBER_HEX resolved as shift
  ! shift/reduce conflict for PRIVATE_ID resolved as shift
  ! shift/reduce conflict for GLOBAL_ID resolved as shift
  ! shift/reduce conflict for UNARY_FNC resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULAR_FNC resolved as shift
  ! shift/reduce conflict for STRING_SINGLE resolved as shift
  ! shift/reduce conflict for STRING_DOUBLE resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for LSPAREN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WITH resolved as shift
  ! shift/reduce conflict for PRIVATE resolved as shift
    RBRACE          reduce using rule 60 (new_scope -> .)
    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    PRIVATE_ID      shift and go to state 77
    GLOBAL_ID       shift and go to state 78
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 41
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    WITH            shift and go to state 48
    PRIVATE         shift and go to state 83

  ! NULAR_FNC       [ reduce using rule 60 (new_scope -> .) ]
  ! UNARY_FNC       [ reduce using rule 60 (new_scope -> .) ]
  ! PLUS            [ reduce using rule 60 (new_scope -> .) ]
  ! MINUS           [ reduce using rule 60 (new_scope -> .) ]
  ! NOT             [ reduce using rule 60 (new_scope -> .) ]
  ! PRIVATE         [ reduce using rule 60 (new_scope -> .) ]
  ! PRIVATE_ID      [ reduce using rule 60 (new_scope -> .) ]
  ! GLOBAL_ID       [ reduce using rule 60 (new_scope -> .) ]
  ! LPAREN          [ reduce using rule 60 (new_scope -> .) ]
  ! IF              [ reduce using rule 60 (new_scope -> .) ]
  ! WHILE           [ reduce using rule 60 (new_scope -> .) ]
  ! FOR             [ reduce using rule 60 (new_scope -> .) ]
  ! NUMBER_REAL     [ reduce using rule 60 (new_scope -> .) ]
  ! NUMBER_EXP      [ reduce using rule 60 (new_scope -> .) ]
  ! NUMBER_HEX      [ reduce using rule 60 (new_scope -> .) ]
  ! STRING_SINGLE   [ reduce using rule 60 (new_scope -> .) ]
  ! STRING_DOUBLE   [ reduce using rule 60 (new_scope -> .) ]
  ! LBRACE          [ reduce using rule 60 (new_scope -> .) ]
  ! LSPAREN         [ reduce using rule 60 (new_scope -> .) ]
  ! WITH            [ reduce using rule 60 (new_scope -> .) ]

    primaryexp                     shift and go to state 125
    booleanexp                     shift and go to state 150
    new_scope                      shift and go to state 92
    number                         shift and go to state 33
    identifier                     shift and go to state 73
    helpertype                     shift and go to state 34
    unaryexp                       shift and go to state 74
    nularexp                       shift and go to state 75
    string                         shift and go to state 35
    binaryexp                      shift and go to state 76
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 79
    whiletype                      shift and go to state 80
    fortype                        shift and go to state 81
    withtype                       shift and go to state 82
    arraydefinition                shift and go to state 23

state 148

    (28) fortype -> FOR new_scope string FROM primaryexp . TO primaryexp
    (29) fortype -> FOR new_scope string FROM primaryexp . TO primaryexp STEP primaryexp
    (46) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (47) binaryexp -> primaryexp . comparisonoperator primaryexp
    (48) binaryexp -> primaryexp . mathoperator primaryexp
    (76) comparisonoperator -> . LT
    (77) comparisonoperator -> . GT
    (78) comparisonoperator -> . LTE
    (79) comparisonoperator -> . GTE
    (80) comparisonoperator -> . EQUALITY
    (81) comparisonoperator -> . INEQUALITY
    (82) comparisonoperator -> . AND
    (83) comparisonoperator -> . OR
    (84) mathoperator -> . PLUS
    (85) mathoperator -> . MINUS
    (86) mathoperator -> . TIMES
    (87) mathoperator -> . DIVIDE
    (88) mathoperator -> . MOD
    (89) mathoperator -> . POW

    TO              shift and go to state 151
    BINARY_FNC      shift and go to state 54
    LT              shift and go to state 57
    GT              shift and go to state 58
    LTE             shift and go to state 59
    GTE             shift and go to state 60
    EQUALITY        shift and go to state 61
    INEQUALITY      shift and go to state 62
    AND             shift and go to state 63
    OR              shift and go to state 64
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POW             shift and go to state 70

    comparisonoperator             shift and go to state 55
    mathoperator                   shift and go to state 56

state 149

    (30) fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA . forloop_condition COMMA bracedexp_noscope RSPAREN
    (32) forloop_condition -> . LBRACE booleanexp RBRACE
    (33) forloop_condition -> . identifier
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID

    LBRACE          shift and go to state 153
    PRIVATE_ID      shift and go to state 77
    GLOBAL_ID       shift and go to state 78

    forloop_condition              shift and go to state 152
    identifier                     shift and go to state 154

state 150

    (92) booleanexp -> primaryexp comparisonoperator LBRACE booleanexp . RBRACE

    RBRACE          shift and go to state 155


state 151

    (28) fortype -> FOR new_scope string FROM primaryexp TO . primaryexp
    (29) fortype -> FOR new_scope string FROM primaryexp TO . primaryexp STEP primaryexp
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (40) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    PRIVATE_ID      shift and go to state 77
    GLOBAL_ID       shift and go to state 78
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 41
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    WITH            shift and go to state 48
    PRIVATE         shift and go to state 83

    string                         shift and go to state 35
    primaryexp                     shift and go to state 156
    number                         shift and go to state 33
    identifier                     shift and go to state 73
    helpertype                     shift and go to state 34
    unaryexp                       shift and go to state 74
    nularexp                       shift and go to state 75
    binaryexp                      shift and go to state 76
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 79
    whiletype                      shift and go to state 80
    fortype                        shift and go to state 81
    withtype                       shift and go to state 82
    arraydefinition                shift and go to state 23

state 152

    (30) fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition . COMMA bracedexp_noscope RSPAREN

    COMMA           shift and go to state 157


state 153

    (32) forloop_condition -> LBRACE . booleanexp RBRACE
    (90) booleanexp -> . primaryexp
    (91) booleanexp -> . primaryexp comparisonoperator booleanexp
    (92) booleanexp -> . primaryexp comparisonoperator LBRACE booleanexp RBRACE
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (40) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    PRIVATE_ID      shift and go to state 77
    GLOBAL_ID       shift and go to state 78
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 41
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    WITH            shift and go to state 48
    PRIVATE         shift and go to state 83

    booleanexp                     shift and go to state 158
    primaryexp                     shift and go to state 125
    number                         shift and go to state 33
    identifier                     shift and go to state 73
    helpertype                     shift and go to state 34
    unaryexp                       shift and go to state 74
    nularexp                       shift and go to state 75
    string                         shift and go to state 35
    binaryexp                      shift and go to state 76
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 79
    whiletype                      shift and go to state 80
    fortype                        shift and go to state 81
    withtype                       shift and go to state 82
    arraydefinition                shift and go to state 23

state 154

    (33) forloop_condition -> identifier .

    COMMA           reduce using rule 33 (forloop_condition -> identifier .)


state 155

    (92) booleanexp -> primaryexp comparisonoperator LBRACE booleanexp RBRACE .

    RPAREN          reduce using rule 92 (booleanexp -> primaryexp comparisonoperator LBRACE booleanexp RBRACE .)
    RBRACE          reduce using rule 92 (booleanexp -> primaryexp comparisonoperator LBRACE booleanexp RBRACE .)


state 156

    (28) fortype -> FOR new_scope string FROM primaryexp TO primaryexp .
    (29) fortype -> FOR new_scope string FROM primaryexp TO primaryexp . STEP primaryexp
    (46) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (47) binaryexp -> primaryexp . comparisonoperator primaryexp
    (48) binaryexp -> primaryexp . mathoperator primaryexp
    (76) comparisonoperator -> . LT
    (77) comparisonoperator -> . GT
    (78) comparisonoperator -> . LTE
    (79) comparisonoperator -> . GTE
    (80) comparisonoperator -> . EQUALITY
    (81) comparisonoperator -> . INEQUALITY
    (82) comparisonoperator -> . AND
    (83) comparisonoperator -> . OR
    (84) mathoperator -> . PLUS
    (85) mathoperator -> . MINUS
    (86) mathoperator -> . TIMES
    (87) mathoperator -> . DIVIDE
    (88) mathoperator -> . MOD
    (89) mathoperator -> . POW

  ! shift/reduce conflict for STEP resolved as shift
  ! shift/reduce conflict for BINARY_FNC resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for EQUALITY resolved as shift
  ! shift/reduce conflict for INEQUALITY resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    DO              reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    SEMI_COLON      reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    COMMA           reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    $end            reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    RBRACE          reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    RPAREN          reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    RSPAREN         reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    TO              reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    STEP            shift and go to state 159
    BINARY_FNC      shift and go to state 54
    LT              shift and go to state 57
    GT              shift and go to state 58
    LTE             shift and go to state 59
    GTE             shift and go to state 60
    EQUALITY        shift and go to state 61
    INEQUALITY      shift and go to state 62
    AND             shift and go to state 63
    OR              shift and go to state 64
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POW             shift and go to state 70

  ! BINARY_FNC      [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! LT              [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! GT              [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! LTE             [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! GTE             [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! EQUALITY        [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! INEQUALITY      [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! AND             [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! OR              [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! PLUS            [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! MINUS           [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! TIMES           [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! DIVIDE          [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! MOD             [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! POW             [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! STEP            [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]

    comparisonoperator             shift and go to state 55
    mathoperator                   shift and go to state 56

state 157

    (30) fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA . bracedexp_noscope RSPAREN
    (34) bracedexp_noscope -> . LBRACE code RBRACE

    LBRACE          shift and go to state 118

    bracedexp_noscope              shift and go to state 160

state 158

    (32) forloop_condition -> LBRACE booleanexp . RBRACE

    RBRACE          shift and go to state 161


state 159

    (29) fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP . primaryexp
    (49) primaryexp -> . number
    (50) primaryexp -> . identifier
    (51) primaryexp -> . helpertype
    (52) primaryexp -> . unaryexp
    (53) primaryexp -> . nularexp
    (54) primaryexp -> . string
    (55) primaryexp -> . binaryexp
    (56) primaryexp -> . bracedexp
    (57) primaryexp -> . LPAREN binaryexp RPAREN
    (58) primaryexp -> . array
    (95) number -> . NUMBER_REAL
    (96) number -> . NUMBER_EXP
    (97) number -> . NUMBER_HEX
    (42) identifier -> . PRIVATE_ID
    (43) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (71) unaryexp -> . UNARY_FNC primaryexp
    (72) unaryexp -> . PLUS primaryexp
    (73) unaryexp -> . MINUS primaryexp
    (74) unaryexp -> . NOT primaryexp
    (75) unaryexp -> . arraydefinition
    (69) nularexp -> . NULAR_FNC
    (70) nularexp -> . identifier
    (98) string -> . STRING_SINGLE
    (99) string -> . STRING_DOUBLE
    (46) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (47) binaryexp -> . primaryexp comparisonoperator primaryexp
    (48) binaryexp -> . primaryexp mathoperator primaryexp
    (59) bracedexp -> . LBRACE new_scope code RBRACE
    (61) array -> . LSPAREN RSPAREN
    (62) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF LPAREN booleanexp RPAREN
    (26) whiletype -> . WHILE LBRACE booleanexp RBRACE
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (40) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 43
    NUMBER_EXP      shift and go to state 44
    NUMBER_HEX      shift and go to state 45
    PRIVATE_ID      shift and go to state 77
    GLOBAL_ID       shift and go to state 78
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 46
    STRING_DOUBLE   shift and go to state 47
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 41
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    FOR             shift and go to state 40
    WITH            shift and go to state 48
    PRIVATE         shift and go to state 83

    string                         shift and go to state 35
    primaryexp                     shift and go to state 162
    number                         shift and go to state 33
    identifier                     shift and go to state 73
    helpertype                     shift and go to state 34
    unaryexp                       shift and go to state 74
    nularexp                       shift and go to state 75
    binaryexp                      shift and go to state 76
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 79
    whiletype                      shift and go to state 80
    fortype                        shift and go to state 81
    withtype                       shift and go to state 82
    arraydefinition                shift and go to state 23

state 160

    (30) fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope . RSPAREN

    RSPAREN         shift and go to state 163


state 161

    (32) forloop_condition -> LBRACE booleanexp RBRACE .

    COMMA           reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)


state 162

    (29) fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .
    (46) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (47) binaryexp -> primaryexp . comparisonoperator primaryexp
    (48) binaryexp -> primaryexp . mathoperator primaryexp
    (76) comparisonoperator -> . LT
    (77) comparisonoperator -> . GT
    (78) comparisonoperator -> . LTE
    (79) comparisonoperator -> . GTE
    (80) comparisonoperator -> . EQUALITY
    (81) comparisonoperator -> . INEQUALITY
    (82) comparisonoperator -> . AND
    (83) comparisonoperator -> . OR
    (84) mathoperator -> . PLUS
    (85) mathoperator -> . MINUS
    (86) mathoperator -> . TIMES
    (87) mathoperator -> . DIVIDE
    (88) mathoperator -> . MOD
    (89) mathoperator -> . POW

  ! shift/reduce conflict for BINARY_FNC resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for EQUALITY resolved as shift
  ! shift/reduce conflict for INEQUALITY resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    DO              reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    SEMI_COLON      reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    COMMA           reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    $end            reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    RBRACE          reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    RPAREN          reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    RSPAREN         reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    TO              reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    STEP            reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    BINARY_FNC      shift and go to state 54
    LT              shift and go to state 57
    GT              shift and go to state 58
    LTE             shift and go to state 59
    GTE             shift and go to state 60
    EQUALITY        shift and go to state 61
    INEQUALITY      shift and go to state 62
    AND             shift and go to state 63
    OR              shift and go to state 64
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POW             shift and go to state 70

  ! BINARY_FNC      [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! LT              [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! GT              [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! LTE             [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! GTE             [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! EQUALITY        [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! INEQUALITY      [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! AND             [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! OR              [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! PLUS            [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! MINUS           [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! TIMES           [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! DIVIDE          [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! MOD             [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! POW             [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]

    comparisonoperator             shift and go to state 55
    mathoperator                   shift and go to state 56

state 163

    (30) fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .

    DO              reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    BINARY_FNC      reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    LT              reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    GT              reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    LTE             reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    GTE             reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    EQUALITY        reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    INEQUALITY      reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    AND             reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    OR              reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    PLUS            reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    MINUS           reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    TIMES           reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    DIVIDE          reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    MOD             reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    POW             reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    SEMI_COLON      reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    COMMA           reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    $end            reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    RBRACE          reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    RPAREN          reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    RSPAREN         reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    TO              reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    STEP            reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPAREN in state 147 resolved as shift
WARNING: shift/reduce conflict for NUMBER_REAL in state 147 resolved as shift
WARNING: shift/reduce conflict for NUMBER_EXP in state 147 resolved as shift
WARNING: shift/reduce conflict for NUMBER_HEX in state 147 resolved as shift
WARNING: shift/reduce conflict for PRIVATE_ID in state 147 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_ID in state 147 resolved as shift
WARNING: shift/reduce conflict for UNARY_FNC in state 147 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 147 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 147 resolved as shift
WARNING: shift/reduce conflict for NOT in state 147 resolved as shift
WARNING: shift/reduce conflict for NULAR_FNC in state 147 resolved as shift
WARNING: shift/reduce conflict for STRING_SINGLE in state 147 resolved as shift
WARNING: shift/reduce conflict for STRING_DOUBLE in state 147 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 147 resolved as shift
WARNING: shift/reduce conflict for LSPAREN in state 147 resolved as shift
WARNING: shift/reduce conflict for IF in state 147 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 147 resolved as shift
WARNING: shift/reduce conflict for FOR in state 147 resolved as shift
WARNING: shift/reduce conflict for WITH in state 147 resolved as shift
WARNING: shift/reduce conflict for PRIVATE in state 147 resolved as shift
WARNING: shift/reduce conflict for STEP in state 156 resolved as shift
WARNING: shift/reduce conflict for BINARY_FNC in state 156 resolved as shift
WARNING: shift/reduce conflict for LT in state 156 resolved as shift
WARNING: shift/reduce conflict for GT in state 156 resolved as shift
WARNING: shift/reduce conflict for LTE in state 156 resolved as shift
WARNING: shift/reduce conflict for GTE in state 156 resolved as shift
WARNING: shift/reduce conflict for EQUALITY in state 156 resolved as shift
WARNING: shift/reduce conflict for INEQUALITY in state 156 resolved as shift
WARNING: shift/reduce conflict for AND in state 156 resolved as shift
WARNING: shift/reduce conflict for OR in state 156 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 156 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 156 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 156 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 156 resolved as shift
WARNING: shift/reduce conflict for MOD in state 156 resolved as shift
WARNING: shift/reduce conflict for POW in state 156 resolved as shift
WARNING: shift/reduce conflict for BINARY_FNC in state 162 resolved as shift
WARNING: shift/reduce conflict for LT in state 162 resolved as shift
WARNING: shift/reduce conflict for GT in state 162 resolved as shift
WARNING: shift/reduce conflict for LTE in state 162 resolved as shift
WARNING: shift/reduce conflict for GTE in state 162 resolved as shift
WARNING: shift/reduce conflict for EQUALITY in state 162 resolved as shift
WARNING: shift/reduce conflict for INEQUALITY in state 162 resolved as shift
WARNING: shift/reduce conflict for AND in state 162 resolved as shift
WARNING: shift/reduce conflict for OR in state 162 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 162 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 162 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 162 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 162 resolved as shift
WARNING: shift/reduce conflict for MOD in state 162 resolved as shift
WARNING: shift/reduce conflict for POW in state 162 resolved as shift
WARNING: reduce/reduce conflict in state 18 resolved using rule (primaryexp -> identifier)
WARNING: rejected rule (nularexp -> identifier) in state 18
WARNING: reduce/reduce conflict in state 73 resolved using rule (primaryexp -> identifier)
WARNING: rejected rule (nularexp -> identifier) in state 73
WARNING: reduce/reduce conflict in state 108 resolved using rule (assignment_code -> definition EQUAL LBRACE)
WARNING: rejected rule (new_scope -> <empty>) in state 108
WARNING: reduce/reduce conflict in state 113 resolved using rule (assignment_code -> variable EQUAL LBRACE)
WARNING: rejected rule (new_scope -> <empty>) in state 113
WARNING: reduce/reduce conflict in state 145 resolved using rule (binaryexp -> primaryexp comparisonoperator primaryexp)
WARNING: rejected rule (booleanexp -> primaryexp) in state 145
