Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOL
    COMMENT_MULTI
    COMMENT_SINGLE
    NEWLINE

Grammar

Rule 0     S' -> code
Rule 1     code -> empty
Rule 2     code -> statement
Rule 3     code -> statement terminator code
Rule 4     statement -> controlstructure
Rule 5     statement -> assignment
Rule 6     statement -> binaryexp
Rule 7     statement -> nularexp
Rule 8     statement -> unaryexp
Rule 9     terminator -> SEMI_COLON
Rule 10    terminator -> COMMA
Rule 11    controlstructure -> ifstatement
Rule 12    controlstructure -> whileloop
Rule 13    controlstructure -> forloop
Rule 14    controlstructure -> withstatement
Rule 15    controlstructure -> foreachloop
Rule 16    controlstructure -> switchstatement
Rule 17    helpertype -> iftype
Rule 18    helpertype -> whiletype
Rule 19    helpertype -> fortype
Rule 20    helpertype -> withtype
Rule 21    case -> CASE primaryexp COLON bracedexp
Rule 22    case -> CASE primaryexp
Rule 23    case -> DEFAULT bracedexp
Rule 24    switchstatement -> SWITCH LPAREN primaryexp RPAREN DO LBRACE switchbody RBRACE
Rule 25    switchbody -> empty
Rule 26    switchbody -> case
Rule 27    switchbody -> case terminator switchbody
Rule 28    iftype -> IF forloop_condition
Rule 29    ifstatement -> iftype THEN bracedexp
Rule 30    ifstatement -> iftype EXITWITH bracedexp
Rule 31    ifstatement -> iftype THEN bracedexp ELSE bracedexp
Rule 32    withtype -> WITH NAMESPACE
Rule 33    withstatementinit -> withtype DO
Rule 34    withstatement -> withstatementinit bracedexp
Rule 35    whiletype -> WHILE forloop_condition
Rule 36    whileloop -> whiletype DO bracedexp
Rule 37    foreachloop -> bracedexp FOREACH array
Rule 38    foreachloop -> bracedexp FOREACH primaryexp
Rule 39    fortype -> FOR new_scope string FROM primaryexp TO primaryexp
Rule 40    fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
Rule 41    fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
Rule 42    forloop -> fortype DO bracedexp_noscope
Rule 43    forloop_condition -> LBRACE booleanexp RBRACE
Rule 44    forloop_condition -> identifier
Rule 45    bracedexp_noscope -> LBRACE code RBRACE
Rule 46    vardefinition -> definition
Rule 47    vardefinition -> arraydefinition
Rule 48    assignment -> assignment_code code RBRACE
Rule 49    assignment -> definition EQUAL primaryexp
Rule 50    assignment -> variable EQUAL primaryexp
Rule 51    assignment_code -> definition EQUAL LBRACE
Rule 52    assignment_code -> variable EQUAL LBRACE
Rule 53    arraydefinition -> PRIVATE stringarray
Rule 54    definition -> PRIVATE PRIVATE_ID
Rule 55    definition -> PRIVATE string
Rule 56    identifier -> PRIVATE_ID
Rule 57    identifier -> GLOBAL_ID
Rule 58    variable -> PRIVATE_ID
Rule 59    variable -> GLOBAL_ID
Rule 60    binaryexp -> primaryexp BINARY_FNC primaryexp
Rule 61    binaryexp -> primaryexp comparisonoperator primaryexp
Rule 62    binaryexp -> primaryexp mathoperator primaryexp
Rule 63    primaryexp -> number
Rule 64    primaryexp -> identifier
Rule 65    primaryexp -> helpertype
Rule 66    primaryexp -> array
Rule 67    primaryexp -> unaryexp
Rule 68    primaryexp -> nularexp
Rule 69    primaryexp -> string
Rule 70    primaryexp -> binaryexp
Rule 71    primaryexp -> bracedexp
Rule 72    primaryexp -> LPAREN binaryexp RPAREN
Rule 73    bracedexp -> LBRACE new_scope code RBRACE
Rule 74    new_scope -> <empty>
Rule 75    array -> LSPAREN RSPAREN
Rule 76    array -> LSPAREN arrayelement RSPAREN
Rule 77    arrayelement -> primaryexp
Rule 78    arrayelement -> primaryexp COMMA arrayelement
Rule 79    stringarray -> LSPAREN RSPAREN
Rule 80    stringarray -> LSPAREN stringarrayelement RSPAREN
Rule 81    stringarrayelement -> string
Rule 82    stringarrayelement -> string COMMA stringarrayelement
Rule 83    nularexp -> NULAR_FNC
Rule 84    nularexp -> identifier
Rule 85    unaryexp -> UNARY_FNC primaryexp
Rule 86    unaryexp -> PLUS primaryexp
Rule 87    unaryexp -> MINUS primaryexp
Rule 88    unaryexp -> NOT primaryexp
Rule 89    unaryexp -> vardefinition
Rule 90    comparisonoperator -> LT
Rule 91    comparisonoperator -> GT
Rule 92    comparisonoperator -> LTE
Rule 93    comparisonoperator -> GTE
Rule 94    comparisonoperator -> EQUALITY
Rule 95    comparisonoperator -> INEQUALITY
Rule 96    comparisonoperator -> AND
Rule 97    comparisonoperator -> OR
Rule 98    mathoperator -> PLUS
Rule 99    mathoperator -> MINUS
Rule 100   mathoperator -> TIMES
Rule 101   mathoperator -> DIVIDE
Rule 102   mathoperator -> MOD
Rule 103   mathoperator -> POW
Rule 104   booleanexp -> primaryexp
Rule 105   booleanexp -> primaryexp comparisonoperator booleanexp
Rule 106   booleanexp -> primaryexp comparisonoperator LBRACE booleanexp RBRACE
Rule 107   configaccessor -> GT GT
Rule 108   configaccessor -> DIVIDE
Rule 109   number -> NUMBER_REAL
Rule 110   number -> NUMBER_EXP
Rule 111   number -> NUMBER_HEX
Rule 112   string -> STRING_SINGLE
Rule 113   string -> STRING_DOUBLE
Rule 114   empty -> <empty>

Terminals, with rules where they appear

AND                  : 96
BINARY_FNC           : 60
BOOL                 : 
CASE                 : 21 22
COLON                : 21
COMMA                : 10 41 41 78 82
COMMENT_MULTI        : 
COMMENT_SINGLE       : 
DEFAULT              : 23
DIVIDE               : 101 108
DO                   : 24 33 36 42
ELSE                 : 31
EQUAL                : 49 50 51 52
EQUALITY             : 94
EXITWITH             : 30
FOR                  : 39 40 41
FOREACH              : 37 38
FROM                 : 39 40
GLOBAL_ID            : 57 59
GT                   : 91 107 107
GTE                  : 93
IF                   : 28
INEQUALITY           : 95
LBRACE               : 24 43 45 51 52 73 106
LPAREN               : 24 72
LSPAREN              : 41 75 76 79 80
LT                   : 90
LTE                  : 92
MINUS                : 87 99
MOD                  : 102
NAMESPACE            : 32
NEWLINE              : 
NOT                  : 88
NULAR_FNC            : 83
NUMBER_EXP           : 110
NUMBER_HEX           : 111
NUMBER_REAL          : 109
OR                   : 97
PLUS                 : 86 98
POW                  : 103
PRIVATE              : 53 54 55
PRIVATE_ID           : 54 56 58
RBRACE               : 24 43 45 48 73 106
RPAREN               : 24 72
RSPAREN              : 41 75 76 79 80
SEMI_COLON           : 9
STEP                 : 40
STRING_DOUBLE        : 113
STRING_SINGLE        : 112
SWITCH               : 24
THEN                 : 29 31
TIMES                : 100
TO                   : 39 40
UNARY_FNC            : 85
WHILE                : 35
WITH                 : 32
error                : 

Nonterminals, with rules where they appear

array                : 37 66
arraydefinition      : 47
arrayelement         : 76 78
assignment           : 5
assignment_code      : 48
binaryexp            : 6 70 72
booleanexp           : 43 105 106
bracedexp            : 21 23 29 30 31 31 34 36 37 38 71
bracedexp_noscope    : 41 41 42
case                 : 26 27
code                 : 3 45 48 73 0
comparisonoperator   : 61 105 106
configaccessor       : 
controlstructure     : 4
definition           : 46 49 51
empty                : 1 25
foreachloop          : 15
forloop              : 13
forloop_condition    : 28 35 41
fortype              : 19 42
helpertype           : 65
identifier           : 44 64 84
ifstatement          : 11
iftype               : 17 29 30 31
mathoperator         : 62
new_scope            : 39 40 41 73
nularexp             : 7 68
number               : 63
primaryexp           : 21 22 24 38 39 39 40 40 40 49 50 60 60 61 61 62 62 77 78 85 86 87 88 104 105 106
statement            : 2 3
string               : 39 40 55 69 81 82
stringarray          : 53
stringarrayelement   : 80 82
switchbody           : 24 27
switchstatement      : 16
terminator           : 3 27
unaryexp             : 8 67
vardefinition        : 89
variable             : 50 52
whileloop            : 12
whiletype            : 18 36
withstatement        : 14
withstatementinit    : 34
withtype             : 20 33

Parsing method: LALR

state 0

    (0) S' -> . code
    (1) code -> . empty
    (2) code -> . statement
    (3) code -> . statement terminator code
    (114) empty -> .
    (4) statement -> . controlstructure
    (5) statement -> . assignment
    (6) statement -> . binaryexp
    (7) statement -> . nularexp
    (8) statement -> . unaryexp
    (11) controlstructure -> . ifstatement
    (12) controlstructure -> . whileloop
    (13) controlstructure -> . forloop
    (14) controlstructure -> . withstatement
    (15) controlstructure -> . foreachloop
    (16) controlstructure -> . switchstatement
    (48) assignment -> . assignment_code code RBRACE
    (49) assignment -> . definition EQUAL primaryexp
    (50) assignment -> . variable EQUAL primaryexp
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (29) ifstatement -> . iftype THEN bracedexp
    (30) ifstatement -> . iftype EXITWITH bracedexp
    (31) ifstatement -> . iftype THEN bracedexp ELSE bracedexp
    (36) whileloop -> . whiletype DO bracedexp
    (42) forloop -> . fortype DO bracedexp_noscope
    (34) withstatement -> . withstatementinit bracedexp
    (37) foreachloop -> . bracedexp FOREACH array
    (38) foreachloop -> . bracedexp FOREACH primaryexp
    (24) switchstatement -> . SWITCH LPAREN primaryexp RPAREN DO LBRACE switchbody RBRACE
    (51) assignment_code -> . definition EQUAL LBRACE
    (52) assignment_code -> . variable EQUAL LBRACE
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (58) variable -> . PRIVATE_ID
    (59) variable -> . GLOBAL_ID
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (33) withstatementinit -> . withtype DO
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (53) arraydefinition -> . PRIVATE stringarray
    (32) withtype -> . WITH NAMESPACE

    $end            reduce using rule 114 (empty -> .)
    NULAR_FNC       shift and go to state 19
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    SWITCH          shift and go to state 32
    PRIVATE         shift and go to state 35
    PRIVATE_ID      shift and go to state 36
    GLOBAL_ID       shift and go to state 38
    LPAREN          shift and go to state 33
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    LBRACE          shift and go to state 34
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    LSPAREN         shift and go to state 45
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    WITH            shift and go to state 52

    code                           shift and go to state 1
    empty                          shift and go to state 2
    statement                      shift and go to state 3
    controlstructure               shift and go to state 4
    assignment                     shift and go to state 5
    binaryexp                      shift and go to state 6
    nularexp                       shift and go to state 7
    unaryexp                       shift and go to state 8
    ifstatement                    shift and go to state 9
    whileloop                      shift and go to state 10
    forloop                        shift and go to state 11
    withstatement                  shift and go to state 12
    foreachloop                    shift and go to state 13
    switchstatement                shift and go to state 14
    assignment_code                shift and go to state 15
    definition                     shift and go to state 16
    primaryexp                     shift and go to state 17
    variable                       shift and go to state 18
    identifier                     shift and go to state 20
    vardefinition                  shift and go to state 25
    iftype                         shift and go to state 26
    bracedexp                      shift and go to state 27
    whiletype                      shift and go to state 28
    fortype                        shift and go to state 29
    withstatementinit              shift and go to state 30
    array                          shift and go to state 31
    string                         shift and go to state 37
    number                         shift and go to state 39
    helpertype                     shift and go to state 40
    arraydefinition                shift and go to state 41
    withtype                       shift and go to state 46

state 1

    (0) S' -> code .



state 2

    (1) code -> empty .

    $end            reduce using rule 1 (code -> empty .)
    RBRACE          reduce using rule 1 (code -> empty .)


state 3

    (2) code -> statement .
    (3) code -> statement . terminator code
    (9) terminator -> . SEMI_COLON
    (10) terminator -> . COMMA

    $end            reduce using rule 2 (code -> statement .)
    RBRACE          reduce using rule 2 (code -> statement .)
    SEMI_COLON      shift and go to state 54
    COMMA           shift and go to state 55

    terminator                     shift and go to state 53

state 4

    (4) statement -> controlstructure .

    SEMI_COLON      reduce using rule 4 (statement -> controlstructure .)
    COMMA           reduce using rule 4 (statement -> controlstructure .)
    $end            reduce using rule 4 (statement -> controlstructure .)
    RBRACE          reduce using rule 4 (statement -> controlstructure .)


state 5

    (5) statement -> assignment .

    SEMI_COLON      reduce using rule 5 (statement -> assignment .)
    COMMA           reduce using rule 5 (statement -> assignment .)
    $end            reduce using rule 5 (statement -> assignment .)
    RBRACE          reduce using rule 5 (statement -> assignment .)


state 6

    (6) statement -> binaryexp .
    (70) primaryexp -> binaryexp .

    SEMI_COLON      reduce using rule 6 (statement -> binaryexp .)
    COMMA           reduce using rule 6 (statement -> binaryexp .)
    $end            reduce using rule 6 (statement -> binaryexp .)
    RBRACE          reduce using rule 6 (statement -> binaryexp .)
    BINARY_FNC      reduce using rule 70 (primaryexp -> binaryexp .)
    LT              reduce using rule 70 (primaryexp -> binaryexp .)
    GT              reduce using rule 70 (primaryexp -> binaryexp .)
    LTE             reduce using rule 70 (primaryexp -> binaryexp .)
    GTE             reduce using rule 70 (primaryexp -> binaryexp .)
    EQUALITY        reduce using rule 70 (primaryexp -> binaryexp .)
    INEQUALITY      reduce using rule 70 (primaryexp -> binaryexp .)
    AND             reduce using rule 70 (primaryexp -> binaryexp .)
    OR              reduce using rule 70 (primaryexp -> binaryexp .)
    PLUS            reduce using rule 70 (primaryexp -> binaryexp .)
    MINUS           reduce using rule 70 (primaryexp -> binaryexp .)
    TIMES           reduce using rule 70 (primaryexp -> binaryexp .)
    DIVIDE          reduce using rule 70 (primaryexp -> binaryexp .)
    MOD             reduce using rule 70 (primaryexp -> binaryexp .)
    POW             reduce using rule 70 (primaryexp -> binaryexp .)


state 7

    (7) statement -> nularexp .
    (68) primaryexp -> nularexp .

    SEMI_COLON      reduce using rule 7 (statement -> nularexp .)
    COMMA           reduce using rule 7 (statement -> nularexp .)
    $end            reduce using rule 7 (statement -> nularexp .)
    RBRACE          reduce using rule 7 (statement -> nularexp .)
    BINARY_FNC      reduce using rule 68 (primaryexp -> nularexp .)
    LT              reduce using rule 68 (primaryexp -> nularexp .)
    GT              reduce using rule 68 (primaryexp -> nularexp .)
    LTE             reduce using rule 68 (primaryexp -> nularexp .)
    GTE             reduce using rule 68 (primaryexp -> nularexp .)
    EQUALITY        reduce using rule 68 (primaryexp -> nularexp .)
    INEQUALITY      reduce using rule 68 (primaryexp -> nularexp .)
    AND             reduce using rule 68 (primaryexp -> nularexp .)
    OR              reduce using rule 68 (primaryexp -> nularexp .)
    PLUS            reduce using rule 68 (primaryexp -> nularexp .)
    MINUS           reduce using rule 68 (primaryexp -> nularexp .)
    TIMES           reduce using rule 68 (primaryexp -> nularexp .)
    DIVIDE          reduce using rule 68 (primaryexp -> nularexp .)
    MOD             reduce using rule 68 (primaryexp -> nularexp .)
    POW             reduce using rule 68 (primaryexp -> nularexp .)


state 8

    (8) statement -> unaryexp .
    (67) primaryexp -> unaryexp .

    SEMI_COLON      reduce using rule 8 (statement -> unaryexp .)
    COMMA           reduce using rule 8 (statement -> unaryexp .)
    $end            reduce using rule 8 (statement -> unaryexp .)
    RBRACE          reduce using rule 8 (statement -> unaryexp .)
    BINARY_FNC      reduce using rule 67 (primaryexp -> unaryexp .)
    LT              reduce using rule 67 (primaryexp -> unaryexp .)
    GT              reduce using rule 67 (primaryexp -> unaryexp .)
    LTE             reduce using rule 67 (primaryexp -> unaryexp .)
    GTE             reduce using rule 67 (primaryexp -> unaryexp .)
    EQUALITY        reduce using rule 67 (primaryexp -> unaryexp .)
    INEQUALITY      reduce using rule 67 (primaryexp -> unaryexp .)
    AND             reduce using rule 67 (primaryexp -> unaryexp .)
    OR              reduce using rule 67 (primaryexp -> unaryexp .)
    PLUS            reduce using rule 67 (primaryexp -> unaryexp .)
    MINUS           reduce using rule 67 (primaryexp -> unaryexp .)
    TIMES           reduce using rule 67 (primaryexp -> unaryexp .)
    DIVIDE          reduce using rule 67 (primaryexp -> unaryexp .)
    MOD             reduce using rule 67 (primaryexp -> unaryexp .)
    POW             reduce using rule 67 (primaryexp -> unaryexp .)


state 9

    (11) controlstructure -> ifstatement .

    SEMI_COLON      reduce using rule 11 (controlstructure -> ifstatement .)
    COMMA           reduce using rule 11 (controlstructure -> ifstatement .)
    $end            reduce using rule 11 (controlstructure -> ifstatement .)
    RBRACE          reduce using rule 11 (controlstructure -> ifstatement .)


state 10

    (12) controlstructure -> whileloop .

    SEMI_COLON      reduce using rule 12 (controlstructure -> whileloop .)
    COMMA           reduce using rule 12 (controlstructure -> whileloop .)
    $end            reduce using rule 12 (controlstructure -> whileloop .)
    RBRACE          reduce using rule 12 (controlstructure -> whileloop .)


state 11

    (13) controlstructure -> forloop .

    SEMI_COLON      reduce using rule 13 (controlstructure -> forloop .)
    COMMA           reduce using rule 13 (controlstructure -> forloop .)
    $end            reduce using rule 13 (controlstructure -> forloop .)
    RBRACE          reduce using rule 13 (controlstructure -> forloop .)


state 12

    (14) controlstructure -> withstatement .

    SEMI_COLON      reduce using rule 14 (controlstructure -> withstatement .)
    COMMA           reduce using rule 14 (controlstructure -> withstatement .)
    $end            reduce using rule 14 (controlstructure -> withstatement .)
    RBRACE          reduce using rule 14 (controlstructure -> withstatement .)


state 13

    (15) controlstructure -> foreachloop .

    SEMI_COLON      reduce using rule 15 (controlstructure -> foreachloop .)
    COMMA           reduce using rule 15 (controlstructure -> foreachloop .)
    $end            reduce using rule 15 (controlstructure -> foreachloop .)
    RBRACE          reduce using rule 15 (controlstructure -> foreachloop .)


state 14

    (16) controlstructure -> switchstatement .

    SEMI_COLON      reduce using rule 16 (controlstructure -> switchstatement .)
    COMMA           reduce using rule 16 (controlstructure -> switchstatement .)
    $end            reduce using rule 16 (controlstructure -> switchstatement .)
    RBRACE          reduce using rule 16 (controlstructure -> switchstatement .)


state 15

    (48) assignment -> assignment_code . code RBRACE
    (1) code -> . empty
    (2) code -> . statement
    (3) code -> . statement terminator code
    (114) empty -> .
    (4) statement -> . controlstructure
    (5) statement -> . assignment
    (6) statement -> . binaryexp
    (7) statement -> . nularexp
    (8) statement -> . unaryexp
    (11) controlstructure -> . ifstatement
    (12) controlstructure -> . whileloop
    (13) controlstructure -> . forloop
    (14) controlstructure -> . withstatement
    (15) controlstructure -> . foreachloop
    (16) controlstructure -> . switchstatement
    (48) assignment -> . assignment_code code RBRACE
    (49) assignment -> . definition EQUAL primaryexp
    (50) assignment -> . variable EQUAL primaryexp
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (29) ifstatement -> . iftype THEN bracedexp
    (30) ifstatement -> . iftype EXITWITH bracedexp
    (31) ifstatement -> . iftype THEN bracedexp ELSE bracedexp
    (36) whileloop -> . whiletype DO bracedexp
    (42) forloop -> . fortype DO bracedexp_noscope
    (34) withstatement -> . withstatementinit bracedexp
    (37) foreachloop -> . bracedexp FOREACH array
    (38) foreachloop -> . bracedexp FOREACH primaryexp
    (24) switchstatement -> . SWITCH LPAREN primaryexp RPAREN DO LBRACE switchbody RBRACE
    (51) assignment_code -> . definition EQUAL LBRACE
    (52) assignment_code -> . variable EQUAL LBRACE
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (58) variable -> . PRIVATE_ID
    (59) variable -> . GLOBAL_ID
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (33) withstatementinit -> . withtype DO
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (53) arraydefinition -> . PRIVATE stringarray
    (32) withtype -> . WITH NAMESPACE

    RBRACE          reduce using rule 114 (empty -> .)
    NULAR_FNC       shift and go to state 19
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    SWITCH          shift and go to state 32
    PRIVATE         shift and go to state 35
    PRIVATE_ID      shift and go to state 36
    GLOBAL_ID       shift and go to state 38
    LPAREN          shift and go to state 33
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    LBRACE          shift and go to state 34
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    LSPAREN         shift and go to state 45
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    WITH            shift and go to state 52

    assignment_code                shift and go to state 15
    code                           shift and go to state 56
    empty                          shift and go to state 2
    statement                      shift and go to state 3
    controlstructure               shift and go to state 4
    assignment                     shift and go to state 5
    binaryexp                      shift and go to state 6
    nularexp                       shift and go to state 7
    unaryexp                       shift and go to state 8
    ifstatement                    shift and go to state 9
    whileloop                      shift and go to state 10
    forloop                        shift and go to state 11
    withstatement                  shift and go to state 12
    foreachloop                    shift and go to state 13
    switchstatement                shift and go to state 14
    definition                     shift and go to state 16
    primaryexp                     shift and go to state 17
    variable                       shift and go to state 18
    identifier                     shift and go to state 20
    vardefinition                  shift and go to state 25
    iftype                         shift and go to state 26
    bracedexp                      shift and go to state 27
    whiletype                      shift and go to state 28
    fortype                        shift and go to state 29
    withstatementinit              shift and go to state 30
    array                          shift and go to state 31
    string                         shift and go to state 37
    number                         shift and go to state 39
    helpertype                     shift and go to state 40
    arraydefinition                shift and go to state 41
    withtype                       shift and go to state 46

state 16

    (49) assignment -> definition . EQUAL primaryexp
    (51) assignment_code -> definition . EQUAL LBRACE
    (46) vardefinition -> definition .

    EQUAL           shift and go to state 57
    SEMI_COLON      reduce using rule 46 (vardefinition -> definition .)
    COMMA           reduce using rule 46 (vardefinition -> definition .)
    $end            reduce using rule 46 (vardefinition -> definition .)
    BINARY_FNC      reduce using rule 46 (vardefinition -> definition .)
    LT              reduce using rule 46 (vardefinition -> definition .)
    GT              reduce using rule 46 (vardefinition -> definition .)
    LTE             reduce using rule 46 (vardefinition -> definition .)
    GTE             reduce using rule 46 (vardefinition -> definition .)
    EQUALITY        reduce using rule 46 (vardefinition -> definition .)
    INEQUALITY      reduce using rule 46 (vardefinition -> definition .)
    AND             reduce using rule 46 (vardefinition -> definition .)
    OR              reduce using rule 46 (vardefinition -> definition .)
    PLUS            reduce using rule 46 (vardefinition -> definition .)
    MINUS           reduce using rule 46 (vardefinition -> definition .)
    TIMES           reduce using rule 46 (vardefinition -> definition .)
    DIVIDE          reduce using rule 46 (vardefinition -> definition .)
    MOD             reduce using rule 46 (vardefinition -> definition .)
    POW             reduce using rule 46 (vardefinition -> definition .)
    RBRACE          reduce using rule 46 (vardefinition -> definition .)


state 17

    (60) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (61) binaryexp -> primaryexp . comparisonoperator primaryexp
    (62) binaryexp -> primaryexp . mathoperator primaryexp
    (90) comparisonoperator -> . LT
    (91) comparisonoperator -> . GT
    (92) comparisonoperator -> . LTE
    (93) comparisonoperator -> . GTE
    (94) comparisonoperator -> . EQUALITY
    (95) comparisonoperator -> . INEQUALITY
    (96) comparisonoperator -> . AND
    (97) comparisonoperator -> . OR
    (98) mathoperator -> . PLUS
    (99) mathoperator -> . MINUS
    (100) mathoperator -> . TIMES
    (101) mathoperator -> . DIVIDE
    (102) mathoperator -> . MOD
    (103) mathoperator -> . POW

    BINARY_FNC      shift and go to state 58
    LT              shift and go to state 61
    GT              shift and go to state 62
    LTE             shift and go to state 63
    GTE             shift and go to state 64
    EQUALITY        shift and go to state 65
    INEQUALITY      shift and go to state 66
    AND             shift and go to state 67
    OR              shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    MOD             shift and go to state 73
    POW             shift and go to state 74

    comparisonoperator             shift and go to state 59
    mathoperator                   shift and go to state 60

state 18

    (50) assignment -> variable . EQUAL primaryexp
    (52) assignment_code -> variable . EQUAL LBRACE

    EQUAL           shift and go to state 75


state 19

    (83) nularexp -> NULAR_FNC .

    SEMI_COLON      reduce using rule 83 (nularexp -> NULAR_FNC .)
    COMMA           reduce using rule 83 (nularexp -> NULAR_FNC .)
    $end            reduce using rule 83 (nularexp -> NULAR_FNC .)
    BINARY_FNC      reduce using rule 83 (nularexp -> NULAR_FNC .)
    LT              reduce using rule 83 (nularexp -> NULAR_FNC .)
    GT              reduce using rule 83 (nularexp -> NULAR_FNC .)
    LTE             reduce using rule 83 (nularexp -> NULAR_FNC .)
    GTE             reduce using rule 83 (nularexp -> NULAR_FNC .)
    EQUALITY        reduce using rule 83 (nularexp -> NULAR_FNC .)
    INEQUALITY      reduce using rule 83 (nularexp -> NULAR_FNC .)
    AND             reduce using rule 83 (nularexp -> NULAR_FNC .)
    OR              reduce using rule 83 (nularexp -> NULAR_FNC .)
    PLUS            reduce using rule 83 (nularexp -> NULAR_FNC .)
    MINUS           reduce using rule 83 (nularexp -> NULAR_FNC .)
    TIMES           reduce using rule 83 (nularexp -> NULAR_FNC .)
    DIVIDE          reduce using rule 83 (nularexp -> NULAR_FNC .)
    MOD             reduce using rule 83 (nularexp -> NULAR_FNC .)
    POW             reduce using rule 83 (nularexp -> NULAR_FNC .)
    RBRACE          reduce using rule 83 (nularexp -> NULAR_FNC .)
    RSPAREN         reduce using rule 83 (nularexp -> NULAR_FNC .)
    RPAREN          reduce using rule 83 (nularexp -> NULAR_FNC .)
    TO              reduce using rule 83 (nularexp -> NULAR_FNC .)
    STEP            reduce using rule 83 (nularexp -> NULAR_FNC .)
    DO              reduce using rule 83 (nularexp -> NULAR_FNC .)
    COLON           reduce using rule 83 (nularexp -> NULAR_FNC .)


state 20

    (84) nularexp -> identifier .
    (64) primaryexp -> identifier .

  ! reduce/reduce conflict for BINARY_FNC resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for LT resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for GT resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for LTE resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for GTE resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for EQUALITY resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for INEQUALITY resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for AND resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for OR resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for PLUS resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for MINUS resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for TIMES resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for MOD resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for POW resolved using rule 64 (primaryexp -> identifier .)
    SEMI_COLON      reduce using rule 84 (nularexp -> identifier .)
    COMMA           reduce using rule 84 (nularexp -> identifier .)
    $end            reduce using rule 84 (nularexp -> identifier .)
    RBRACE          reduce using rule 84 (nularexp -> identifier .)
    BINARY_FNC      reduce using rule 64 (primaryexp -> identifier .)
    LT              reduce using rule 64 (primaryexp -> identifier .)
    GT              reduce using rule 64 (primaryexp -> identifier .)
    LTE             reduce using rule 64 (primaryexp -> identifier .)
    GTE             reduce using rule 64 (primaryexp -> identifier .)
    EQUALITY        reduce using rule 64 (primaryexp -> identifier .)
    INEQUALITY      reduce using rule 64 (primaryexp -> identifier .)
    AND             reduce using rule 64 (primaryexp -> identifier .)
    OR              reduce using rule 64 (primaryexp -> identifier .)
    PLUS            reduce using rule 64 (primaryexp -> identifier .)
    MINUS           reduce using rule 64 (primaryexp -> identifier .)
    TIMES           reduce using rule 64 (primaryexp -> identifier .)
    DIVIDE          reduce using rule 64 (primaryexp -> identifier .)
    MOD             reduce using rule 64 (primaryexp -> identifier .)
    POW             reduce using rule 64 (primaryexp -> identifier .)

  ! BINARY_FNC      [ reduce using rule 84 (nularexp -> identifier .) ]
  ! LT              [ reduce using rule 84 (nularexp -> identifier .) ]
  ! GT              [ reduce using rule 84 (nularexp -> identifier .) ]
  ! LTE             [ reduce using rule 84 (nularexp -> identifier .) ]
  ! GTE             [ reduce using rule 84 (nularexp -> identifier .) ]
  ! EQUALITY        [ reduce using rule 84 (nularexp -> identifier .) ]
  ! INEQUALITY      [ reduce using rule 84 (nularexp -> identifier .) ]
  ! AND             [ reduce using rule 84 (nularexp -> identifier .) ]
  ! OR              [ reduce using rule 84 (nularexp -> identifier .) ]
  ! PLUS            [ reduce using rule 84 (nularexp -> identifier .) ]
  ! MINUS           [ reduce using rule 84 (nularexp -> identifier .) ]
  ! TIMES           [ reduce using rule 84 (nularexp -> identifier .) ]
  ! DIVIDE          [ reduce using rule 84 (nularexp -> identifier .) ]
  ! MOD             [ reduce using rule 84 (nularexp -> identifier .) ]
  ! POW             [ reduce using rule 84 (nularexp -> identifier .) ]


state 21

    (85) unaryexp -> UNARY_FNC . primaryexp
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (32) withtype -> . WITH NAMESPACE
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (53) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 33
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    PRIVATE_ID      shift and go to state 82
    GLOBAL_ID       shift and go to state 83
    LSPAREN         shift and go to state 45
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    NULAR_FNC       shift and go to state 19
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    LBRACE          shift and go to state 34
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    WITH            shift and go to state 52
    PRIVATE         shift and go to state 35

    primaryexp                     shift and go to state 76
    number                         shift and go to state 39
    identifier                     shift and go to state 77
    helpertype                     shift and go to state 40
    array                          shift and go to state 31
    unaryexp                       shift and go to state 78
    nularexp                       shift and go to state 79
    string                         shift and go to state 37
    binaryexp                      shift and go to state 80
    bracedexp                      shift and go to state 81
    iftype                         shift and go to state 84
    whiletype                      shift and go to state 85
    fortype                        shift and go to state 86
    withtype                       shift and go to state 87
    vardefinition                  shift and go to state 25
    definition                     shift and go to state 88
    arraydefinition                shift and go to state 41

state 22

    (86) unaryexp -> PLUS . primaryexp
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (32) withtype -> . WITH NAMESPACE
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (53) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 33
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    PRIVATE_ID      shift and go to state 82
    GLOBAL_ID       shift and go to state 83
    LSPAREN         shift and go to state 45
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    NULAR_FNC       shift and go to state 19
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    LBRACE          shift and go to state 34
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    WITH            shift and go to state 52
    PRIVATE         shift and go to state 35

    primaryexp                     shift and go to state 89
    number                         shift and go to state 39
    identifier                     shift and go to state 77
    helpertype                     shift and go to state 40
    array                          shift and go to state 31
    unaryexp                       shift and go to state 78
    nularexp                       shift and go to state 79
    string                         shift and go to state 37
    binaryexp                      shift and go to state 80
    bracedexp                      shift and go to state 81
    iftype                         shift and go to state 84
    whiletype                      shift and go to state 85
    fortype                        shift and go to state 86
    withtype                       shift and go to state 87
    vardefinition                  shift and go to state 25
    definition                     shift and go to state 88
    arraydefinition                shift and go to state 41

state 23

    (87) unaryexp -> MINUS . primaryexp
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (32) withtype -> . WITH NAMESPACE
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (53) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 33
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    PRIVATE_ID      shift and go to state 82
    GLOBAL_ID       shift and go to state 83
    LSPAREN         shift and go to state 45
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    NULAR_FNC       shift and go to state 19
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    LBRACE          shift and go to state 34
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    WITH            shift and go to state 52
    PRIVATE         shift and go to state 35

    primaryexp                     shift and go to state 90
    number                         shift and go to state 39
    identifier                     shift and go to state 77
    helpertype                     shift and go to state 40
    array                          shift and go to state 31
    unaryexp                       shift and go to state 78
    nularexp                       shift and go to state 79
    string                         shift and go to state 37
    binaryexp                      shift and go to state 80
    bracedexp                      shift and go to state 81
    iftype                         shift and go to state 84
    whiletype                      shift and go to state 85
    fortype                        shift and go to state 86
    withtype                       shift and go to state 87
    vardefinition                  shift and go to state 25
    definition                     shift and go to state 88
    arraydefinition                shift and go to state 41

state 24

    (88) unaryexp -> NOT . primaryexp
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (32) withtype -> . WITH NAMESPACE
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (53) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 33
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    PRIVATE_ID      shift and go to state 82
    GLOBAL_ID       shift and go to state 83
    LSPAREN         shift and go to state 45
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    NULAR_FNC       shift and go to state 19
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    LBRACE          shift and go to state 34
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    WITH            shift and go to state 52
    PRIVATE         shift and go to state 35

    primaryexp                     shift and go to state 91
    number                         shift and go to state 39
    identifier                     shift and go to state 77
    helpertype                     shift and go to state 40
    array                          shift and go to state 31
    unaryexp                       shift and go to state 78
    nularexp                       shift and go to state 79
    string                         shift and go to state 37
    binaryexp                      shift and go to state 80
    bracedexp                      shift and go to state 81
    iftype                         shift and go to state 84
    whiletype                      shift and go to state 85
    fortype                        shift and go to state 86
    withtype                       shift and go to state 87
    vardefinition                  shift and go to state 25
    definition                     shift and go to state 88
    arraydefinition                shift and go to state 41

state 25

    (89) unaryexp -> vardefinition .

    SEMI_COLON      reduce using rule 89 (unaryexp -> vardefinition .)
    COMMA           reduce using rule 89 (unaryexp -> vardefinition .)
    $end            reduce using rule 89 (unaryexp -> vardefinition .)
    BINARY_FNC      reduce using rule 89 (unaryexp -> vardefinition .)
    LT              reduce using rule 89 (unaryexp -> vardefinition .)
    GT              reduce using rule 89 (unaryexp -> vardefinition .)
    LTE             reduce using rule 89 (unaryexp -> vardefinition .)
    GTE             reduce using rule 89 (unaryexp -> vardefinition .)
    EQUALITY        reduce using rule 89 (unaryexp -> vardefinition .)
    INEQUALITY      reduce using rule 89 (unaryexp -> vardefinition .)
    AND             reduce using rule 89 (unaryexp -> vardefinition .)
    OR              reduce using rule 89 (unaryexp -> vardefinition .)
    PLUS            reduce using rule 89 (unaryexp -> vardefinition .)
    MINUS           reduce using rule 89 (unaryexp -> vardefinition .)
    TIMES           reduce using rule 89 (unaryexp -> vardefinition .)
    DIVIDE          reduce using rule 89 (unaryexp -> vardefinition .)
    MOD             reduce using rule 89 (unaryexp -> vardefinition .)
    POW             reduce using rule 89 (unaryexp -> vardefinition .)
    RBRACE          reduce using rule 89 (unaryexp -> vardefinition .)
    RSPAREN         reduce using rule 89 (unaryexp -> vardefinition .)
    RPAREN          reduce using rule 89 (unaryexp -> vardefinition .)
    TO              reduce using rule 89 (unaryexp -> vardefinition .)
    STEP            reduce using rule 89 (unaryexp -> vardefinition .)
    DO              reduce using rule 89 (unaryexp -> vardefinition .)
    COLON           reduce using rule 89 (unaryexp -> vardefinition .)


state 26

    (29) ifstatement -> iftype . THEN bracedexp
    (30) ifstatement -> iftype . EXITWITH bracedexp
    (31) ifstatement -> iftype . THEN bracedexp ELSE bracedexp
    (17) helpertype -> iftype .

    THEN            shift and go to state 92
    EXITWITH        shift and go to state 93
    BINARY_FNC      reduce using rule 17 (helpertype -> iftype .)
    LT              reduce using rule 17 (helpertype -> iftype .)
    GT              reduce using rule 17 (helpertype -> iftype .)
    LTE             reduce using rule 17 (helpertype -> iftype .)
    GTE             reduce using rule 17 (helpertype -> iftype .)
    EQUALITY        reduce using rule 17 (helpertype -> iftype .)
    INEQUALITY      reduce using rule 17 (helpertype -> iftype .)
    AND             reduce using rule 17 (helpertype -> iftype .)
    OR              reduce using rule 17 (helpertype -> iftype .)
    PLUS            reduce using rule 17 (helpertype -> iftype .)
    MINUS           reduce using rule 17 (helpertype -> iftype .)
    TIMES           reduce using rule 17 (helpertype -> iftype .)
    DIVIDE          reduce using rule 17 (helpertype -> iftype .)
    MOD             reduce using rule 17 (helpertype -> iftype .)
    POW             reduce using rule 17 (helpertype -> iftype .)


state 27

    (37) foreachloop -> bracedexp . FOREACH array
    (38) foreachloop -> bracedexp . FOREACH primaryexp
    (71) primaryexp -> bracedexp .

    FOREACH         shift and go to state 94
    BINARY_FNC      reduce using rule 71 (primaryexp -> bracedexp .)
    LT              reduce using rule 71 (primaryexp -> bracedexp .)
    GT              reduce using rule 71 (primaryexp -> bracedexp .)
    LTE             reduce using rule 71 (primaryexp -> bracedexp .)
    GTE             reduce using rule 71 (primaryexp -> bracedexp .)
    EQUALITY        reduce using rule 71 (primaryexp -> bracedexp .)
    INEQUALITY      reduce using rule 71 (primaryexp -> bracedexp .)
    AND             reduce using rule 71 (primaryexp -> bracedexp .)
    OR              reduce using rule 71 (primaryexp -> bracedexp .)
    PLUS            reduce using rule 71 (primaryexp -> bracedexp .)
    MINUS           reduce using rule 71 (primaryexp -> bracedexp .)
    TIMES           reduce using rule 71 (primaryexp -> bracedexp .)
    DIVIDE          reduce using rule 71 (primaryexp -> bracedexp .)
    MOD             reduce using rule 71 (primaryexp -> bracedexp .)
    POW             reduce using rule 71 (primaryexp -> bracedexp .)


state 28

    (36) whileloop -> whiletype . DO bracedexp
    (18) helpertype -> whiletype .

    DO              shift and go to state 95
    BINARY_FNC      reduce using rule 18 (helpertype -> whiletype .)
    LT              reduce using rule 18 (helpertype -> whiletype .)
    GT              reduce using rule 18 (helpertype -> whiletype .)
    LTE             reduce using rule 18 (helpertype -> whiletype .)
    GTE             reduce using rule 18 (helpertype -> whiletype .)
    EQUALITY        reduce using rule 18 (helpertype -> whiletype .)
    INEQUALITY      reduce using rule 18 (helpertype -> whiletype .)
    AND             reduce using rule 18 (helpertype -> whiletype .)
    OR              reduce using rule 18 (helpertype -> whiletype .)
    PLUS            reduce using rule 18 (helpertype -> whiletype .)
    MINUS           reduce using rule 18 (helpertype -> whiletype .)
    TIMES           reduce using rule 18 (helpertype -> whiletype .)
    DIVIDE          reduce using rule 18 (helpertype -> whiletype .)
    MOD             reduce using rule 18 (helpertype -> whiletype .)
    POW             reduce using rule 18 (helpertype -> whiletype .)


state 29

    (42) forloop -> fortype . DO bracedexp_noscope
    (19) helpertype -> fortype .

    DO              shift and go to state 96
    BINARY_FNC      reduce using rule 19 (helpertype -> fortype .)
    LT              reduce using rule 19 (helpertype -> fortype .)
    GT              reduce using rule 19 (helpertype -> fortype .)
    LTE             reduce using rule 19 (helpertype -> fortype .)
    GTE             reduce using rule 19 (helpertype -> fortype .)
    EQUALITY        reduce using rule 19 (helpertype -> fortype .)
    INEQUALITY      reduce using rule 19 (helpertype -> fortype .)
    AND             reduce using rule 19 (helpertype -> fortype .)
    OR              reduce using rule 19 (helpertype -> fortype .)
    PLUS            reduce using rule 19 (helpertype -> fortype .)
    MINUS           reduce using rule 19 (helpertype -> fortype .)
    TIMES           reduce using rule 19 (helpertype -> fortype .)
    DIVIDE          reduce using rule 19 (helpertype -> fortype .)
    MOD             reduce using rule 19 (helpertype -> fortype .)
    POW             reduce using rule 19 (helpertype -> fortype .)


state 30

    (34) withstatement -> withstatementinit . bracedexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE

    LBRACE          shift and go to state 34

    bracedexp                      shift and go to state 97

state 31

    (66) primaryexp -> array .

    BINARY_FNC      reduce using rule 66 (primaryexp -> array .)
    LT              reduce using rule 66 (primaryexp -> array .)
    GT              reduce using rule 66 (primaryexp -> array .)
    LTE             reduce using rule 66 (primaryexp -> array .)
    GTE             reduce using rule 66 (primaryexp -> array .)
    EQUALITY        reduce using rule 66 (primaryexp -> array .)
    INEQUALITY      reduce using rule 66 (primaryexp -> array .)
    AND             reduce using rule 66 (primaryexp -> array .)
    OR              reduce using rule 66 (primaryexp -> array .)
    PLUS            reduce using rule 66 (primaryexp -> array .)
    MINUS           reduce using rule 66 (primaryexp -> array .)
    TIMES           reduce using rule 66 (primaryexp -> array .)
    DIVIDE          reduce using rule 66 (primaryexp -> array .)
    MOD             reduce using rule 66 (primaryexp -> array .)
    POW             reduce using rule 66 (primaryexp -> array .)
    SEMI_COLON      reduce using rule 66 (primaryexp -> array .)
    COMMA           reduce using rule 66 (primaryexp -> array .)
    $end            reduce using rule 66 (primaryexp -> array .)
    RBRACE          reduce using rule 66 (primaryexp -> array .)
    RSPAREN         reduce using rule 66 (primaryexp -> array .)
    RPAREN          reduce using rule 66 (primaryexp -> array .)
    TO              reduce using rule 66 (primaryexp -> array .)
    STEP            reduce using rule 66 (primaryexp -> array .)
    DO              reduce using rule 66 (primaryexp -> array .)
    COLON           reduce using rule 66 (primaryexp -> array .)


state 32

    (24) switchstatement -> SWITCH . LPAREN primaryexp RPAREN DO LBRACE switchbody RBRACE

    LPAREN          shift and go to state 98


state 33

    (72) primaryexp -> LPAREN . binaryexp RPAREN
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (32) withtype -> . WITH NAMESPACE
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (53) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 33
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    PRIVATE_ID      shift and go to state 82
    GLOBAL_ID       shift and go to state 83
    LSPAREN         shift and go to state 45
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    NULAR_FNC       shift and go to state 19
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    LBRACE          shift and go to state 34
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    WITH            shift and go to state 52
    PRIVATE         shift and go to state 35

    binaryexp                      shift and go to state 99
    primaryexp                     shift and go to state 17
    number                         shift and go to state 39
    identifier                     shift and go to state 77
    helpertype                     shift and go to state 40
    array                          shift and go to state 31
    unaryexp                       shift and go to state 78
    nularexp                       shift and go to state 79
    string                         shift and go to state 37
    bracedexp                      shift and go to state 81
    iftype                         shift and go to state 84
    whiletype                      shift and go to state 85
    fortype                        shift and go to state 86
    withtype                       shift and go to state 87
    vardefinition                  shift and go to state 25
    definition                     shift and go to state 88
    arraydefinition                shift and go to state 41

state 34

    (73) bracedexp -> LBRACE . new_scope code RBRACE
    (74) new_scope -> .

    NULAR_FNC       reduce using rule 74 (new_scope -> .)
    UNARY_FNC       reduce using rule 74 (new_scope -> .)
    PLUS            reduce using rule 74 (new_scope -> .)
    MINUS           reduce using rule 74 (new_scope -> .)
    NOT             reduce using rule 74 (new_scope -> .)
    SWITCH          reduce using rule 74 (new_scope -> .)
    PRIVATE         reduce using rule 74 (new_scope -> .)
    PRIVATE_ID      reduce using rule 74 (new_scope -> .)
    GLOBAL_ID       reduce using rule 74 (new_scope -> .)
    LPAREN          reduce using rule 74 (new_scope -> .)
    IF              reduce using rule 74 (new_scope -> .)
    WHILE           reduce using rule 74 (new_scope -> .)
    FOR             reduce using rule 74 (new_scope -> .)
    LBRACE          reduce using rule 74 (new_scope -> .)
    NUMBER_REAL     reduce using rule 74 (new_scope -> .)
    NUMBER_EXP      reduce using rule 74 (new_scope -> .)
    NUMBER_HEX      reduce using rule 74 (new_scope -> .)
    LSPAREN         reduce using rule 74 (new_scope -> .)
    STRING_SINGLE   reduce using rule 74 (new_scope -> .)
    STRING_DOUBLE   reduce using rule 74 (new_scope -> .)
    WITH            reduce using rule 74 (new_scope -> .)
    RBRACE          reduce using rule 74 (new_scope -> .)

    new_scope                      shift and go to state 100

state 35

    (54) definition -> PRIVATE . PRIVATE_ID
    (55) definition -> PRIVATE . string
    (53) arraydefinition -> PRIVATE . stringarray
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (79) stringarray -> . LSPAREN RSPAREN
    (80) stringarray -> . LSPAREN stringarrayelement RSPAREN

    PRIVATE_ID      shift and go to state 101
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    LSPAREN         shift and go to state 104

    string                         shift and go to state 102
    stringarray                    shift and go to state 103

state 36

    (58) variable -> PRIVATE_ID .
    (56) identifier -> PRIVATE_ID .

    EQUAL           reduce using rule 58 (variable -> PRIVATE_ID .)
    SEMI_COLON      reduce using rule 56 (identifier -> PRIVATE_ID .)
    COMMA           reduce using rule 56 (identifier -> PRIVATE_ID .)
    $end            reduce using rule 56 (identifier -> PRIVATE_ID .)
    BINARY_FNC      reduce using rule 56 (identifier -> PRIVATE_ID .)
    LT              reduce using rule 56 (identifier -> PRIVATE_ID .)
    GT              reduce using rule 56 (identifier -> PRIVATE_ID .)
    LTE             reduce using rule 56 (identifier -> PRIVATE_ID .)
    GTE             reduce using rule 56 (identifier -> PRIVATE_ID .)
    EQUALITY        reduce using rule 56 (identifier -> PRIVATE_ID .)
    INEQUALITY      reduce using rule 56 (identifier -> PRIVATE_ID .)
    AND             reduce using rule 56 (identifier -> PRIVATE_ID .)
    OR              reduce using rule 56 (identifier -> PRIVATE_ID .)
    PLUS            reduce using rule 56 (identifier -> PRIVATE_ID .)
    MINUS           reduce using rule 56 (identifier -> PRIVATE_ID .)
    TIMES           reduce using rule 56 (identifier -> PRIVATE_ID .)
    DIVIDE          reduce using rule 56 (identifier -> PRIVATE_ID .)
    MOD             reduce using rule 56 (identifier -> PRIVATE_ID .)
    POW             reduce using rule 56 (identifier -> PRIVATE_ID .)
    RBRACE          reduce using rule 56 (identifier -> PRIVATE_ID .)


state 37

    (69) primaryexp -> string .

    BINARY_FNC      reduce using rule 69 (primaryexp -> string .)
    LT              reduce using rule 69 (primaryexp -> string .)
    GT              reduce using rule 69 (primaryexp -> string .)
    LTE             reduce using rule 69 (primaryexp -> string .)
    GTE             reduce using rule 69 (primaryexp -> string .)
    EQUALITY        reduce using rule 69 (primaryexp -> string .)
    INEQUALITY      reduce using rule 69 (primaryexp -> string .)
    AND             reduce using rule 69 (primaryexp -> string .)
    OR              reduce using rule 69 (primaryexp -> string .)
    PLUS            reduce using rule 69 (primaryexp -> string .)
    MINUS           reduce using rule 69 (primaryexp -> string .)
    TIMES           reduce using rule 69 (primaryexp -> string .)
    DIVIDE          reduce using rule 69 (primaryexp -> string .)
    MOD             reduce using rule 69 (primaryexp -> string .)
    POW             reduce using rule 69 (primaryexp -> string .)
    SEMI_COLON      reduce using rule 69 (primaryexp -> string .)
    COMMA           reduce using rule 69 (primaryexp -> string .)
    $end            reduce using rule 69 (primaryexp -> string .)
    RBRACE          reduce using rule 69 (primaryexp -> string .)
    RSPAREN         reduce using rule 69 (primaryexp -> string .)
    RPAREN          reduce using rule 69 (primaryexp -> string .)
    TO              reduce using rule 69 (primaryexp -> string .)
    STEP            reduce using rule 69 (primaryexp -> string .)
    DO              reduce using rule 69 (primaryexp -> string .)
    COLON           reduce using rule 69 (primaryexp -> string .)


state 38

    (59) variable -> GLOBAL_ID .
    (57) identifier -> GLOBAL_ID .

    EQUAL           reduce using rule 59 (variable -> GLOBAL_ID .)
    SEMI_COLON      reduce using rule 57 (identifier -> GLOBAL_ID .)
    COMMA           reduce using rule 57 (identifier -> GLOBAL_ID .)
    $end            reduce using rule 57 (identifier -> GLOBAL_ID .)
    BINARY_FNC      reduce using rule 57 (identifier -> GLOBAL_ID .)
    LT              reduce using rule 57 (identifier -> GLOBAL_ID .)
    GT              reduce using rule 57 (identifier -> GLOBAL_ID .)
    LTE             reduce using rule 57 (identifier -> GLOBAL_ID .)
    GTE             reduce using rule 57 (identifier -> GLOBAL_ID .)
    EQUALITY        reduce using rule 57 (identifier -> GLOBAL_ID .)
    INEQUALITY      reduce using rule 57 (identifier -> GLOBAL_ID .)
    AND             reduce using rule 57 (identifier -> GLOBAL_ID .)
    OR              reduce using rule 57 (identifier -> GLOBAL_ID .)
    PLUS            reduce using rule 57 (identifier -> GLOBAL_ID .)
    MINUS           reduce using rule 57 (identifier -> GLOBAL_ID .)
    TIMES           reduce using rule 57 (identifier -> GLOBAL_ID .)
    DIVIDE          reduce using rule 57 (identifier -> GLOBAL_ID .)
    MOD             reduce using rule 57 (identifier -> GLOBAL_ID .)
    POW             reduce using rule 57 (identifier -> GLOBAL_ID .)
    RBRACE          reduce using rule 57 (identifier -> GLOBAL_ID .)


state 39

    (63) primaryexp -> number .

    BINARY_FNC      reduce using rule 63 (primaryexp -> number .)
    LT              reduce using rule 63 (primaryexp -> number .)
    GT              reduce using rule 63 (primaryexp -> number .)
    LTE             reduce using rule 63 (primaryexp -> number .)
    GTE             reduce using rule 63 (primaryexp -> number .)
    EQUALITY        reduce using rule 63 (primaryexp -> number .)
    INEQUALITY      reduce using rule 63 (primaryexp -> number .)
    AND             reduce using rule 63 (primaryexp -> number .)
    OR              reduce using rule 63 (primaryexp -> number .)
    PLUS            reduce using rule 63 (primaryexp -> number .)
    MINUS           reduce using rule 63 (primaryexp -> number .)
    TIMES           reduce using rule 63 (primaryexp -> number .)
    DIVIDE          reduce using rule 63 (primaryexp -> number .)
    MOD             reduce using rule 63 (primaryexp -> number .)
    POW             reduce using rule 63 (primaryexp -> number .)
    SEMI_COLON      reduce using rule 63 (primaryexp -> number .)
    COMMA           reduce using rule 63 (primaryexp -> number .)
    $end            reduce using rule 63 (primaryexp -> number .)
    RBRACE          reduce using rule 63 (primaryexp -> number .)
    RSPAREN         reduce using rule 63 (primaryexp -> number .)
    RPAREN          reduce using rule 63 (primaryexp -> number .)
    TO              reduce using rule 63 (primaryexp -> number .)
    STEP            reduce using rule 63 (primaryexp -> number .)
    DO              reduce using rule 63 (primaryexp -> number .)
    COLON           reduce using rule 63 (primaryexp -> number .)


state 40

    (65) primaryexp -> helpertype .

    BINARY_FNC      reduce using rule 65 (primaryexp -> helpertype .)
    LT              reduce using rule 65 (primaryexp -> helpertype .)
    GT              reduce using rule 65 (primaryexp -> helpertype .)
    LTE             reduce using rule 65 (primaryexp -> helpertype .)
    GTE             reduce using rule 65 (primaryexp -> helpertype .)
    EQUALITY        reduce using rule 65 (primaryexp -> helpertype .)
    INEQUALITY      reduce using rule 65 (primaryexp -> helpertype .)
    AND             reduce using rule 65 (primaryexp -> helpertype .)
    OR              reduce using rule 65 (primaryexp -> helpertype .)
    PLUS            reduce using rule 65 (primaryexp -> helpertype .)
    MINUS           reduce using rule 65 (primaryexp -> helpertype .)
    TIMES           reduce using rule 65 (primaryexp -> helpertype .)
    DIVIDE          reduce using rule 65 (primaryexp -> helpertype .)
    MOD             reduce using rule 65 (primaryexp -> helpertype .)
    POW             reduce using rule 65 (primaryexp -> helpertype .)
    SEMI_COLON      reduce using rule 65 (primaryexp -> helpertype .)
    COMMA           reduce using rule 65 (primaryexp -> helpertype .)
    $end            reduce using rule 65 (primaryexp -> helpertype .)
    RBRACE          reduce using rule 65 (primaryexp -> helpertype .)
    RSPAREN         reduce using rule 65 (primaryexp -> helpertype .)
    RPAREN          reduce using rule 65 (primaryexp -> helpertype .)
    TO              reduce using rule 65 (primaryexp -> helpertype .)
    STEP            reduce using rule 65 (primaryexp -> helpertype .)
    DO              reduce using rule 65 (primaryexp -> helpertype .)
    COLON           reduce using rule 65 (primaryexp -> helpertype .)


state 41

    (47) vardefinition -> arraydefinition .

    SEMI_COLON      reduce using rule 47 (vardefinition -> arraydefinition .)
    COMMA           reduce using rule 47 (vardefinition -> arraydefinition .)
    $end            reduce using rule 47 (vardefinition -> arraydefinition .)
    BINARY_FNC      reduce using rule 47 (vardefinition -> arraydefinition .)
    LT              reduce using rule 47 (vardefinition -> arraydefinition .)
    GT              reduce using rule 47 (vardefinition -> arraydefinition .)
    LTE             reduce using rule 47 (vardefinition -> arraydefinition .)
    GTE             reduce using rule 47 (vardefinition -> arraydefinition .)
    EQUALITY        reduce using rule 47 (vardefinition -> arraydefinition .)
    INEQUALITY      reduce using rule 47 (vardefinition -> arraydefinition .)
    AND             reduce using rule 47 (vardefinition -> arraydefinition .)
    OR              reduce using rule 47 (vardefinition -> arraydefinition .)
    PLUS            reduce using rule 47 (vardefinition -> arraydefinition .)
    MINUS           reduce using rule 47 (vardefinition -> arraydefinition .)
    TIMES           reduce using rule 47 (vardefinition -> arraydefinition .)
    DIVIDE          reduce using rule 47 (vardefinition -> arraydefinition .)
    MOD             reduce using rule 47 (vardefinition -> arraydefinition .)
    POW             reduce using rule 47 (vardefinition -> arraydefinition .)
    RBRACE          reduce using rule 47 (vardefinition -> arraydefinition .)
    RSPAREN         reduce using rule 47 (vardefinition -> arraydefinition .)
    RPAREN          reduce using rule 47 (vardefinition -> arraydefinition .)
    TO              reduce using rule 47 (vardefinition -> arraydefinition .)
    STEP            reduce using rule 47 (vardefinition -> arraydefinition .)
    DO              reduce using rule 47 (vardefinition -> arraydefinition .)
    COLON           reduce using rule 47 (vardefinition -> arraydefinition .)


state 42

    (28) iftype -> IF . forloop_condition
    (43) forloop_condition -> . LBRACE booleanexp RBRACE
    (44) forloop_condition -> . identifier
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID

    LBRACE          shift and go to state 106
    PRIVATE_ID      shift and go to state 82
    GLOBAL_ID       shift and go to state 83

    forloop_condition              shift and go to state 105
    identifier                     shift and go to state 107

state 43

    (35) whiletype -> WHILE . forloop_condition
    (43) forloop_condition -> . LBRACE booleanexp RBRACE
    (44) forloop_condition -> . identifier
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID

    LBRACE          shift and go to state 106
    PRIVATE_ID      shift and go to state 82
    GLOBAL_ID       shift and go to state 83

    forloop_condition              shift and go to state 108
    identifier                     shift and go to state 107

state 44

    (39) fortype -> FOR . new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> FOR . new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> FOR . new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (74) new_scope -> .

    LSPAREN         reduce using rule 74 (new_scope -> .)
    STRING_SINGLE   reduce using rule 74 (new_scope -> .)
    STRING_DOUBLE   reduce using rule 74 (new_scope -> .)

    new_scope                      shift and go to state 109

state 45

    (75) array -> LSPAREN . RSPAREN
    (76) array -> LSPAREN . arrayelement RSPAREN
    (77) arrayelement -> . primaryexp
    (78) arrayelement -> . primaryexp COMMA arrayelement
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (32) withtype -> . WITH NAMESPACE
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (53) arraydefinition -> . PRIVATE stringarray

    RSPAREN         shift and go to state 110
    LPAREN          shift and go to state 33
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    PRIVATE_ID      shift and go to state 82
    GLOBAL_ID       shift and go to state 83
    LSPAREN         shift and go to state 45
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    NULAR_FNC       shift and go to state 19
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    LBRACE          shift and go to state 34
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    WITH            shift and go to state 52
    PRIVATE         shift and go to state 35

    arrayelement                   shift and go to state 111
    primaryexp                     shift and go to state 112
    number                         shift and go to state 39
    identifier                     shift and go to state 77
    helpertype                     shift and go to state 40
    array                          shift and go to state 31
    unaryexp                       shift and go to state 78
    nularexp                       shift and go to state 79
    string                         shift and go to state 37
    binaryexp                      shift and go to state 80
    bracedexp                      shift and go to state 81
    iftype                         shift and go to state 84
    whiletype                      shift and go to state 85
    fortype                        shift and go to state 86
    withtype                       shift and go to state 87
    vardefinition                  shift and go to state 25
    definition                     shift and go to state 88
    arraydefinition                shift and go to state 41

state 46

    (33) withstatementinit -> withtype . DO
    (20) helpertype -> withtype .

    DO              shift and go to state 113
    BINARY_FNC      reduce using rule 20 (helpertype -> withtype .)
    LT              reduce using rule 20 (helpertype -> withtype .)
    GT              reduce using rule 20 (helpertype -> withtype .)
    LTE             reduce using rule 20 (helpertype -> withtype .)
    GTE             reduce using rule 20 (helpertype -> withtype .)
    EQUALITY        reduce using rule 20 (helpertype -> withtype .)
    INEQUALITY      reduce using rule 20 (helpertype -> withtype .)
    AND             reduce using rule 20 (helpertype -> withtype .)
    OR              reduce using rule 20 (helpertype -> withtype .)
    PLUS            reduce using rule 20 (helpertype -> withtype .)
    MINUS           reduce using rule 20 (helpertype -> withtype .)
    TIMES           reduce using rule 20 (helpertype -> withtype .)
    DIVIDE          reduce using rule 20 (helpertype -> withtype .)
    MOD             reduce using rule 20 (helpertype -> withtype .)
    POW             reduce using rule 20 (helpertype -> withtype .)


state 47

    (109) number -> NUMBER_REAL .

    BINARY_FNC      reduce using rule 109 (number -> NUMBER_REAL .)
    LT              reduce using rule 109 (number -> NUMBER_REAL .)
    GT              reduce using rule 109 (number -> NUMBER_REAL .)
    LTE             reduce using rule 109 (number -> NUMBER_REAL .)
    GTE             reduce using rule 109 (number -> NUMBER_REAL .)
    EQUALITY        reduce using rule 109 (number -> NUMBER_REAL .)
    INEQUALITY      reduce using rule 109 (number -> NUMBER_REAL .)
    AND             reduce using rule 109 (number -> NUMBER_REAL .)
    OR              reduce using rule 109 (number -> NUMBER_REAL .)
    PLUS            reduce using rule 109 (number -> NUMBER_REAL .)
    MINUS           reduce using rule 109 (number -> NUMBER_REAL .)
    TIMES           reduce using rule 109 (number -> NUMBER_REAL .)
    DIVIDE          reduce using rule 109 (number -> NUMBER_REAL .)
    MOD             reduce using rule 109 (number -> NUMBER_REAL .)
    POW             reduce using rule 109 (number -> NUMBER_REAL .)
    SEMI_COLON      reduce using rule 109 (number -> NUMBER_REAL .)
    COMMA           reduce using rule 109 (number -> NUMBER_REAL .)
    $end            reduce using rule 109 (number -> NUMBER_REAL .)
    RBRACE          reduce using rule 109 (number -> NUMBER_REAL .)
    RSPAREN         reduce using rule 109 (number -> NUMBER_REAL .)
    RPAREN          reduce using rule 109 (number -> NUMBER_REAL .)
    TO              reduce using rule 109 (number -> NUMBER_REAL .)
    STEP            reduce using rule 109 (number -> NUMBER_REAL .)
    DO              reduce using rule 109 (number -> NUMBER_REAL .)
    COLON           reduce using rule 109 (number -> NUMBER_REAL .)


state 48

    (110) number -> NUMBER_EXP .

    BINARY_FNC      reduce using rule 110 (number -> NUMBER_EXP .)
    LT              reduce using rule 110 (number -> NUMBER_EXP .)
    GT              reduce using rule 110 (number -> NUMBER_EXP .)
    LTE             reduce using rule 110 (number -> NUMBER_EXP .)
    GTE             reduce using rule 110 (number -> NUMBER_EXP .)
    EQUALITY        reduce using rule 110 (number -> NUMBER_EXP .)
    INEQUALITY      reduce using rule 110 (number -> NUMBER_EXP .)
    AND             reduce using rule 110 (number -> NUMBER_EXP .)
    OR              reduce using rule 110 (number -> NUMBER_EXP .)
    PLUS            reduce using rule 110 (number -> NUMBER_EXP .)
    MINUS           reduce using rule 110 (number -> NUMBER_EXP .)
    TIMES           reduce using rule 110 (number -> NUMBER_EXP .)
    DIVIDE          reduce using rule 110 (number -> NUMBER_EXP .)
    MOD             reduce using rule 110 (number -> NUMBER_EXP .)
    POW             reduce using rule 110 (number -> NUMBER_EXP .)
    SEMI_COLON      reduce using rule 110 (number -> NUMBER_EXP .)
    COMMA           reduce using rule 110 (number -> NUMBER_EXP .)
    $end            reduce using rule 110 (number -> NUMBER_EXP .)
    RBRACE          reduce using rule 110 (number -> NUMBER_EXP .)
    RSPAREN         reduce using rule 110 (number -> NUMBER_EXP .)
    RPAREN          reduce using rule 110 (number -> NUMBER_EXP .)
    TO              reduce using rule 110 (number -> NUMBER_EXP .)
    STEP            reduce using rule 110 (number -> NUMBER_EXP .)
    DO              reduce using rule 110 (number -> NUMBER_EXP .)
    COLON           reduce using rule 110 (number -> NUMBER_EXP .)


state 49

    (111) number -> NUMBER_HEX .

    BINARY_FNC      reduce using rule 111 (number -> NUMBER_HEX .)
    LT              reduce using rule 111 (number -> NUMBER_HEX .)
    GT              reduce using rule 111 (number -> NUMBER_HEX .)
    LTE             reduce using rule 111 (number -> NUMBER_HEX .)
    GTE             reduce using rule 111 (number -> NUMBER_HEX .)
    EQUALITY        reduce using rule 111 (number -> NUMBER_HEX .)
    INEQUALITY      reduce using rule 111 (number -> NUMBER_HEX .)
    AND             reduce using rule 111 (number -> NUMBER_HEX .)
    OR              reduce using rule 111 (number -> NUMBER_HEX .)
    PLUS            reduce using rule 111 (number -> NUMBER_HEX .)
    MINUS           reduce using rule 111 (number -> NUMBER_HEX .)
    TIMES           reduce using rule 111 (number -> NUMBER_HEX .)
    DIVIDE          reduce using rule 111 (number -> NUMBER_HEX .)
    MOD             reduce using rule 111 (number -> NUMBER_HEX .)
    POW             reduce using rule 111 (number -> NUMBER_HEX .)
    SEMI_COLON      reduce using rule 111 (number -> NUMBER_HEX .)
    COMMA           reduce using rule 111 (number -> NUMBER_HEX .)
    $end            reduce using rule 111 (number -> NUMBER_HEX .)
    RBRACE          reduce using rule 111 (number -> NUMBER_HEX .)
    RSPAREN         reduce using rule 111 (number -> NUMBER_HEX .)
    RPAREN          reduce using rule 111 (number -> NUMBER_HEX .)
    TO              reduce using rule 111 (number -> NUMBER_HEX .)
    STEP            reduce using rule 111 (number -> NUMBER_HEX .)
    DO              reduce using rule 111 (number -> NUMBER_HEX .)
    COLON           reduce using rule 111 (number -> NUMBER_HEX .)


state 50

    (112) string -> STRING_SINGLE .

    BINARY_FNC      reduce using rule 112 (string -> STRING_SINGLE .)
    LT              reduce using rule 112 (string -> STRING_SINGLE .)
    GT              reduce using rule 112 (string -> STRING_SINGLE .)
    LTE             reduce using rule 112 (string -> STRING_SINGLE .)
    GTE             reduce using rule 112 (string -> STRING_SINGLE .)
    EQUALITY        reduce using rule 112 (string -> STRING_SINGLE .)
    INEQUALITY      reduce using rule 112 (string -> STRING_SINGLE .)
    AND             reduce using rule 112 (string -> STRING_SINGLE .)
    OR              reduce using rule 112 (string -> STRING_SINGLE .)
    PLUS            reduce using rule 112 (string -> STRING_SINGLE .)
    MINUS           reduce using rule 112 (string -> STRING_SINGLE .)
    TIMES           reduce using rule 112 (string -> STRING_SINGLE .)
    DIVIDE          reduce using rule 112 (string -> STRING_SINGLE .)
    MOD             reduce using rule 112 (string -> STRING_SINGLE .)
    POW             reduce using rule 112 (string -> STRING_SINGLE .)
    SEMI_COLON      reduce using rule 112 (string -> STRING_SINGLE .)
    COMMA           reduce using rule 112 (string -> STRING_SINGLE .)
    $end            reduce using rule 112 (string -> STRING_SINGLE .)
    RBRACE          reduce using rule 112 (string -> STRING_SINGLE .)
    RSPAREN         reduce using rule 112 (string -> STRING_SINGLE .)
    RPAREN          reduce using rule 112 (string -> STRING_SINGLE .)
    TO              reduce using rule 112 (string -> STRING_SINGLE .)
    STEP            reduce using rule 112 (string -> STRING_SINGLE .)
    DO              reduce using rule 112 (string -> STRING_SINGLE .)
    COLON           reduce using rule 112 (string -> STRING_SINGLE .)
    EQUAL           reduce using rule 112 (string -> STRING_SINGLE .)
    FROM            reduce using rule 112 (string -> STRING_SINGLE .)


state 51

    (113) string -> STRING_DOUBLE .

    BINARY_FNC      reduce using rule 113 (string -> STRING_DOUBLE .)
    LT              reduce using rule 113 (string -> STRING_DOUBLE .)
    GT              reduce using rule 113 (string -> STRING_DOUBLE .)
    LTE             reduce using rule 113 (string -> STRING_DOUBLE .)
    GTE             reduce using rule 113 (string -> STRING_DOUBLE .)
    EQUALITY        reduce using rule 113 (string -> STRING_DOUBLE .)
    INEQUALITY      reduce using rule 113 (string -> STRING_DOUBLE .)
    AND             reduce using rule 113 (string -> STRING_DOUBLE .)
    OR              reduce using rule 113 (string -> STRING_DOUBLE .)
    PLUS            reduce using rule 113 (string -> STRING_DOUBLE .)
    MINUS           reduce using rule 113 (string -> STRING_DOUBLE .)
    TIMES           reduce using rule 113 (string -> STRING_DOUBLE .)
    DIVIDE          reduce using rule 113 (string -> STRING_DOUBLE .)
    MOD             reduce using rule 113 (string -> STRING_DOUBLE .)
    POW             reduce using rule 113 (string -> STRING_DOUBLE .)
    SEMI_COLON      reduce using rule 113 (string -> STRING_DOUBLE .)
    COMMA           reduce using rule 113 (string -> STRING_DOUBLE .)
    $end            reduce using rule 113 (string -> STRING_DOUBLE .)
    RBRACE          reduce using rule 113 (string -> STRING_DOUBLE .)
    RSPAREN         reduce using rule 113 (string -> STRING_DOUBLE .)
    RPAREN          reduce using rule 113 (string -> STRING_DOUBLE .)
    TO              reduce using rule 113 (string -> STRING_DOUBLE .)
    STEP            reduce using rule 113 (string -> STRING_DOUBLE .)
    DO              reduce using rule 113 (string -> STRING_DOUBLE .)
    COLON           reduce using rule 113 (string -> STRING_DOUBLE .)
    EQUAL           reduce using rule 113 (string -> STRING_DOUBLE .)
    FROM            reduce using rule 113 (string -> STRING_DOUBLE .)


state 52

    (32) withtype -> WITH . NAMESPACE

    NAMESPACE       shift and go to state 114


state 53

    (3) code -> statement terminator . code
    (1) code -> . empty
    (2) code -> . statement
    (3) code -> . statement terminator code
    (114) empty -> .
    (4) statement -> . controlstructure
    (5) statement -> . assignment
    (6) statement -> . binaryexp
    (7) statement -> . nularexp
    (8) statement -> . unaryexp
    (11) controlstructure -> . ifstatement
    (12) controlstructure -> . whileloop
    (13) controlstructure -> . forloop
    (14) controlstructure -> . withstatement
    (15) controlstructure -> . foreachloop
    (16) controlstructure -> . switchstatement
    (48) assignment -> . assignment_code code RBRACE
    (49) assignment -> . definition EQUAL primaryexp
    (50) assignment -> . variable EQUAL primaryexp
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (29) ifstatement -> . iftype THEN bracedexp
    (30) ifstatement -> . iftype EXITWITH bracedexp
    (31) ifstatement -> . iftype THEN bracedexp ELSE bracedexp
    (36) whileloop -> . whiletype DO bracedexp
    (42) forloop -> . fortype DO bracedexp_noscope
    (34) withstatement -> . withstatementinit bracedexp
    (37) foreachloop -> . bracedexp FOREACH array
    (38) foreachloop -> . bracedexp FOREACH primaryexp
    (24) switchstatement -> . SWITCH LPAREN primaryexp RPAREN DO LBRACE switchbody RBRACE
    (51) assignment_code -> . definition EQUAL LBRACE
    (52) assignment_code -> . variable EQUAL LBRACE
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (58) variable -> . PRIVATE_ID
    (59) variable -> . GLOBAL_ID
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (33) withstatementinit -> . withtype DO
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (53) arraydefinition -> . PRIVATE stringarray
    (32) withtype -> . WITH NAMESPACE

    $end            reduce using rule 114 (empty -> .)
    RBRACE          reduce using rule 114 (empty -> .)
    NULAR_FNC       shift and go to state 19
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    SWITCH          shift and go to state 32
    PRIVATE         shift and go to state 35
    PRIVATE_ID      shift and go to state 36
    GLOBAL_ID       shift and go to state 38
    LPAREN          shift and go to state 33
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    LBRACE          shift and go to state 34
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    LSPAREN         shift and go to state 45
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    WITH            shift and go to state 52

    statement                      shift and go to state 3
    code                           shift and go to state 115
    empty                          shift and go to state 2
    controlstructure               shift and go to state 4
    assignment                     shift and go to state 5
    binaryexp                      shift and go to state 6
    nularexp                       shift and go to state 7
    unaryexp                       shift and go to state 8
    ifstatement                    shift and go to state 9
    whileloop                      shift and go to state 10
    forloop                        shift and go to state 11
    withstatement                  shift and go to state 12
    foreachloop                    shift and go to state 13
    switchstatement                shift and go to state 14
    assignment_code                shift and go to state 15
    definition                     shift and go to state 16
    primaryexp                     shift and go to state 17
    variable                       shift and go to state 18
    identifier                     shift and go to state 20
    vardefinition                  shift and go to state 25
    iftype                         shift and go to state 26
    bracedexp                      shift and go to state 27
    whiletype                      shift and go to state 28
    fortype                        shift and go to state 29
    withstatementinit              shift and go to state 30
    array                          shift and go to state 31
    string                         shift and go to state 37
    number                         shift and go to state 39
    helpertype                     shift and go to state 40
    arraydefinition                shift and go to state 41
    withtype                       shift and go to state 46

state 54

    (9) terminator -> SEMI_COLON .

    NULAR_FNC       reduce using rule 9 (terminator -> SEMI_COLON .)
    UNARY_FNC       reduce using rule 9 (terminator -> SEMI_COLON .)
    PLUS            reduce using rule 9 (terminator -> SEMI_COLON .)
    MINUS           reduce using rule 9 (terminator -> SEMI_COLON .)
    NOT             reduce using rule 9 (terminator -> SEMI_COLON .)
    SWITCH          reduce using rule 9 (terminator -> SEMI_COLON .)
    PRIVATE         reduce using rule 9 (terminator -> SEMI_COLON .)
    PRIVATE_ID      reduce using rule 9 (terminator -> SEMI_COLON .)
    GLOBAL_ID       reduce using rule 9 (terminator -> SEMI_COLON .)
    LPAREN          reduce using rule 9 (terminator -> SEMI_COLON .)
    IF              reduce using rule 9 (terminator -> SEMI_COLON .)
    WHILE           reduce using rule 9 (terminator -> SEMI_COLON .)
    FOR             reduce using rule 9 (terminator -> SEMI_COLON .)
    LBRACE          reduce using rule 9 (terminator -> SEMI_COLON .)
    NUMBER_REAL     reduce using rule 9 (terminator -> SEMI_COLON .)
    NUMBER_EXP      reduce using rule 9 (terminator -> SEMI_COLON .)
    NUMBER_HEX      reduce using rule 9 (terminator -> SEMI_COLON .)
    LSPAREN         reduce using rule 9 (terminator -> SEMI_COLON .)
    STRING_SINGLE   reduce using rule 9 (terminator -> SEMI_COLON .)
    STRING_DOUBLE   reduce using rule 9 (terminator -> SEMI_COLON .)
    WITH            reduce using rule 9 (terminator -> SEMI_COLON .)
    $end            reduce using rule 9 (terminator -> SEMI_COLON .)
    RBRACE          reduce using rule 9 (terminator -> SEMI_COLON .)
    CASE            reduce using rule 9 (terminator -> SEMI_COLON .)
    DEFAULT         reduce using rule 9 (terminator -> SEMI_COLON .)


state 55

    (10) terminator -> COMMA .

    NULAR_FNC       reduce using rule 10 (terminator -> COMMA .)
    UNARY_FNC       reduce using rule 10 (terminator -> COMMA .)
    PLUS            reduce using rule 10 (terminator -> COMMA .)
    MINUS           reduce using rule 10 (terminator -> COMMA .)
    NOT             reduce using rule 10 (terminator -> COMMA .)
    SWITCH          reduce using rule 10 (terminator -> COMMA .)
    PRIVATE         reduce using rule 10 (terminator -> COMMA .)
    PRIVATE_ID      reduce using rule 10 (terminator -> COMMA .)
    GLOBAL_ID       reduce using rule 10 (terminator -> COMMA .)
    LPAREN          reduce using rule 10 (terminator -> COMMA .)
    IF              reduce using rule 10 (terminator -> COMMA .)
    WHILE           reduce using rule 10 (terminator -> COMMA .)
    FOR             reduce using rule 10 (terminator -> COMMA .)
    LBRACE          reduce using rule 10 (terminator -> COMMA .)
    NUMBER_REAL     reduce using rule 10 (terminator -> COMMA .)
    NUMBER_EXP      reduce using rule 10 (terminator -> COMMA .)
    NUMBER_HEX      reduce using rule 10 (terminator -> COMMA .)
    LSPAREN         reduce using rule 10 (terminator -> COMMA .)
    STRING_SINGLE   reduce using rule 10 (terminator -> COMMA .)
    STRING_DOUBLE   reduce using rule 10 (terminator -> COMMA .)
    WITH            reduce using rule 10 (terminator -> COMMA .)
    $end            reduce using rule 10 (terminator -> COMMA .)
    RBRACE          reduce using rule 10 (terminator -> COMMA .)
    CASE            reduce using rule 10 (terminator -> COMMA .)
    DEFAULT         reduce using rule 10 (terminator -> COMMA .)


state 56

    (48) assignment -> assignment_code code . RBRACE

    RBRACE          shift and go to state 116


state 57

    (49) assignment -> definition EQUAL . primaryexp
    (51) assignment_code -> definition EQUAL . LBRACE
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (32) withtype -> . WITH NAMESPACE
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (53) arraydefinition -> . PRIVATE stringarray

    LBRACE          shift and go to state 118
    LPAREN          shift and go to state 33
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    PRIVATE_ID      shift and go to state 82
    GLOBAL_ID       shift and go to state 83
    LSPAREN         shift and go to state 45
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    NULAR_FNC       shift and go to state 19
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    WITH            shift and go to state 52
    PRIVATE         shift and go to state 35

    definition                     shift and go to state 88
    primaryexp                     shift and go to state 117
    number                         shift and go to state 39
    identifier                     shift and go to state 77
    helpertype                     shift and go to state 40
    array                          shift and go to state 31
    unaryexp                       shift and go to state 78
    nularexp                       shift and go to state 79
    string                         shift and go to state 37
    binaryexp                      shift and go to state 80
    bracedexp                      shift and go to state 81
    iftype                         shift and go to state 84
    whiletype                      shift and go to state 85
    fortype                        shift and go to state 86
    withtype                       shift and go to state 87
    vardefinition                  shift and go to state 25
    arraydefinition                shift and go to state 41

state 58

    (60) binaryexp -> primaryexp BINARY_FNC . primaryexp
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (32) withtype -> . WITH NAMESPACE
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (53) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 33
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    PRIVATE_ID      shift and go to state 82
    GLOBAL_ID       shift and go to state 83
    LSPAREN         shift and go to state 45
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    NULAR_FNC       shift and go to state 19
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    LBRACE          shift and go to state 34
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    WITH            shift and go to state 52
    PRIVATE         shift and go to state 35

    primaryexp                     shift and go to state 119
    number                         shift and go to state 39
    identifier                     shift and go to state 77
    helpertype                     shift and go to state 40
    array                          shift and go to state 31
    unaryexp                       shift and go to state 78
    nularexp                       shift and go to state 79
    string                         shift and go to state 37
    binaryexp                      shift and go to state 80
    bracedexp                      shift and go to state 81
    iftype                         shift and go to state 84
    whiletype                      shift and go to state 85
    fortype                        shift and go to state 86
    withtype                       shift and go to state 87
    vardefinition                  shift and go to state 25
    definition                     shift and go to state 88
    arraydefinition                shift and go to state 41

state 59

    (61) binaryexp -> primaryexp comparisonoperator . primaryexp
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (32) withtype -> . WITH NAMESPACE
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (53) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 33
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    PRIVATE_ID      shift and go to state 82
    GLOBAL_ID       shift and go to state 83
    LSPAREN         shift and go to state 45
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    NULAR_FNC       shift and go to state 19
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    LBRACE          shift and go to state 34
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    WITH            shift and go to state 52
    PRIVATE         shift and go to state 35

    primaryexp                     shift and go to state 120
    number                         shift and go to state 39
    identifier                     shift and go to state 77
    helpertype                     shift and go to state 40
    array                          shift and go to state 31
    unaryexp                       shift and go to state 78
    nularexp                       shift and go to state 79
    string                         shift and go to state 37
    binaryexp                      shift and go to state 80
    bracedexp                      shift and go to state 81
    iftype                         shift and go to state 84
    whiletype                      shift and go to state 85
    fortype                        shift and go to state 86
    withtype                       shift and go to state 87
    vardefinition                  shift and go to state 25
    definition                     shift and go to state 88
    arraydefinition                shift and go to state 41

state 60

    (62) binaryexp -> primaryexp mathoperator . primaryexp
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (32) withtype -> . WITH NAMESPACE
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (53) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 33
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    PRIVATE_ID      shift and go to state 82
    GLOBAL_ID       shift and go to state 83
    LSPAREN         shift and go to state 45
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    NULAR_FNC       shift and go to state 19
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    LBRACE          shift and go to state 34
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    WITH            shift and go to state 52
    PRIVATE         shift and go to state 35

    primaryexp                     shift and go to state 121
    number                         shift and go to state 39
    identifier                     shift and go to state 77
    helpertype                     shift and go to state 40
    array                          shift and go to state 31
    unaryexp                       shift and go to state 78
    nularexp                       shift and go to state 79
    string                         shift and go to state 37
    binaryexp                      shift and go to state 80
    bracedexp                      shift and go to state 81
    iftype                         shift and go to state 84
    whiletype                      shift and go to state 85
    fortype                        shift and go to state 86
    withtype                       shift and go to state 87
    vardefinition                  shift and go to state 25
    definition                     shift and go to state 88
    arraydefinition                shift and go to state 41

state 61

    (90) comparisonoperator -> LT .

    LPAREN          reduce using rule 90 (comparisonoperator -> LT .)
    NUMBER_REAL     reduce using rule 90 (comparisonoperator -> LT .)
    NUMBER_EXP      reduce using rule 90 (comparisonoperator -> LT .)
    NUMBER_HEX      reduce using rule 90 (comparisonoperator -> LT .)
    PRIVATE_ID      reduce using rule 90 (comparisonoperator -> LT .)
    GLOBAL_ID       reduce using rule 90 (comparisonoperator -> LT .)
    LSPAREN         reduce using rule 90 (comparisonoperator -> LT .)
    UNARY_FNC       reduce using rule 90 (comparisonoperator -> LT .)
    PLUS            reduce using rule 90 (comparisonoperator -> LT .)
    MINUS           reduce using rule 90 (comparisonoperator -> LT .)
    NOT             reduce using rule 90 (comparisonoperator -> LT .)
    NULAR_FNC       reduce using rule 90 (comparisonoperator -> LT .)
    STRING_SINGLE   reduce using rule 90 (comparisonoperator -> LT .)
    STRING_DOUBLE   reduce using rule 90 (comparisonoperator -> LT .)
    LBRACE          reduce using rule 90 (comparisonoperator -> LT .)
    IF              reduce using rule 90 (comparisonoperator -> LT .)
    WHILE           reduce using rule 90 (comparisonoperator -> LT .)
    FOR             reduce using rule 90 (comparisonoperator -> LT .)
    WITH            reduce using rule 90 (comparisonoperator -> LT .)
    PRIVATE         reduce using rule 90 (comparisonoperator -> LT .)


state 62

    (91) comparisonoperator -> GT .

    LPAREN          reduce using rule 91 (comparisonoperator -> GT .)
    NUMBER_REAL     reduce using rule 91 (comparisonoperator -> GT .)
    NUMBER_EXP      reduce using rule 91 (comparisonoperator -> GT .)
    NUMBER_HEX      reduce using rule 91 (comparisonoperator -> GT .)
    PRIVATE_ID      reduce using rule 91 (comparisonoperator -> GT .)
    GLOBAL_ID       reduce using rule 91 (comparisonoperator -> GT .)
    LSPAREN         reduce using rule 91 (comparisonoperator -> GT .)
    UNARY_FNC       reduce using rule 91 (comparisonoperator -> GT .)
    PLUS            reduce using rule 91 (comparisonoperator -> GT .)
    MINUS           reduce using rule 91 (comparisonoperator -> GT .)
    NOT             reduce using rule 91 (comparisonoperator -> GT .)
    NULAR_FNC       reduce using rule 91 (comparisonoperator -> GT .)
    STRING_SINGLE   reduce using rule 91 (comparisonoperator -> GT .)
    STRING_DOUBLE   reduce using rule 91 (comparisonoperator -> GT .)
    LBRACE          reduce using rule 91 (comparisonoperator -> GT .)
    IF              reduce using rule 91 (comparisonoperator -> GT .)
    WHILE           reduce using rule 91 (comparisonoperator -> GT .)
    FOR             reduce using rule 91 (comparisonoperator -> GT .)
    WITH            reduce using rule 91 (comparisonoperator -> GT .)
    PRIVATE         reduce using rule 91 (comparisonoperator -> GT .)


state 63

    (92) comparisonoperator -> LTE .

    LPAREN          reduce using rule 92 (comparisonoperator -> LTE .)
    NUMBER_REAL     reduce using rule 92 (comparisonoperator -> LTE .)
    NUMBER_EXP      reduce using rule 92 (comparisonoperator -> LTE .)
    NUMBER_HEX      reduce using rule 92 (comparisonoperator -> LTE .)
    PRIVATE_ID      reduce using rule 92 (comparisonoperator -> LTE .)
    GLOBAL_ID       reduce using rule 92 (comparisonoperator -> LTE .)
    LSPAREN         reduce using rule 92 (comparisonoperator -> LTE .)
    UNARY_FNC       reduce using rule 92 (comparisonoperator -> LTE .)
    PLUS            reduce using rule 92 (comparisonoperator -> LTE .)
    MINUS           reduce using rule 92 (comparisonoperator -> LTE .)
    NOT             reduce using rule 92 (comparisonoperator -> LTE .)
    NULAR_FNC       reduce using rule 92 (comparisonoperator -> LTE .)
    STRING_SINGLE   reduce using rule 92 (comparisonoperator -> LTE .)
    STRING_DOUBLE   reduce using rule 92 (comparisonoperator -> LTE .)
    LBRACE          reduce using rule 92 (comparisonoperator -> LTE .)
    IF              reduce using rule 92 (comparisonoperator -> LTE .)
    WHILE           reduce using rule 92 (comparisonoperator -> LTE .)
    FOR             reduce using rule 92 (comparisonoperator -> LTE .)
    WITH            reduce using rule 92 (comparisonoperator -> LTE .)
    PRIVATE         reduce using rule 92 (comparisonoperator -> LTE .)


state 64

    (93) comparisonoperator -> GTE .

    LPAREN          reduce using rule 93 (comparisonoperator -> GTE .)
    NUMBER_REAL     reduce using rule 93 (comparisonoperator -> GTE .)
    NUMBER_EXP      reduce using rule 93 (comparisonoperator -> GTE .)
    NUMBER_HEX      reduce using rule 93 (comparisonoperator -> GTE .)
    PRIVATE_ID      reduce using rule 93 (comparisonoperator -> GTE .)
    GLOBAL_ID       reduce using rule 93 (comparisonoperator -> GTE .)
    LSPAREN         reduce using rule 93 (comparisonoperator -> GTE .)
    UNARY_FNC       reduce using rule 93 (comparisonoperator -> GTE .)
    PLUS            reduce using rule 93 (comparisonoperator -> GTE .)
    MINUS           reduce using rule 93 (comparisonoperator -> GTE .)
    NOT             reduce using rule 93 (comparisonoperator -> GTE .)
    NULAR_FNC       reduce using rule 93 (comparisonoperator -> GTE .)
    STRING_SINGLE   reduce using rule 93 (comparisonoperator -> GTE .)
    STRING_DOUBLE   reduce using rule 93 (comparisonoperator -> GTE .)
    LBRACE          reduce using rule 93 (comparisonoperator -> GTE .)
    IF              reduce using rule 93 (comparisonoperator -> GTE .)
    WHILE           reduce using rule 93 (comparisonoperator -> GTE .)
    FOR             reduce using rule 93 (comparisonoperator -> GTE .)
    WITH            reduce using rule 93 (comparisonoperator -> GTE .)
    PRIVATE         reduce using rule 93 (comparisonoperator -> GTE .)


state 65

    (94) comparisonoperator -> EQUALITY .

    LPAREN          reduce using rule 94 (comparisonoperator -> EQUALITY .)
    NUMBER_REAL     reduce using rule 94 (comparisonoperator -> EQUALITY .)
    NUMBER_EXP      reduce using rule 94 (comparisonoperator -> EQUALITY .)
    NUMBER_HEX      reduce using rule 94 (comparisonoperator -> EQUALITY .)
    PRIVATE_ID      reduce using rule 94 (comparisonoperator -> EQUALITY .)
    GLOBAL_ID       reduce using rule 94 (comparisonoperator -> EQUALITY .)
    LSPAREN         reduce using rule 94 (comparisonoperator -> EQUALITY .)
    UNARY_FNC       reduce using rule 94 (comparisonoperator -> EQUALITY .)
    PLUS            reduce using rule 94 (comparisonoperator -> EQUALITY .)
    MINUS           reduce using rule 94 (comparisonoperator -> EQUALITY .)
    NOT             reduce using rule 94 (comparisonoperator -> EQUALITY .)
    NULAR_FNC       reduce using rule 94 (comparisonoperator -> EQUALITY .)
    STRING_SINGLE   reduce using rule 94 (comparisonoperator -> EQUALITY .)
    STRING_DOUBLE   reduce using rule 94 (comparisonoperator -> EQUALITY .)
    LBRACE          reduce using rule 94 (comparisonoperator -> EQUALITY .)
    IF              reduce using rule 94 (comparisonoperator -> EQUALITY .)
    WHILE           reduce using rule 94 (comparisonoperator -> EQUALITY .)
    FOR             reduce using rule 94 (comparisonoperator -> EQUALITY .)
    WITH            reduce using rule 94 (comparisonoperator -> EQUALITY .)
    PRIVATE         reduce using rule 94 (comparisonoperator -> EQUALITY .)


state 66

    (95) comparisonoperator -> INEQUALITY .

    LPAREN          reduce using rule 95 (comparisonoperator -> INEQUALITY .)
    NUMBER_REAL     reduce using rule 95 (comparisonoperator -> INEQUALITY .)
    NUMBER_EXP      reduce using rule 95 (comparisonoperator -> INEQUALITY .)
    NUMBER_HEX      reduce using rule 95 (comparisonoperator -> INEQUALITY .)
    PRIVATE_ID      reduce using rule 95 (comparisonoperator -> INEQUALITY .)
    GLOBAL_ID       reduce using rule 95 (comparisonoperator -> INEQUALITY .)
    LSPAREN         reduce using rule 95 (comparisonoperator -> INEQUALITY .)
    UNARY_FNC       reduce using rule 95 (comparisonoperator -> INEQUALITY .)
    PLUS            reduce using rule 95 (comparisonoperator -> INEQUALITY .)
    MINUS           reduce using rule 95 (comparisonoperator -> INEQUALITY .)
    NOT             reduce using rule 95 (comparisonoperator -> INEQUALITY .)
    NULAR_FNC       reduce using rule 95 (comparisonoperator -> INEQUALITY .)
    STRING_SINGLE   reduce using rule 95 (comparisonoperator -> INEQUALITY .)
    STRING_DOUBLE   reduce using rule 95 (comparisonoperator -> INEQUALITY .)
    LBRACE          reduce using rule 95 (comparisonoperator -> INEQUALITY .)
    IF              reduce using rule 95 (comparisonoperator -> INEQUALITY .)
    WHILE           reduce using rule 95 (comparisonoperator -> INEQUALITY .)
    FOR             reduce using rule 95 (comparisonoperator -> INEQUALITY .)
    WITH            reduce using rule 95 (comparisonoperator -> INEQUALITY .)
    PRIVATE         reduce using rule 95 (comparisonoperator -> INEQUALITY .)


state 67

    (96) comparisonoperator -> AND .

    LPAREN          reduce using rule 96 (comparisonoperator -> AND .)
    NUMBER_REAL     reduce using rule 96 (comparisonoperator -> AND .)
    NUMBER_EXP      reduce using rule 96 (comparisonoperator -> AND .)
    NUMBER_HEX      reduce using rule 96 (comparisonoperator -> AND .)
    PRIVATE_ID      reduce using rule 96 (comparisonoperator -> AND .)
    GLOBAL_ID       reduce using rule 96 (comparisonoperator -> AND .)
    LSPAREN         reduce using rule 96 (comparisonoperator -> AND .)
    UNARY_FNC       reduce using rule 96 (comparisonoperator -> AND .)
    PLUS            reduce using rule 96 (comparisonoperator -> AND .)
    MINUS           reduce using rule 96 (comparisonoperator -> AND .)
    NOT             reduce using rule 96 (comparisonoperator -> AND .)
    NULAR_FNC       reduce using rule 96 (comparisonoperator -> AND .)
    STRING_SINGLE   reduce using rule 96 (comparisonoperator -> AND .)
    STRING_DOUBLE   reduce using rule 96 (comparisonoperator -> AND .)
    LBRACE          reduce using rule 96 (comparisonoperator -> AND .)
    IF              reduce using rule 96 (comparisonoperator -> AND .)
    WHILE           reduce using rule 96 (comparisonoperator -> AND .)
    FOR             reduce using rule 96 (comparisonoperator -> AND .)
    WITH            reduce using rule 96 (comparisonoperator -> AND .)
    PRIVATE         reduce using rule 96 (comparisonoperator -> AND .)


state 68

    (97) comparisonoperator -> OR .

    LPAREN          reduce using rule 97 (comparisonoperator -> OR .)
    NUMBER_REAL     reduce using rule 97 (comparisonoperator -> OR .)
    NUMBER_EXP      reduce using rule 97 (comparisonoperator -> OR .)
    NUMBER_HEX      reduce using rule 97 (comparisonoperator -> OR .)
    PRIVATE_ID      reduce using rule 97 (comparisonoperator -> OR .)
    GLOBAL_ID       reduce using rule 97 (comparisonoperator -> OR .)
    LSPAREN         reduce using rule 97 (comparisonoperator -> OR .)
    UNARY_FNC       reduce using rule 97 (comparisonoperator -> OR .)
    PLUS            reduce using rule 97 (comparisonoperator -> OR .)
    MINUS           reduce using rule 97 (comparisonoperator -> OR .)
    NOT             reduce using rule 97 (comparisonoperator -> OR .)
    NULAR_FNC       reduce using rule 97 (comparisonoperator -> OR .)
    STRING_SINGLE   reduce using rule 97 (comparisonoperator -> OR .)
    STRING_DOUBLE   reduce using rule 97 (comparisonoperator -> OR .)
    LBRACE          reduce using rule 97 (comparisonoperator -> OR .)
    IF              reduce using rule 97 (comparisonoperator -> OR .)
    WHILE           reduce using rule 97 (comparisonoperator -> OR .)
    FOR             reduce using rule 97 (comparisonoperator -> OR .)
    WITH            reduce using rule 97 (comparisonoperator -> OR .)
    PRIVATE         reduce using rule 97 (comparisonoperator -> OR .)


state 69

    (98) mathoperator -> PLUS .

    LPAREN          reduce using rule 98 (mathoperator -> PLUS .)
    NUMBER_REAL     reduce using rule 98 (mathoperator -> PLUS .)
    NUMBER_EXP      reduce using rule 98 (mathoperator -> PLUS .)
    NUMBER_HEX      reduce using rule 98 (mathoperator -> PLUS .)
    PRIVATE_ID      reduce using rule 98 (mathoperator -> PLUS .)
    GLOBAL_ID       reduce using rule 98 (mathoperator -> PLUS .)
    LSPAREN         reduce using rule 98 (mathoperator -> PLUS .)
    UNARY_FNC       reduce using rule 98 (mathoperator -> PLUS .)
    PLUS            reduce using rule 98 (mathoperator -> PLUS .)
    MINUS           reduce using rule 98 (mathoperator -> PLUS .)
    NOT             reduce using rule 98 (mathoperator -> PLUS .)
    NULAR_FNC       reduce using rule 98 (mathoperator -> PLUS .)
    STRING_SINGLE   reduce using rule 98 (mathoperator -> PLUS .)
    STRING_DOUBLE   reduce using rule 98 (mathoperator -> PLUS .)
    LBRACE          reduce using rule 98 (mathoperator -> PLUS .)
    IF              reduce using rule 98 (mathoperator -> PLUS .)
    WHILE           reduce using rule 98 (mathoperator -> PLUS .)
    FOR             reduce using rule 98 (mathoperator -> PLUS .)
    WITH            reduce using rule 98 (mathoperator -> PLUS .)
    PRIVATE         reduce using rule 98 (mathoperator -> PLUS .)


state 70

    (99) mathoperator -> MINUS .

    LPAREN          reduce using rule 99 (mathoperator -> MINUS .)
    NUMBER_REAL     reduce using rule 99 (mathoperator -> MINUS .)
    NUMBER_EXP      reduce using rule 99 (mathoperator -> MINUS .)
    NUMBER_HEX      reduce using rule 99 (mathoperator -> MINUS .)
    PRIVATE_ID      reduce using rule 99 (mathoperator -> MINUS .)
    GLOBAL_ID       reduce using rule 99 (mathoperator -> MINUS .)
    LSPAREN         reduce using rule 99 (mathoperator -> MINUS .)
    UNARY_FNC       reduce using rule 99 (mathoperator -> MINUS .)
    PLUS            reduce using rule 99 (mathoperator -> MINUS .)
    MINUS           reduce using rule 99 (mathoperator -> MINUS .)
    NOT             reduce using rule 99 (mathoperator -> MINUS .)
    NULAR_FNC       reduce using rule 99 (mathoperator -> MINUS .)
    STRING_SINGLE   reduce using rule 99 (mathoperator -> MINUS .)
    STRING_DOUBLE   reduce using rule 99 (mathoperator -> MINUS .)
    LBRACE          reduce using rule 99 (mathoperator -> MINUS .)
    IF              reduce using rule 99 (mathoperator -> MINUS .)
    WHILE           reduce using rule 99 (mathoperator -> MINUS .)
    FOR             reduce using rule 99 (mathoperator -> MINUS .)
    WITH            reduce using rule 99 (mathoperator -> MINUS .)
    PRIVATE         reduce using rule 99 (mathoperator -> MINUS .)


state 71

    (100) mathoperator -> TIMES .

    LPAREN          reduce using rule 100 (mathoperator -> TIMES .)
    NUMBER_REAL     reduce using rule 100 (mathoperator -> TIMES .)
    NUMBER_EXP      reduce using rule 100 (mathoperator -> TIMES .)
    NUMBER_HEX      reduce using rule 100 (mathoperator -> TIMES .)
    PRIVATE_ID      reduce using rule 100 (mathoperator -> TIMES .)
    GLOBAL_ID       reduce using rule 100 (mathoperator -> TIMES .)
    LSPAREN         reduce using rule 100 (mathoperator -> TIMES .)
    UNARY_FNC       reduce using rule 100 (mathoperator -> TIMES .)
    PLUS            reduce using rule 100 (mathoperator -> TIMES .)
    MINUS           reduce using rule 100 (mathoperator -> TIMES .)
    NOT             reduce using rule 100 (mathoperator -> TIMES .)
    NULAR_FNC       reduce using rule 100 (mathoperator -> TIMES .)
    STRING_SINGLE   reduce using rule 100 (mathoperator -> TIMES .)
    STRING_DOUBLE   reduce using rule 100 (mathoperator -> TIMES .)
    LBRACE          reduce using rule 100 (mathoperator -> TIMES .)
    IF              reduce using rule 100 (mathoperator -> TIMES .)
    WHILE           reduce using rule 100 (mathoperator -> TIMES .)
    FOR             reduce using rule 100 (mathoperator -> TIMES .)
    WITH            reduce using rule 100 (mathoperator -> TIMES .)
    PRIVATE         reduce using rule 100 (mathoperator -> TIMES .)


state 72

    (101) mathoperator -> DIVIDE .

    LPAREN          reduce using rule 101 (mathoperator -> DIVIDE .)
    NUMBER_REAL     reduce using rule 101 (mathoperator -> DIVIDE .)
    NUMBER_EXP      reduce using rule 101 (mathoperator -> DIVIDE .)
    NUMBER_HEX      reduce using rule 101 (mathoperator -> DIVIDE .)
    PRIVATE_ID      reduce using rule 101 (mathoperator -> DIVIDE .)
    GLOBAL_ID       reduce using rule 101 (mathoperator -> DIVIDE .)
    LSPAREN         reduce using rule 101 (mathoperator -> DIVIDE .)
    UNARY_FNC       reduce using rule 101 (mathoperator -> DIVIDE .)
    PLUS            reduce using rule 101 (mathoperator -> DIVIDE .)
    MINUS           reduce using rule 101 (mathoperator -> DIVIDE .)
    NOT             reduce using rule 101 (mathoperator -> DIVIDE .)
    NULAR_FNC       reduce using rule 101 (mathoperator -> DIVIDE .)
    STRING_SINGLE   reduce using rule 101 (mathoperator -> DIVIDE .)
    STRING_DOUBLE   reduce using rule 101 (mathoperator -> DIVIDE .)
    LBRACE          reduce using rule 101 (mathoperator -> DIVIDE .)
    IF              reduce using rule 101 (mathoperator -> DIVIDE .)
    WHILE           reduce using rule 101 (mathoperator -> DIVIDE .)
    FOR             reduce using rule 101 (mathoperator -> DIVIDE .)
    WITH            reduce using rule 101 (mathoperator -> DIVIDE .)
    PRIVATE         reduce using rule 101 (mathoperator -> DIVIDE .)


state 73

    (102) mathoperator -> MOD .

    LPAREN          reduce using rule 102 (mathoperator -> MOD .)
    NUMBER_REAL     reduce using rule 102 (mathoperator -> MOD .)
    NUMBER_EXP      reduce using rule 102 (mathoperator -> MOD .)
    NUMBER_HEX      reduce using rule 102 (mathoperator -> MOD .)
    PRIVATE_ID      reduce using rule 102 (mathoperator -> MOD .)
    GLOBAL_ID       reduce using rule 102 (mathoperator -> MOD .)
    LSPAREN         reduce using rule 102 (mathoperator -> MOD .)
    UNARY_FNC       reduce using rule 102 (mathoperator -> MOD .)
    PLUS            reduce using rule 102 (mathoperator -> MOD .)
    MINUS           reduce using rule 102 (mathoperator -> MOD .)
    NOT             reduce using rule 102 (mathoperator -> MOD .)
    NULAR_FNC       reduce using rule 102 (mathoperator -> MOD .)
    STRING_SINGLE   reduce using rule 102 (mathoperator -> MOD .)
    STRING_DOUBLE   reduce using rule 102 (mathoperator -> MOD .)
    LBRACE          reduce using rule 102 (mathoperator -> MOD .)
    IF              reduce using rule 102 (mathoperator -> MOD .)
    WHILE           reduce using rule 102 (mathoperator -> MOD .)
    FOR             reduce using rule 102 (mathoperator -> MOD .)
    WITH            reduce using rule 102 (mathoperator -> MOD .)
    PRIVATE         reduce using rule 102 (mathoperator -> MOD .)


state 74

    (103) mathoperator -> POW .

    LPAREN          reduce using rule 103 (mathoperator -> POW .)
    NUMBER_REAL     reduce using rule 103 (mathoperator -> POW .)
    NUMBER_EXP      reduce using rule 103 (mathoperator -> POW .)
    NUMBER_HEX      reduce using rule 103 (mathoperator -> POW .)
    PRIVATE_ID      reduce using rule 103 (mathoperator -> POW .)
    GLOBAL_ID       reduce using rule 103 (mathoperator -> POW .)
    LSPAREN         reduce using rule 103 (mathoperator -> POW .)
    UNARY_FNC       reduce using rule 103 (mathoperator -> POW .)
    PLUS            reduce using rule 103 (mathoperator -> POW .)
    MINUS           reduce using rule 103 (mathoperator -> POW .)
    NOT             reduce using rule 103 (mathoperator -> POW .)
    NULAR_FNC       reduce using rule 103 (mathoperator -> POW .)
    STRING_SINGLE   reduce using rule 103 (mathoperator -> POW .)
    STRING_DOUBLE   reduce using rule 103 (mathoperator -> POW .)
    LBRACE          reduce using rule 103 (mathoperator -> POW .)
    IF              reduce using rule 103 (mathoperator -> POW .)
    WHILE           reduce using rule 103 (mathoperator -> POW .)
    FOR             reduce using rule 103 (mathoperator -> POW .)
    WITH            reduce using rule 103 (mathoperator -> POW .)
    PRIVATE         reduce using rule 103 (mathoperator -> POW .)


state 75

    (50) assignment -> variable EQUAL . primaryexp
    (52) assignment_code -> variable EQUAL . LBRACE
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (32) withtype -> . WITH NAMESPACE
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (53) arraydefinition -> . PRIVATE stringarray

    LBRACE          shift and go to state 123
    LPAREN          shift and go to state 33
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    PRIVATE_ID      shift and go to state 82
    GLOBAL_ID       shift and go to state 83
    LSPAREN         shift and go to state 45
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    NULAR_FNC       shift and go to state 19
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    WITH            shift and go to state 52
    PRIVATE         shift and go to state 35

    primaryexp                     shift and go to state 122
    number                         shift and go to state 39
    identifier                     shift and go to state 77
    helpertype                     shift and go to state 40
    array                          shift and go to state 31
    unaryexp                       shift and go to state 78
    nularexp                       shift and go to state 79
    string                         shift and go to state 37
    binaryexp                      shift and go to state 80
    bracedexp                      shift and go to state 81
    iftype                         shift and go to state 84
    whiletype                      shift and go to state 85
    fortype                        shift and go to state 86
    withtype                       shift and go to state 87
    vardefinition                  shift and go to state 25
    definition                     shift and go to state 88
    arraydefinition                shift and go to state 41

state 76

    (85) unaryexp -> UNARY_FNC primaryexp .
    (60) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (61) binaryexp -> primaryexp . comparisonoperator primaryexp
    (62) binaryexp -> primaryexp . mathoperator primaryexp
    (90) comparisonoperator -> . LT
    (91) comparisonoperator -> . GT
    (92) comparisonoperator -> . LTE
    (93) comparisonoperator -> . GTE
    (94) comparisonoperator -> . EQUALITY
    (95) comparisonoperator -> . INEQUALITY
    (96) comparisonoperator -> . AND
    (97) comparisonoperator -> . OR
    (98) mathoperator -> . PLUS
    (99) mathoperator -> . MINUS
    (100) mathoperator -> . TIMES
    (101) mathoperator -> . DIVIDE
    (102) mathoperator -> . MOD
    (103) mathoperator -> . POW

    SEMI_COLON      reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)
    COMMA           reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)
    $end            reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)
    BINARY_FNC      reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)
    LT              reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)
    GT              reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)
    LTE             reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)
    GTE             reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)
    EQUALITY        reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)
    INEQUALITY      reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)
    AND             reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)
    OR              reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)
    PLUS            reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)
    MINUS           reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)
    TIMES           reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)
    DIVIDE          reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)
    MOD             reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)
    POW             reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)
    RBRACE          reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)
    RSPAREN         reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)
    RPAREN          reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)
    TO              reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)
    STEP            reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)
    DO              reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)
    COLON           reduce using rule 85 (unaryexp -> UNARY_FNC primaryexp .)

  ! BINARY_FNC      [ shift and go to state 58 ]
  ! LT              [ shift and go to state 61 ]
  ! GT              [ shift and go to state 62 ]
  ! LTE             [ shift and go to state 63 ]
  ! GTE             [ shift and go to state 64 ]
  ! EQUALITY        [ shift and go to state 65 ]
  ! INEQUALITY      [ shift and go to state 66 ]
  ! AND             [ shift and go to state 67 ]
  ! OR              [ shift and go to state 68 ]
  ! PLUS            [ shift and go to state 69 ]
  ! MINUS           [ shift and go to state 70 ]
  ! TIMES           [ shift and go to state 71 ]
  ! DIVIDE          [ shift and go to state 72 ]
  ! MOD             [ shift and go to state 73 ]
  ! POW             [ shift and go to state 74 ]

    comparisonoperator             shift and go to state 59
    mathoperator                   shift and go to state 60

state 77

    (64) primaryexp -> identifier .
    (84) nularexp -> identifier .

  ! reduce/reduce conflict for BINARY_FNC resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for LT resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for GT resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for LTE resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for GTE resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for EQUALITY resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for INEQUALITY resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for AND resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for OR resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for PLUS resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for MINUS resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for TIMES resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for MOD resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for POW resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for SEMI_COLON resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for COMMA resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for $end resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for RBRACE resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for RSPAREN resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for RPAREN resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for TO resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for STEP resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for DO resolved using rule 64 (primaryexp -> identifier .)
  ! reduce/reduce conflict for COLON resolved using rule 64 (primaryexp -> identifier .)
    BINARY_FNC      reduce using rule 64 (primaryexp -> identifier .)
    LT              reduce using rule 64 (primaryexp -> identifier .)
    GT              reduce using rule 64 (primaryexp -> identifier .)
    LTE             reduce using rule 64 (primaryexp -> identifier .)
    GTE             reduce using rule 64 (primaryexp -> identifier .)
    EQUALITY        reduce using rule 64 (primaryexp -> identifier .)
    INEQUALITY      reduce using rule 64 (primaryexp -> identifier .)
    AND             reduce using rule 64 (primaryexp -> identifier .)
    OR              reduce using rule 64 (primaryexp -> identifier .)
    PLUS            reduce using rule 64 (primaryexp -> identifier .)
    MINUS           reduce using rule 64 (primaryexp -> identifier .)
    TIMES           reduce using rule 64 (primaryexp -> identifier .)
    DIVIDE          reduce using rule 64 (primaryexp -> identifier .)
    MOD             reduce using rule 64 (primaryexp -> identifier .)
    POW             reduce using rule 64 (primaryexp -> identifier .)
    SEMI_COLON      reduce using rule 64 (primaryexp -> identifier .)
    COMMA           reduce using rule 64 (primaryexp -> identifier .)
    $end            reduce using rule 64 (primaryexp -> identifier .)
    RBRACE          reduce using rule 64 (primaryexp -> identifier .)
    RSPAREN         reduce using rule 64 (primaryexp -> identifier .)
    RPAREN          reduce using rule 64 (primaryexp -> identifier .)
    TO              reduce using rule 64 (primaryexp -> identifier .)
    STEP            reduce using rule 64 (primaryexp -> identifier .)
    DO              reduce using rule 64 (primaryexp -> identifier .)
    COLON           reduce using rule 64 (primaryexp -> identifier .)

  ! BINARY_FNC      [ reduce using rule 84 (nularexp -> identifier .) ]
  ! LT              [ reduce using rule 84 (nularexp -> identifier .) ]
  ! GT              [ reduce using rule 84 (nularexp -> identifier .) ]
  ! LTE             [ reduce using rule 84 (nularexp -> identifier .) ]
  ! GTE             [ reduce using rule 84 (nularexp -> identifier .) ]
  ! EQUALITY        [ reduce using rule 84 (nularexp -> identifier .) ]
  ! INEQUALITY      [ reduce using rule 84 (nularexp -> identifier .) ]
  ! AND             [ reduce using rule 84 (nularexp -> identifier .) ]
  ! OR              [ reduce using rule 84 (nularexp -> identifier .) ]
  ! PLUS            [ reduce using rule 84 (nularexp -> identifier .) ]
  ! MINUS           [ reduce using rule 84 (nularexp -> identifier .) ]
  ! TIMES           [ reduce using rule 84 (nularexp -> identifier .) ]
  ! DIVIDE          [ reduce using rule 84 (nularexp -> identifier .) ]
  ! MOD             [ reduce using rule 84 (nularexp -> identifier .) ]
  ! POW             [ reduce using rule 84 (nularexp -> identifier .) ]
  ! SEMI_COLON      [ reduce using rule 84 (nularexp -> identifier .) ]
  ! COMMA           [ reduce using rule 84 (nularexp -> identifier .) ]
  ! $end            [ reduce using rule 84 (nularexp -> identifier .) ]
  ! RBRACE          [ reduce using rule 84 (nularexp -> identifier .) ]
  ! RSPAREN         [ reduce using rule 84 (nularexp -> identifier .) ]
  ! RPAREN          [ reduce using rule 84 (nularexp -> identifier .) ]
  ! TO              [ reduce using rule 84 (nularexp -> identifier .) ]
  ! STEP            [ reduce using rule 84 (nularexp -> identifier .) ]
  ! DO              [ reduce using rule 84 (nularexp -> identifier .) ]
  ! COLON           [ reduce using rule 84 (nularexp -> identifier .) ]


state 78

    (67) primaryexp -> unaryexp .

    BINARY_FNC      reduce using rule 67 (primaryexp -> unaryexp .)
    LT              reduce using rule 67 (primaryexp -> unaryexp .)
    GT              reduce using rule 67 (primaryexp -> unaryexp .)
    LTE             reduce using rule 67 (primaryexp -> unaryexp .)
    GTE             reduce using rule 67 (primaryexp -> unaryexp .)
    EQUALITY        reduce using rule 67 (primaryexp -> unaryexp .)
    INEQUALITY      reduce using rule 67 (primaryexp -> unaryexp .)
    AND             reduce using rule 67 (primaryexp -> unaryexp .)
    OR              reduce using rule 67 (primaryexp -> unaryexp .)
    PLUS            reduce using rule 67 (primaryexp -> unaryexp .)
    MINUS           reduce using rule 67 (primaryexp -> unaryexp .)
    TIMES           reduce using rule 67 (primaryexp -> unaryexp .)
    DIVIDE          reduce using rule 67 (primaryexp -> unaryexp .)
    MOD             reduce using rule 67 (primaryexp -> unaryexp .)
    POW             reduce using rule 67 (primaryexp -> unaryexp .)
    SEMI_COLON      reduce using rule 67 (primaryexp -> unaryexp .)
    COMMA           reduce using rule 67 (primaryexp -> unaryexp .)
    $end            reduce using rule 67 (primaryexp -> unaryexp .)
    RBRACE          reduce using rule 67 (primaryexp -> unaryexp .)
    RSPAREN         reduce using rule 67 (primaryexp -> unaryexp .)
    RPAREN          reduce using rule 67 (primaryexp -> unaryexp .)
    TO              reduce using rule 67 (primaryexp -> unaryexp .)
    STEP            reduce using rule 67 (primaryexp -> unaryexp .)
    DO              reduce using rule 67 (primaryexp -> unaryexp .)
    COLON           reduce using rule 67 (primaryexp -> unaryexp .)


state 79

    (68) primaryexp -> nularexp .

    BINARY_FNC      reduce using rule 68 (primaryexp -> nularexp .)
    LT              reduce using rule 68 (primaryexp -> nularexp .)
    GT              reduce using rule 68 (primaryexp -> nularexp .)
    LTE             reduce using rule 68 (primaryexp -> nularexp .)
    GTE             reduce using rule 68 (primaryexp -> nularexp .)
    EQUALITY        reduce using rule 68 (primaryexp -> nularexp .)
    INEQUALITY      reduce using rule 68 (primaryexp -> nularexp .)
    AND             reduce using rule 68 (primaryexp -> nularexp .)
    OR              reduce using rule 68 (primaryexp -> nularexp .)
    PLUS            reduce using rule 68 (primaryexp -> nularexp .)
    MINUS           reduce using rule 68 (primaryexp -> nularexp .)
    TIMES           reduce using rule 68 (primaryexp -> nularexp .)
    DIVIDE          reduce using rule 68 (primaryexp -> nularexp .)
    MOD             reduce using rule 68 (primaryexp -> nularexp .)
    POW             reduce using rule 68 (primaryexp -> nularexp .)
    SEMI_COLON      reduce using rule 68 (primaryexp -> nularexp .)
    COMMA           reduce using rule 68 (primaryexp -> nularexp .)
    $end            reduce using rule 68 (primaryexp -> nularexp .)
    RBRACE          reduce using rule 68 (primaryexp -> nularexp .)
    RSPAREN         reduce using rule 68 (primaryexp -> nularexp .)
    RPAREN          reduce using rule 68 (primaryexp -> nularexp .)
    TO              reduce using rule 68 (primaryexp -> nularexp .)
    STEP            reduce using rule 68 (primaryexp -> nularexp .)
    DO              reduce using rule 68 (primaryexp -> nularexp .)
    COLON           reduce using rule 68 (primaryexp -> nularexp .)


state 80

    (70) primaryexp -> binaryexp .

    BINARY_FNC      reduce using rule 70 (primaryexp -> binaryexp .)
    LT              reduce using rule 70 (primaryexp -> binaryexp .)
    GT              reduce using rule 70 (primaryexp -> binaryexp .)
    LTE             reduce using rule 70 (primaryexp -> binaryexp .)
    GTE             reduce using rule 70 (primaryexp -> binaryexp .)
    EQUALITY        reduce using rule 70 (primaryexp -> binaryexp .)
    INEQUALITY      reduce using rule 70 (primaryexp -> binaryexp .)
    AND             reduce using rule 70 (primaryexp -> binaryexp .)
    OR              reduce using rule 70 (primaryexp -> binaryexp .)
    PLUS            reduce using rule 70 (primaryexp -> binaryexp .)
    MINUS           reduce using rule 70 (primaryexp -> binaryexp .)
    TIMES           reduce using rule 70 (primaryexp -> binaryexp .)
    DIVIDE          reduce using rule 70 (primaryexp -> binaryexp .)
    MOD             reduce using rule 70 (primaryexp -> binaryexp .)
    POW             reduce using rule 70 (primaryexp -> binaryexp .)
    SEMI_COLON      reduce using rule 70 (primaryexp -> binaryexp .)
    COMMA           reduce using rule 70 (primaryexp -> binaryexp .)
    $end            reduce using rule 70 (primaryexp -> binaryexp .)
    RBRACE          reduce using rule 70 (primaryexp -> binaryexp .)
    RSPAREN         reduce using rule 70 (primaryexp -> binaryexp .)
    RPAREN          reduce using rule 70 (primaryexp -> binaryexp .)
    TO              reduce using rule 70 (primaryexp -> binaryexp .)
    STEP            reduce using rule 70 (primaryexp -> binaryexp .)
    DO              reduce using rule 70 (primaryexp -> binaryexp .)
    COLON           reduce using rule 70 (primaryexp -> binaryexp .)


state 81

    (71) primaryexp -> bracedexp .

    BINARY_FNC      reduce using rule 71 (primaryexp -> bracedexp .)
    LT              reduce using rule 71 (primaryexp -> bracedexp .)
    GT              reduce using rule 71 (primaryexp -> bracedexp .)
    LTE             reduce using rule 71 (primaryexp -> bracedexp .)
    GTE             reduce using rule 71 (primaryexp -> bracedexp .)
    EQUALITY        reduce using rule 71 (primaryexp -> bracedexp .)
    INEQUALITY      reduce using rule 71 (primaryexp -> bracedexp .)
    AND             reduce using rule 71 (primaryexp -> bracedexp .)
    OR              reduce using rule 71 (primaryexp -> bracedexp .)
    PLUS            reduce using rule 71 (primaryexp -> bracedexp .)
    MINUS           reduce using rule 71 (primaryexp -> bracedexp .)
    TIMES           reduce using rule 71 (primaryexp -> bracedexp .)
    DIVIDE          reduce using rule 71 (primaryexp -> bracedexp .)
    MOD             reduce using rule 71 (primaryexp -> bracedexp .)
    POW             reduce using rule 71 (primaryexp -> bracedexp .)
    SEMI_COLON      reduce using rule 71 (primaryexp -> bracedexp .)
    COMMA           reduce using rule 71 (primaryexp -> bracedexp .)
    $end            reduce using rule 71 (primaryexp -> bracedexp .)
    RBRACE          reduce using rule 71 (primaryexp -> bracedexp .)
    RSPAREN         reduce using rule 71 (primaryexp -> bracedexp .)
    RPAREN          reduce using rule 71 (primaryexp -> bracedexp .)
    TO              reduce using rule 71 (primaryexp -> bracedexp .)
    STEP            reduce using rule 71 (primaryexp -> bracedexp .)
    DO              reduce using rule 71 (primaryexp -> bracedexp .)
    COLON           reduce using rule 71 (primaryexp -> bracedexp .)


state 82

    (56) identifier -> PRIVATE_ID .

    BINARY_FNC      reduce using rule 56 (identifier -> PRIVATE_ID .)
    LT              reduce using rule 56 (identifier -> PRIVATE_ID .)
    GT              reduce using rule 56 (identifier -> PRIVATE_ID .)
    LTE             reduce using rule 56 (identifier -> PRIVATE_ID .)
    GTE             reduce using rule 56 (identifier -> PRIVATE_ID .)
    EQUALITY        reduce using rule 56 (identifier -> PRIVATE_ID .)
    INEQUALITY      reduce using rule 56 (identifier -> PRIVATE_ID .)
    AND             reduce using rule 56 (identifier -> PRIVATE_ID .)
    OR              reduce using rule 56 (identifier -> PRIVATE_ID .)
    PLUS            reduce using rule 56 (identifier -> PRIVATE_ID .)
    MINUS           reduce using rule 56 (identifier -> PRIVATE_ID .)
    TIMES           reduce using rule 56 (identifier -> PRIVATE_ID .)
    DIVIDE          reduce using rule 56 (identifier -> PRIVATE_ID .)
    MOD             reduce using rule 56 (identifier -> PRIVATE_ID .)
    POW             reduce using rule 56 (identifier -> PRIVATE_ID .)
    SEMI_COLON      reduce using rule 56 (identifier -> PRIVATE_ID .)
    COMMA           reduce using rule 56 (identifier -> PRIVATE_ID .)
    $end            reduce using rule 56 (identifier -> PRIVATE_ID .)
    RBRACE          reduce using rule 56 (identifier -> PRIVATE_ID .)
    RSPAREN         reduce using rule 56 (identifier -> PRIVATE_ID .)
    RPAREN          reduce using rule 56 (identifier -> PRIVATE_ID .)
    TO              reduce using rule 56 (identifier -> PRIVATE_ID .)
    STEP            reduce using rule 56 (identifier -> PRIVATE_ID .)
    DO              reduce using rule 56 (identifier -> PRIVATE_ID .)
    COLON           reduce using rule 56 (identifier -> PRIVATE_ID .)
    THEN            reduce using rule 56 (identifier -> PRIVATE_ID .)
    EXITWITH        reduce using rule 56 (identifier -> PRIVATE_ID .)


state 83

    (57) identifier -> GLOBAL_ID .

    BINARY_FNC      reduce using rule 57 (identifier -> GLOBAL_ID .)
    LT              reduce using rule 57 (identifier -> GLOBAL_ID .)
    GT              reduce using rule 57 (identifier -> GLOBAL_ID .)
    LTE             reduce using rule 57 (identifier -> GLOBAL_ID .)
    GTE             reduce using rule 57 (identifier -> GLOBAL_ID .)
    EQUALITY        reduce using rule 57 (identifier -> GLOBAL_ID .)
    INEQUALITY      reduce using rule 57 (identifier -> GLOBAL_ID .)
    AND             reduce using rule 57 (identifier -> GLOBAL_ID .)
    OR              reduce using rule 57 (identifier -> GLOBAL_ID .)
    PLUS            reduce using rule 57 (identifier -> GLOBAL_ID .)
    MINUS           reduce using rule 57 (identifier -> GLOBAL_ID .)
    TIMES           reduce using rule 57 (identifier -> GLOBAL_ID .)
    DIVIDE          reduce using rule 57 (identifier -> GLOBAL_ID .)
    MOD             reduce using rule 57 (identifier -> GLOBAL_ID .)
    POW             reduce using rule 57 (identifier -> GLOBAL_ID .)
    SEMI_COLON      reduce using rule 57 (identifier -> GLOBAL_ID .)
    COMMA           reduce using rule 57 (identifier -> GLOBAL_ID .)
    $end            reduce using rule 57 (identifier -> GLOBAL_ID .)
    RBRACE          reduce using rule 57 (identifier -> GLOBAL_ID .)
    RSPAREN         reduce using rule 57 (identifier -> GLOBAL_ID .)
    RPAREN          reduce using rule 57 (identifier -> GLOBAL_ID .)
    TO              reduce using rule 57 (identifier -> GLOBAL_ID .)
    STEP            reduce using rule 57 (identifier -> GLOBAL_ID .)
    DO              reduce using rule 57 (identifier -> GLOBAL_ID .)
    COLON           reduce using rule 57 (identifier -> GLOBAL_ID .)
    THEN            reduce using rule 57 (identifier -> GLOBAL_ID .)
    EXITWITH        reduce using rule 57 (identifier -> GLOBAL_ID .)


state 84

    (17) helpertype -> iftype .

    BINARY_FNC      reduce using rule 17 (helpertype -> iftype .)
    LT              reduce using rule 17 (helpertype -> iftype .)
    GT              reduce using rule 17 (helpertype -> iftype .)
    LTE             reduce using rule 17 (helpertype -> iftype .)
    GTE             reduce using rule 17 (helpertype -> iftype .)
    EQUALITY        reduce using rule 17 (helpertype -> iftype .)
    INEQUALITY      reduce using rule 17 (helpertype -> iftype .)
    AND             reduce using rule 17 (helpertype -> iftype .)
    OR              reduce using rule 17 (helpertype -> iftype .)
    PLUS            reduce using rule 17 (helpertype -> iftype .)
    MINUS           reduce using rule 17 (helpertype -> iftype .)
    TIMES           reduce using rule 17 (helpertype -> iftype .)
    DIVIDE          reduce using rule 17 (helpertype -> iftype .)
    MOD             reduce using rule 17 (helpertype -> iftype .)
    POW             reduce using rule 17 (helpertype -> iftype .)
    SEMI_COLON      reduce using rule 17 (helpertype -> iftype .)
    COMMA           reduce using rule 17 (helpertype -> iftype .)
    $end            reduce using rule 17 (helpertype -> iftype .)
    RBRACE          reduce using rule 17 (helpertype -> iftype .)
    RSPAREN         reduce using rule 17 (helpertype -> iftype .)
    RPAREN          reduce using rule 17 (helpertype -> iftype .)
    TO              reduce using rule 17 (helpertype -> iftype .)
    STEP            reduce using rule 17 (helpertype -> iftype .)
    DO              reduce using rule 17 (helpertype -> iftype .)
    COLON           reduce using rule 17 (helpertype -> iftype .)


state 85

    (18) helpertype -> whiletype .

    BINARY_FNC      reduce using rule 18 (helpertype -> whiletype .)
    LT              reduce using rule 18 (helpertype -> whiletype .)
    GT              reduce using rule 18 (helpertype -> whiletype .)
    LTE             reduce using rule 18 (helpertype -> whiletype .)
    GTE             reduce using rule 18 (helpertype -> whiletype .)
    EQUALITY        reduce using rule 18 (helpertype -> whiletype .)
    INEQUALITY      reduce using rule 18 (helpertype -> whiletype .)
    AND             reduce using rule 18 (helpertype -> whiletype .)
    OR              reduce using rule 18 (helpertype -> whiletype .)
    PLUS            reduce using rule 18 (helpertype -> whiletype .)
    MINUS           reduce using rule 18 (helpertype -> whiletype .)
    TIMES           reduce using rule 18 (helpertype -> whiletype .)
    DIVIDE          reduce using rule 18 (helpertype -> whiletype .)
    MOD             reduce using rule 18 (helpertype -> whiletype .)
    POW             reduce using rule 18 (helpertype -> whiletype .)
    SEMI_COLON      reduce using rule 18 (helpertype -> whiletype .)
    COMMA           reduce using rule 18 (helpertype -> whiletype .)
    $end            reduce using rule 18 (helpertype -> whiletype .)
    RBRACE          reduce using rule 18 (helpertype -> whiletype .)
    RSPAREN         reduce using rule 18 (helpertype -> whiletype .)
    RPAREN          reduce using rule 18 (helpertype -> whiletype .)
    TO              reduce using rule 18 (helpertype -> whiletype .)
    STEP            reduce using rule 18 (helpertype -> whiletype .)
    DO              reduce using rule 18 (helpertype -> whiletype .)
    COLON           reduce using rule 18 (helpertype -> whiletype .)


state 86

    (19) helpertype -> fortype .

    BINARY_FNC      reduce using rule 19 (helpertype -> fortype .)
    LT              reduce using rule 19 (helpertype -> fortype .)
    GT              reduce using rule 19 (helpertype -> fortype .)
    LTE             reduce using rule 19 (helpertype -> fortype .)
    GTE             reduce using rule 19 (helpertype -> fortype .)
    EQUALITY        reduce using rule 19 (helpertype -> fortype .)
    INEQUALITY      reduce using rule 19 (helpertype -> fortype .)
    AND             reduce using rule 19 (helpertype -> fortype .)
    OR              reduce using rule 19 (helpertype -> fortype .)
    PLUS            reduce using rule 19 (helpertype -> fortype .)
    MINUS           reduce using rule 19 (helpertype -> fortype .)
    TIMES           reduce using rule 19 (helpertype -> fortype .)
    DIVIDE          reduce using rule 19 (helpertype -> fortype .)
    MOD             reduce using rule 19 (helpertype -> fortype .)
    POW             reduce using rule 19 (helpertype -> fortype .)
    SEMI_COLON      reduce using rule 19 (helpertype -> fortype .)
    COMMA           reduce using rule 19 (helpertype -> fortype .)
    $end            reduce using rule 19 (helpertype -> fortype .)
    RBRACE          reduce using rule 19 (helpertype -> fortype .)
    RSPAREN         reduce using rule 19 (helpertype -> fortype .)
    RPAREN          reduce using rule 19 (helpertype -> fortype .)
    TO              reduce using rule 19 (helpertype -> fortype .)
    STEP            reduce using rule 19 (helpertype -> fortype .)
    DO              reduce using rule 19 (helpertype -> fortype .)
    COLON           reduce using rule 19 (helpertype -> fortype .)


state 87

    (20) helpertype -> withtype .

    BINARY_FNC      reduce using rule 20 (helpertype -> withtype .)
    LT              reduce using rule 20 (helpertype -> withtype .)
    GT              reduce using rule 20 (helpertype -> withtype .)
    LTE             reduce using rule 20 (helpertype -> withtype .)
    GTE             reduce using rule 20 (helpertype -> withtype .)
    EQUALITY        reduce using rule 20 (helpertype -> withtype .)
    INEQUALITY      reduce using rule 20 (helpertype -> withtype .)
    AND             reduce using rule 20 (helpertype -> withtype .)
    OR              reduce using rule 20 (helpertype -> withtype .)
    PLUS            reduce using rule 20 (helpertype -> withtype .)
    MINUS           reduce using rule 20 (helpertype -> withtype .)
    TIMES           reduce using rule 20 (helpertype -> withtype .)
    DIVIDE          reduce using rule 20 (helpertype -> withtype .)
    MOD             reduce using rule 20 (helpertype -> withtype .)
    POW             reduce using rule 20 (helpertype -> withtype .)
    SEMI_COLON      reduce using rule 20 (helpertype -> withtype .)
    COMMA           reduce using rule 20 (helpertype -> withtype .)
    $end            reduce using rule 20 (helpertype -> withtype .)
    RBRACE          reduce using rule 20 (helpertype -> withtype .)
    RSPAREN         reduce using rule 20 (helpertype -> withtype .)
    RPAREN          reduce using rule 20 (helpertype -> withtype .)
    TO              reduce using rule 20 (helpertype -> withtype .)
    STEP            reduce using rule 20 (helpertype -> withtype .)
    DO              reduce using rule 20 (helpertype -> withtype .)
    COLON           reduce using rule 20 (helpertype -> withtype .)


state 88

    (46) vardefinition -> definition .

    BINARY_FNC      reduce using rule 46 (vardefinition -> definition .)
    LT              reduce using rule 46 (vardefinition -> definition .)
    GT              reduce using rule 46 (vardefinition -> definition .)
    LTE             reduce using rule 46 (vardefinition -> definition .)
    GTE             reduce using rule 46 (vardefinition -> definition .)
    EQUALITY        reduce using rule 46 (vardefinition -> definition .)
    INEQUALITY      reduce using rule 46 (vardefinition -> definition .)
    AND             reduce using rule 46 (vardefinition -> definition .)
    OR              reduce using rule 46 (vardefinition -> definition .)
    PLUS            reduce using rule 46 (vardefinition -> definition .)
    MINUS           reduce using rule 46 (vardefinition -> definition .)
    TIMES           reduce using rule 46 (vardefinition -> definition .)
    DIVIDE          reduce using rule 46 (vardefinition -> definition .)
    MOD             reduce using rule 46 (vardefinition -> definition .)
    POW             reduce using rule 46 (vardefinition -> definition .)
    SEMI_COLON      reduce using rule 46 (vardefinition -> definition .)
    COMMA           reduce using rule 46 (vardefinition -> definition .)
    $end            reduce using rule 46 (vardefinition -> definition .)
    RBRACE          reduce using rule 46 (vardefinition -> definition .)
    RSPAREN         reduce using rule 46 (vardefinition -> definition .)
    RPAREN          reduce using rule 46 (vardefinition -> definition .)
    TO              reduce using rule 46 (vardefinition -> definition .)
    STEP            reduce using rule 46 (vardefinition -> definition .)
    DO              reduce using rule 46 (vardefinition -> definition .)
    COLON           reduce using rule 46 (vardefinition -> definition .)


state 89

    (86) unaryexp -> PLUS primaryexp .
    (60) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (61) binaryexp -> primaryexp . comparisonoperator primaryexp
    (62) binaryexp -> primaryexp . mathoperator primaryexp
    (90) comparisonoperator -> . LT
    (91) comparisonoperator -> . GT
    (92) comparisonoperator -> . LTE
    (93) comparisonoperator -> . GTE
    (94) comparisonoperator -> . EQUALITY
    (95) comparisonoperator -> . INEQUALITY
    (96) comparisonoperator -> . AND
    (97) comparisonoperator -> . OR
    (98) mathoperator -> . PLUS
    (99) mathoperator -> . MINUS
    (100) mathoperator -> . TIMES
    (101) mathoperator -> . DIVIDE
    (102) mathoperator -> . MOD
    (103) mathoperator -> . POW

    SEMI_COLON      reduce using rule 86 (unaryexp -> PLUS primaryexp .)
    COMMA           reduce using rule 86 (unaryexp -> PLUS primaryexp .)
    $end            reduce using rule 86 (unaryexp -> PLUS primaryexp .)
    BINARY_FNC      reduce using rule 86 (unaryexp -> PLUS primaryexp .)
    LT              reduce using rule 86 (unaryexp -> PLUS primaryexp .)
    GT              reduce using rule 86 (unaryexp -> PLUS primaryexp .)
    LTE             reduce using rule 86 (unaryexp -> PLUS primaryexp .)
    GTE             reduce using rule 86 (unaryexp -> PLUS primaryexp .)
    EQUALITY        reduce using rule 86 (unaryexp -> PLUS primaryexp .)
    INEQUALITY      reduce using rule 86 (unaryexp -> PLUS primaryexp .)
    AND             reduce using rule 86 (unaryexp -> PLUS primaryexp .)
    OR              reduce using rule 86 (unaryexp -> PLUS primaryexp .)
    PLUS            reduce using rule 86 (unaryexp -> PLUS primaryexp .)
    MINUS           reduce using rule 86 (unaryexp -> PLUS primaryexp .)
    TIMES           reduce using rule 86 (unaryexp -> PLUS primaryexp .)
    DIVIDE          reduce using rule 86 (unaryexp -> PLUS primaryexp .)
    MOD             reduce using rule 86 (unaryexp -> PLUS primaryexp .)
    POW             reduce using rule 86 (unaryexp -> PLUS primaryexp .)
    RBRACE          reduce using rule 86 (unaryexp -> PLUS primaryexp .)
    RSPAREN         reduce using rule 86 (unaryexp -> PLUS primaryexp .)
    RPAREN          reduce using rule 86 (unaryexp -> PLUS primaryexp .)
    TO              reduce using rule 86 (unaryexp -> PLUS primaryexp .)
    STEP            reduce using rule 86 (unaryexp -> PLUS primaryexp .)
    DO              reduce using rule 86 (unaryexp -> PLUS primaryexp .)
    COLON           reduce using rule 86 (unaryexp -> PLUS primaryexp .)

  ! BINARY_FNC      [ shift and go to state 58 ]
  ! LT              [ shift and go to state 61 ]
  ! GT              [ shift and go to state 62 ]
  ! LTE             [ shift and go to state 63 ]
  ! GTE             [ shift and go to state 64 ]
  ! EQUALITY        [ shift and go to state 65 ]
  ! INEQUALITY      [ shift and go to state 66 ]
  ! AND             [ shift and go to state 67 ]
  ! OR              [ shift and go to state 68 ]
  ! PLUS            [ shift and go to state 69 ]
  ! MINUS           [ shift and go to state 70 ]
  ! TIMES           [ shift and go to state 71 ]
  ! DIVIDE          [ shift and go to state 72 ]
  ! MOD             [ shift and go to state 73 ]
  ! POW             [ shift and go to state 74 ]

    comparisonoperator             shift and go to state 59
    mathoperator                   shift and go to state 60

state 90

    (87) unaryexp -> MINUS primaryexp .
    (60) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (61) binaryexp -> primaryexp . comparisonoperator primaryexp
    (62) binaryexp -> primaryexp . mathoperator primaryexp
    (90) comparisonoperator -> . LT
    (91) comparisonoperator -> . GT
    (92) comparisonoperator -> . LTE
    (93) comparisonoperator -> . GTE
    (94) comparisonoperator -> . EQUALITY
    (95) comparisonoperator -> . INEQUALITY
    (96) comparisonoperator -> . AND
    (97) comparisonoperator -> . OR
    (98) mathoperator -> . PLUS
    (99) mathoperator -> . MINUS
    (100) mathoperator -> . TIMES
    (101) mathoperator -> . DIVIDE
    (102) mathoperator -> . MOD
    (103) mathoperator -> . POW

    SEMI_COLON      reduce using rule 87 (unaryexp -> MINUS primaryexp .)
    COMMA           reduce using rule 87 (unaryexp -> MINUS primaryexp .)
    $end            reduce using rule 87 (unaryexp -> MINUS primaryexp .)
    BINARY_FNC      reduce using rule 87 (unaryexp -> MINUS primaryexp .)
    LT              reduce using rule 87 (unaryexp -> MINUS primaryexp .)
    GT              reduce using rule 87 (unaryexp -> MINUS primaryexp .)
    LTE             reduce using rule 87 (unaryexp -> MINUS primaryexp .)
    GTE             reduce using rule 87 (unaryexp -> MINUS primaryexp .)
    EQUALITY        reduce using rule 87 (unaryexp -> MINUS primaryexp .)
    INEQUALITY      reduce using rule 87 (unaryexp -> MINUS primaryexp .)
    AND             reduce using rule 87 (unaryexp -> MINUS primaryexp .)
    OR              reduce using rule 87 (unaryexp -> MINUS primaryexp .)
    PLUS            reduce using rule 87 (unaryexp -> MINUS primaryexp .)
    MINUS           reduce using rule 87 (unaryexp -> MINUS primaryexp .)
    TIMES           reduce using rule 87 (unaryexp -> MINUS primaryexp .)
    DIVIDE          reduce using rule 87 (unaryexp -> MINUS primaryexp .)
    MOD             reduce using rule 87 (unaryexp -> MINUS primaryexp .)
    POW             reduce using rule 87 (unaryexp -> MINUS primaryexp .)
    RBRACE          reduce using rule 87 (unaryexp -> MINUS primaryexp .)
    RSPAREN         reduce using rule 87 (unaryexp -> MINUS primaryexp .)
    RPAREN          reduce using rule 87 (unaryexp -> MINUS primaryexp .)
    TO              reduce using rule 87 (unaryexp -> MINUS primaryexp .)
    STEP            reduce using rule 87 (unaryexp -> MINUS primaryexp .)
    DO              reduce using rule 87 (unaryexp -> MINUS primaryexp .)
    COLON           reduce using rule 87 (unaryexp -> MINUS primaryexp .)

  ! BINARY_FNC      [ shift and go to state 58 ]
  ! LT              [ shift and go to state 61 ]
  ! GT              [ shift and go to state 62 ]
  ! LTE             [ shift and go to state 63 ]
  ! GTE             [ shift and go to state 64 ]
  ! EQUALITY        [ shift and go to state 65 ]
  ! INEQUALITY      [ shift and go to state 66 ]
  ! AND             [ shift and go to state 67 ]
  ! OR              [ shift and go to state 68 ]
  ! PLUS            [ shift and go to state 69 ]
  ! MINUS           [ shift and go to state 70 ]
  ! TIMES           [ shift and go to state 71 ]
  ! DIVIDE          [ shift and go to state 72 ]
  ! MOD             [ shift and go to state 73 ]
  ! POW             [ shift and go to state 74 ]

    comparisonoperator             shift and go to state 59
    mathoperator                   shift and go to state 60

state 91

    (88) unaryexp -> NOT primaryexp .
    (60) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (61) binaryexp -> primaryexp . comparisonoperator primaryexp
    (62) binaryexp -> primaryexp . mathoperator primaryexp
    (90) comparisonoperator -> . LT
    (91) comparisonoperator -> . GT
    (92) comparisonoperator -> . LTE
    (93) comparisonoperator -> . GTE
    (94) comparisonoperator -> . EQUALITY
    (95) comparisonoperator -> . INEQUALITY
    (96) comparisonoperator -> . AND
    (97) comparisonoperator -> . OR
    (98) mathoperator -> . PLUS
    (99) mathoperator -> . MINUS
    (100) mathoperator -> . TIMES
    (101) mathoperator -> . DIVIDE
    (102) mathoperator -> . MOD
    (103) mathoperator -> . POW

    SEMI_COLON      reduce using rule 88 (unaryexp -> NOT primaryexp .)
    COMMA           reduce using rule 88 (unaryexp -> NOT primaryexp .)
    $end            reduce using rule 88 (unaryexp -> NOT primaryexp .)
    BINARY_FNC      reduce using rule 88 (unaryexp -> NOT primaryexp .)
    LT              reduce using rule 88 (unaryexp -> NOT primaryexp .)
    GT              reduce using rule 88 (unaryexp -> NOT primaryexp .)
    LTE             reduce using rule 88 (unaryexp -> NOT primaryexp .)
    GTE             reduce using rule 88 (unaryexp -> NOT primaryexp .)
    EQUALITY        reduce using rule 88 (unaryexp -> NOT primaryexp .)
    INEQUALITY      reduce using rule 88 (unaryexp -> NOT primaryexp .)
    AND             reduce using rule 88 (unaryexp -> NOT primaryexp .)
    OR              reduce using rule 88 (unaryexp -> NOT primaryexp .)
    PLUS            reduce using rule 88 (unaryexp -> NOT primaryexp .)
    MINUS           reduce using rule 88 (unaryexp -> NOT primaryexp .)
    TIMES           reduce using rule 88 (unaryexp -> NOT primaryexp .)
    DIVIDE          reduce using rule 88 (unaryexp -> NOT primaryexp .)
    MOD             reduce using rule 88 (unaryexp -> NOT primaryexp .)
    POW             reduce using rule 88 (unaryexp -> NOT primaryexp .)
    RBRACE          reduce using rule 88 (unaryexp -> NOT primaryexp .)
    RSPAREN         reduce using rule 88 (unaryexp -> NOT primaryexp .)
    RPAREN          reduce using rule 88 (unaryexp -> NOT primaryexp .)
    TO              reduce using rule 88 (unaryexp -> NOT primaryexp .)
    STEP            reduce using rule 88 (unaryexp -> NOT primaryexp .)
    DO              reduce using rule 88 (unaryexp -> NOT primaryexp .)
    COLON           reduce using rule 88 (unaryexp -> NOT primaryexp .)

  ! BINARY_FNC      [ shift and go to state 58 ]
  ! LT              [ shift and go to state 61 ]
  ! GT              [ shift and go to state 62 ]
  ! LTE             [ shift and go to state 63 ]
  ! GTE             [ shift and go to state 64 ]
  ! EQUALITY        [ shift and go to state 65 ]
  ! INEQUALITY      [ shift and go to state 66 ]
  ! AND             [ shift and go to state 67 ]
  ! OR              [ shift and go to state 68 ]
  ! PLUS            [ shift and go to state 69 ]
  ! MINUS           [ shift and go to state 70 ]
  ! TIMES           [ shift and go to state 71 ]
  ! DIVIDE          [ shift and go to state 72 ]
  ! MOD             [ shift and go to state 73 ]
  ! POW             [ shift and go to state 74 ]

    comparisonoperator             shift and go to state 59
    mathoperator                   shift and go to state 60

state 92

    (29) ifstatement -> iftype THEN . bracedexp
    (31) ifstatement -> iftype THEN . bracedexp ELSE bracedexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE

    LBRACE          shift and go to state 34

    bracedexp                      shift and go to state 124

state 93

    (30) ifstatement -> iftype EXITWITH . bracedexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE

    LBRACE          shift and go to state 34

    bracedexp                      shift and go to state 125

state 94

    (37) foreachloop -> bracedexp FOREACH . array
    (38) foreachloop -> bracedexp FOREACH . primaryexp
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (32) withtype -> . WITH NAMESPACE
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (53) arraydefinition -> . PRIVATE stringarray

    LSPAREN         shift and go to state 45
    LPAREN          shift and go to state 33
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    PRIVATE_ID      shift and go to state 82
    GLOBAL_ID       shift and go to state 83
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    NULAR_FNC       shift and go to state 19
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    LBRACE          shift and go to state 34
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    WITH            shift and go to state 52
    PRIVATE         shift and go to state 35

    bracedexp                      shift and go to state 81
    array                          shift and go to state 126
    primaryexp                     shift and go to state 127
    number                         shift and go to state 39
    identifier                     shift and go to state 77
    helpertype                     shift and go to state 40
    unaryexp                       shift and go to state 78
    nularexp                       shift and go to state 79
    string                         shift and go to state 37
    binaryexp                      shift and go to state 80
    iftype                         shift and go to state 84
    whiletype                      shift and go to state 85
    fortype                        shift and go to state 86
    withtype                       shift and go to state 87
    vardefinition                  shift and go to state 25
    definition                     shift and go to state 88
    arraydefinition                shift and go to state 41

state 95

    (36) whileloop -> whiletype DO . bracedexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE

    LBRACE          shift and go to state 34

    bracedexp                      shift and go to state 128

state 96

    (42) forloop -> fortype DO . bracedexp_noscope
    (45) bracedexp_noscope -> . LBRACE code RBRACE

    LBRACE          shift and go to state 130

    bracedexp_noscope              shift and go to state 129

state 97

    (34) withstatement -> withstatementinit bracedexp .

    SEMI_COLON      reduce using rule 34 (withstatement -> withstatementinit bracedexp .)
    COMMA           reduce using rule 34 (withstatement -> withstatementinit bracedexp .)
    $end            reduce using rule 34 (withstatement -> withstatementinit bracedexp .)
    RBRACE          reduce using rule 34 (withstatement -> withstatementinit bracedexp .)


state 98

    (24) switchstatement -> SWITCH LPAREN . primaryexp RPAREN DO LBRACE switchbody RBRACE
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (32) withtype -> . WITH NAMESPACE
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (53) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 33
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    PRIVATE_ID      shift and go to state 82
    GLOBAL_ID       shift and go to state 83
    LSPAREN         shift and go to state 45
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    NULAR_FNC       shift and go to state 19
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    LBRACE          shift and go to state 34
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    WITH            shift and go to state 52
    PRIVATE         shift and go to state 35

    primaryexp                     shift and go to state 131
    number                         shift and go to state 39
    identifier                     shift and go to state 77
    helpertype                     shift and go to state 40
    array                          shift and go to state 31
    unaryexp                       shift and go to state 78
    nularexp                       shift and go to state 79
    string                         shift and go to state 37
    binaryexp                      shift and go to state 80
    bracedexp                      shift and go to state 81
    iftype                         shift and go to state 84
    whiletype                      shift and go to state 85
    fortype                        shift and go to state 86
    withtype                       shift and go to state 87
    vardefinition                  shift and go to state 25
    definition                     shift and go to state 88
    arraydefinition                shift and go to state 41

state 99

    (72) primaryexp -> LPAREN binaryexp . RPAREN
    (70) primaryexp -> binaryexp .

    RPAREN          shift and go to state 132
    BINARY_FNC      reduce using rule 70 (primaryexp -> binaryexp .)
    LT              reduce using rule 70 (primaryexp -> binaryexp .)
    GT              reduce using rule 70 (primaryexp -> binaryexp .)
    LTE             reduce using rule 70 (primaryexp -> binaryexp .)
    GTE             reduce using rule 70 (primaryexp -> binaryexp .)
    EQUALITY        reduce using rule 70 (primaryexp -> binaryexp .)
    INEQUALITY      reduce using rule 70 (primaryexp -> binaryexp .)
    AND             reduce using rule 70 (primaryexp -> binaryexp .)
    OR              reduce using rule 70 (primaryexp -> binaryexp .)
    PLUS            reduce using rule 70 (primaryexp -> binaryexp .)
    MINUS           reduce using rule 70 (primaryexp -> binaryexp .)
    TIMES           reduce using rule 70 (primaryexp -> binaryexp .)
    DIVIDE          reduce using rule 70 (primaryexp -> binaryexp .)
    MOD             reduce using rule 70 (primaryexp -> binaryexp .)
    POW             reduce using rule 70 (primaryexp -> binaryexp .)


state 100

    (73) bracedexp -> LBRACE new_scope . code RBRACE
    (1) code -> . empty
    (2) code -> . statement
    (3) code -> . statement terminator code
    (114) empty -> .
    (4) statement -> . controlstructure
    (5) statement -> . assignment
    (6) statement -> . binaryexp
    (7) statement -> . nularexp
    (8) statement -> . unaryexp
    (11) controlstructure -> . ifstatement
    (12) controlstructure -> . whileloop
    (13) controlstructure -> . forloop
    (14) controlstructure -> . withstatement
    (15) controlstructure -> . foreachloop
    (16) controlstructure -> . switchstatement
    (48) assignment -> . assignment_code code RBRACE
    (49) assignment -> . definition EQUAL primaryexp
    (50) assignment -> . variable EQUAL primaryexp
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (29) ifstatement -> . iftype THEN bracedexp
    (30) ifstatement -> . iftype EXITWITH bracedexp
    (31) ifstatement -> . iftype THEN bracedexp ELSE bracedexp
    (36) whileloop -> . whiletype DO bracedexp
    (42) forloop -> . fortype DO bracedexp_noscope
    (34) withstatement -> . withstatementinit bracedexp
    (37) foreachloop -> . bracedexp FOREACH array
    (38) foreachloop -> . bracedexp FOREACH primaryexp
    (24) switchstatement -> . SWITCH LPAREN primaryexp RPAREN DO LBRACE switchbody RBRACE
    (51) assignment_code -> . definition EQUAL LBRACE
    (52) assignment_code -> . variable EQUAL LBRACE
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (58) variable -> . PRIVATE_ID
    (59) variable -> . GLOBAL_ID
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (33) withstatementinit -> . withtype DO
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (53) arraydefinition -> . PRIVATE stringarray
    (32) withtype -> . WITH NAMESPACE

    RBRACE          reduce using rule 114 (empty -> .)
    NULAR_FNC       shift and go to state 19
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    SWITCH          shift and go to state 32
    PRIVATE         shift and go to state 35
    PRIVATE_ID      shift and go to state 36
    GLOBAL_ID       shift and go to state 38
    LPAREN          shift and go to state 33
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    LBRACE          shift and go to state 34
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    LSPAREN         shift and go to state 45
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    WITH            shift and go to state 52

    code                           shift and go to state 133
    empty                          shift and go to state 2
    statement                      shift and go to state 3
    controlstructure               shift and go to state 4
    assignment                     shift and go to state 5
    binaryexp                      shift and go to state 6
    nularexp                       shift and go to state 7
    unaryexp                       shift and go to state 8
    ifstatement                    shift and go to state 9
    whileloop                      shift and go to state 10
    forloop                        shift and go to state 11
    withstatement                  shift and go to state 12
    foreachloop                    shift and go to state 13
    switchstatement                shift and go to state 14
    assignment_code                shift and go to state 15
    definition                     shift and go to state 16
    primaryexp                     shift and go to state 17
    variable                       shift and go to state 18
    identifier                     shift and go to state 20
    vardefinition                  shift and go to state 25
    iftype                         shift and go to state 26
    bracedexp                      shift and go to state 27
    whiletype                      shift and go to state 28
    fortype                        shift and go to state 29
    withstatementinit              shift and go to state 30
    array                          shift and go to state 31
    string                         shift and go to state 37
    number                         shift and go to state 39
    helpertype                     shift and go to state 40
    arraydefinition                shift and go to state 41
    withtype                       shift and go to state 46

state 101

    (54) definition -> PRIVATE PRIVATE_ID .

    EQUAL           reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    SEMI_COLON      reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    COMMA           reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    $end            reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    BINARY_FNC      reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    LT              reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    GT              reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    LTE             reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    GTE             reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    EQUALITY        reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    INEQUALITY      reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    AND             reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    OR              reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    PLUS            reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    MINUS           reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    TIMES           reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    DIVIDE          reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    MOD             reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    POW             reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    RBRACE          reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    RSPAREN         reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    RPAREN          reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    TO              reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    STEP            reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    DO              reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)
    COLON           reduce using rule 54 (definition -> PRIVATE PRIVATE_ID .)


state 102

    (55) definition -> PRIVATE string .

    EQUAL           reduce using rule 55 (definition -> PRIVATE string .)
    SEMI_COLON      reduce using rule 55 (definition -> PRIVATE string .)
    COMMA           reduce using rule 55 (definition -> PRIVATE string .)
    $end            reduce using rule 55 (definition -> PRIVATE string .)
    BINARY_FNC      reduce using rule 55 (definition -> PRIVATE string .)
    LT              reduce using rule 55 (definition -> PRIVATE string .)
    GT              reduce using rule 55 (definition -> PRIVATE string .)
    LTE             reduce using rule 55 (definition -> PRIVATE string .)
    GTE             reduce using rule 55 (definition -> PRIVATE string .)
    EQUALITY        reduce using rule 55 (definition -> PRIVATE string .)
    INEQUALITY      reduce using rule 55 (definition -> PRIVATE string .)
    AND             reduce using rule 55 (definition -> PRIVATE string .)
    OR              reduce using rule 55 (definition -> PRIVATE string .)
    PLUS            reduce using rule 55 (definition -> PRIVATE string .)
    MINUS           reduce using rule 55 (definition -> PRIVATE string .)
    TIMES           reduce using rule 55 (definition -> PRIVATE string .)
    DIVIDE          reduce using rule 55 (definition -> PRIVATE string .)
    MOD             reduce using rule 55 (definition -> PRIVATE string .)
    POW             reduce using rule 55 (definition -> PRIVATE string .)
    RBRACE          reduce using rule 55 (definition -> PRIVATE string .)
    RSPAREN         reduce using rule 55 (definition -> PRIVATE string .)
    RPAREN          reduce using rule 55 (definition -> PRIVATE string .)
    TO              reduce using rule 55 (definition -> PRIVATE string .)
    STEP            reduce using rule 55 (definition -> PRIVATE string .)
    DO              reduce using rule 55 (definition -> PRIVATE string .)
    COLON           reduce using rule 55 (definition -> PRIVATE string .)


state 103

    (53) arraydefinition -> PRIVATE stringarray .

    SEMI_COLON      reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)
    COMMA           reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)
    $end            reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)
    BINARY_FNC      reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)
    LT              reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)
    GT              reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)
    LTE             reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)
    GTE             reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)
    EQUALITY        reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)
    INEQUALITY      reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)
    AND             reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)
    OR              reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)
    PLUS            reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)
    MINUS           reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)
    TIMES           reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)
    DIVIDE          reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)
    MOD             reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)
    POW             reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)
    RBRACE          reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)
    RSPAREN         reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)
    RPAREN          reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)
    TO              reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)
    STEP            reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)
    DO              reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)
    COLON           reduce using rule 53 (arraydefinition -> PRIVATE stringarray .)


state 104

    (79) stringarray -> LSPAREN . RSPAREN
    (80) stringarray -> LSPAREN . stringarrayelement RSPAREN
    (81) stringarrayelement -> . string
    (82) stringarrayelement -> . string COMMA stringarrayelement
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE

    RSPAREN         shift and go to state 134
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51

    stringarrayelement             shift and go to state 135
    string                         shift and go to state 136

state 105

    (28) iftype -> IF forloop_condition .

    THEN            reduce using rule 28 (iftype -> IF forloop_condition .)
    EXITWITH        reduce using rule 28 (iftype -> IF forloop_condition .)
    BINARY_FNC      reduce using rule 28 (iftype -> IF forloop_condition .)
    LT              reduce using rule 28 (iftype -> IF forloop_condition .)
    GT              reduce using rule 28 (iftype -> IF forloop_condition .)
    LTE             reduce using rule 28 (iftype -> IF forloop_condition .)
    GTE             reduce using rule 28 (iftype -> IF forloop_condition .)
    EQUALITY        reduce using rule 28 (iftype -> IF forloop_condition .)
    INEQUALITY      reduce using rule 28 (iftype -> IF forloop_condition .)
    AND             reduce using rule 28 (iftype -> IF forloop_condition .)
    OR              reduce using rule 28 (iftype -> IF forloop_condition .)
    PLUS            reduce using rule 28 (iftype -> IF forloop_condition .)
    MINUS           reduce using rule 28 (iftype -> IF forloop_condition .)
    TIMES           reduce using rule 28 (iftype -> IF forloop_condition .)
    DIVIDE          reduce using rule 28 (iftype -> IF forloop_condition .)
    MOD             reduce using rule 28 (iftype -> IF forloop_condition .)
    POW             reduce using rule 28 (iftype -> IF forloop_condition .)
    SEMI_COLON      reduce using rule 28 (iftype -> IF forloop_condition .)
    COMMA           reduce using rule 28 (iftype -> IF forloop_condition .)
    $end            reduce using rule 28 (iftype -> IF forloop_condition .)
    RBRACE          reduce using rule 28 (iftype -> IF forloop_condition .)
    RSPAREN         reduce using rule 28 (iftype -> IF forloop_condition .)
    RPAREN          reduce using rule 28 (iftype -> IF forloop_condition .)
    TO              reduce using rule 28 (iftype -> IF forloop_condition .)
    STEP            reduce using rule 28 (iftype -> IF forloop_condition .)
    DO              reduce using rule 28 (iftype -> IF forloop_condition .)
    COLON           reduce using rule 28 (iftype -> IF forloop_condition .)


state 106

    (43) forloop_condition -> LBRACE . booleanexp RBRACE
    (104) booleanexp -> . primaryexp
    (105) booleanexp -> . primaryexp comparisonoperator booleanexp
    (106) booleanexp -> . primaryexp comparisonoperator LBRACE booleanexp RBRACE
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (32) withtype -> . WITH NAMESPACE
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (53) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 33
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    PRIVATE_ID      shift and go to state 82
    GLOBAL_ID       shift and go to state 83
    LSPAREN         shift and go to state 45
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    NULAR_FNC       shift and go to state 19
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    LBRACE          shift and go to state 34
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    WITH            shift and go to state 52
    PRIVATE         shift and go to state 35

    booleanexp                     shift and go to state 137
    primaryexp                     shift and go to state 138
    number                         shift and go to state 39
    identifier                     shift and go to state 77
    helpertype                     shift and go to state 40
    array                          shift and go to state 31
    unaryexp                       shift and go to state 78
    nularexp                       shift and go to state 79
    string                         shift and go to state 37
    binaryexp                      shift and go to state 80
    bracedexp                      shift and go to state 81
    iftype                         shift and go to state 84
    whiletype                      shift and go to state 85
    fortype                        shift and go to state 86
    withtype                       shift and go to state 87
    vardefinition                  shift and go to state 25
    definition                     shift and go to state 88
    arraydefinition                shift and go to state 41

state 107

    (44) forloop_condition -> identifier .

    THEN            reduce using rule 44 (forloop_condition -> identifier .)
    EXITWITH        reduce using rule 44 (forloop_condition -> identifier .)
    BINARY_FNC      reduce using rule 44 (forloop_condition -> identifier .)
    LT              reduce using rule 44 (forloop_condition -> identifier .)
    GT              reduce using rule 44 (forloop_condition -> identifier .)
    LTE             reduce using rule 44 (forloop_condition -> identifier .)
    GTE             reduce using rule 44 (forloop_condition -> identifier .)
    EQUALITY        reduce using rule 44 (forloop_condition -> identifier .)
    INEQUALITY      reduce using rule 44 (forloop_condition -> identifier .)
    AND             reduce using rule 44 (forloop_condition -> identifier .)
    OR              reduce using rule 44 (forloop_condition -> identifier .)
    PLUS            reduce using rule 44 (forloop_condition -> identifier .)
    MINUS           reduce using rule 44 (forloop_condition -> identifier .)
    TIMES           reduce using rule 44 (forloop_condition -> identifier .)
    DIVIDE          reduce using rule 44 (forloop_condition -> identifier .)
    MOD             reduce using rule 44 (forloop_condition -> identifier .)
    POW             reduce using rule 44 (forloop_condition -> identifier .)
    SEMI_COLON      reduce using rule 44 (forloop_condition -> identifier .)
    COMMA           reduce using rule 44 (forloop_condition -> identifier .)
    $end            reduce using rule 44 (forloop_condition -> identifier .)
    RBRACE          reduce using rule 44 (forloop_condition -> identifier .)
    RSPAREN         reduce using rule 44 (forloop_condition -> identifier .)
    RPAREN          reduce using rule 44 (forloop_condition -> identifier .)
    TO              reduce using rule 44 (forloop_condition -> identifier .)
    STEP            reduce using rule 44 (forloop_condition -> identifier .)
    DO              reduce using rule 44 (forloop_condition -> identifier .)
    COLON           reduce using rule 44 (forloop_condition -> identifier .)


state 108

    (35) whiletype -> WHILE forloop_condition .

    DO              reduce using rule 35 (whiletype -> WHILE forloop_condition .)
    BINARY_FNC      reduce using rule 35 (whiletype -> WHILE forloop_condition .)
    LT              reduce using rule 35 (whiletype -> WHILE forloop_condition .)
    GT              reduce using rule 35 (whiletype -> WHILE forloop_condition .)
    LTE             reduce using rule 35 (whiletype -> WHILE forloop_condition .)
    GTE             reduce using rule 35 (whiletype -> WHILE forloop_condition .)
    EQUALITY        reduce using rule 35 (whiletype -> WHILE forloop_condition .)
    INEQUALITY      reduce using rule 35 (whiletype -> WHILE forloop_condition .)
    AND             reduce using rule 35 (whiletype -> WHILE forloop_condition .)
    OR              reduce using rule 35 (whiletype -> WHILE forloop_condition .)
    PLUS            reduce using rule 35 (whiletype -> WHILE forloop_condition .)
    MINUS           reduce using rule 35 (whiletype -> WHILE forloop_condition .)
    TIMES           reduce using rule 35 (whiletype -> WHILE forloop_condition .)
    DIVIDE          reduce using rule 35 (whiletype -> WHILE forloop_condition .)
    MOD             reduce using rule 35 (whiletype -> WHILE forloop_condition .)
    POW             reduce using rule 35 (whiletype -> WHILE forloop_condition .)
    SEMI_COLON      reduce using rule 35 (whiletype -> WHILE forloop_condition .)
    COMMA           reduce using rule 35 (whiletype -> WHILE forloop_condition .)
    $end            reduce using rule 35 (whiletype -> WHILE forloop_condition .)
    RBRACE          reduce using rule 35 (whiletype -> WHILE forloop_condition .)
    RSPAREN         reduce using rule 35 (whiletype -> WHILE forloop_condition .)
    RPAREN          reduce using rule 35 (whiletype -> WHILE forloop_condition .)
    TO              reduce using rule 35 (whiletype -> WHILE forloop_condition .)
    STEP            reduce using rule 35 (whiletype -> WHILE forloop_condition .)
    COLON           reduce using rule 35 (whiletype -> WHILE forloop_condition .)


state 109

    (39) fortype -> FOR new_scope . string FROM primaryexp TO primaryexp
    (40) fortype -> FOR new_scope . string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> FOR new_scope . LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE

    LSPAREN         shift and go to state 140
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51

    string                         shift and go to state 139

state 110

    (75) array -> LSPAREN RSPAREN .

    BINARY_FNC      reduce using rule 75 (array -> LSPAREN RSPAREN .)
    LT              reduce using rule 75 (array -> LSPAREN RSPAREN .)
    GT              reduce using rule 75 (array -> LSPAREN RSPAREN .)
    LTE             reduce using rule 75 (array -> LSPAREN RSPAREN .)
    GTE             reduce using rule 75 (array -> LSPAREN RSPAREN .)
    EQUALITY        reduce using rule 75 (array -> LSPAREN RSPAREN .)
    INEQUALITY      reduce using rule 75 (array -> LSPAREN RSPAREN .)
    AND             reduce using rule 75 (array -> LSPAREN RSPAREN .)
    OR              reduce using rule 75 (array -> LSPAREN RSPAREN .)
    PLUS            reduce using rule 75 (array -> LSPAREN RSPAREN .)
    MINUS           reduce using rule 75 (array -> LSPAREN RSPAREN .)
    TIMES           reduce using rule 75 (array -> LSPAREN RSPAREN .)
    DIVIDE          reduce using rule 75 (array -> LSPAREN RSPAREN .)
    MOD             reduce using rule 75 (array -> LSPAREN RSPAREN .)
    POW             reduce using rule 75 (array -> LSPAREN RSPAREN .)
    SEMI_COLON      reduce using rule 75 (array -> LSPAREN RSPAREN .)
    COMMA           reduce using rule 75 (array -> LSPAREN RSPAREN .)
    $end            reduce using rule 75 (array -> LSPAREN RSPAREN .)
    RBRACE          reduce using rule 75 (array -> LSPAREN RSPAREN .)
    RSPAREN         reduce using rule 75 (array -> LSPAREN RSPAREN .)
    RPAREN          reduce using rule 75 (array -> LSPAREN RSPAREN .)
    TO              reduce using rule 75 (array -> LSPAREN RSPAREN .)
    STEP            reduce using rule 75 (array -> LSPAREN RSPAREN .)
    DO              reduce using rule 75 (array -> LSPAREN RSPAREN .)
    COLON           reduce using rule 75 (array -> LSPAREN RSPAREN .)


state 111

    (76) array -> LSPAREN arrayelement . RSPAREN

    RSPAREN         shift and go to state 141


state 112

    (77) arrayelement -> primaryexp .
    (78) arrayelement -> primaryexp . COMMA arrayelement
    (60) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (61) binaryexp -> primaryexp . comparisonoperator primaryexp
    (62) binaryexp -> primaryexp . mathoperator primaryexp
    (90) comparisonoperator -> . LT
    (91) comparisonoperator -> . GT
    (92) comparisonoperator -> . LTE
    (93) comparisonoperator -> . GTE
    (94) comparisonoperator -> . EQUALITY
    (95) comparisonoperator -> . INEQUALITY
    (96) comparisonoperator -> . AND
    (97) comparisonoperator -> . OR
    (98) mathoperator -> . PLUS
    (99) mathoperator -> . MINUS
    (100) mathoperator -> . TIMES
    (101) mathoperator -> . DIVIDE
    (102) mathoperator -> . MOD
    (103) mathoperator -> . POW

    RSPAREN         reduce using rule 77 (arrayelement -> primaryexp .)
    COMMA           shift and go to state 142
    BINARY_FNC      shift and go to state 58
    LT              shift and go to state 61
    GT              shift and go to state 62
    LTE             shift and go to state 63
    GTE             shift and go to state 64
    EQUALITY        shift and go to state 65
    INEQUALITY      shift and go to state 66
    AND             shift and go to state 67
    OR              shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    MOD             shift and go to state 73
    POW             shift and go to state 74

    comparisonoperator             shift and go to state 59
    mathoperator                   shift and go to state 60

state 113

    (33) withstatementinit -> withtype DO .

    LBRACE          reduce using rule 33 (withstatementinit -> withtype DO .)


state 114

    (32) withtype -> WITH NAMESPACE .

    DO              reduce using rule 32 (withtype -> WITH NAMESPACE .)
    BINARY_FNC      reduce using rule 32 (withtype -> WITH NAMESPACE .)
    LT              reduce using rule 32 (withtype -> WITH NAMESPACE .)
    GT              reduce using rule 32 (withtype -> WITH NAMESPACE .)
    LTE             reduce using rule 32 (withtype -> WITH NAMESPACE .)
    GTE             reduce using rule 32 (withtype -> WITH NAMESPACE .)
    EQUALITY        reduce using rule 32 (withtype -> WITH NAMESPACE .)
    INEQUALITY      reduce using rule 32 (withtype -> WITH NAMESPACE .)
    AND             reduce using rule 32 (withtype -> WITH NAMESPACE .)
    OR              reduce using rule 32 (withtype -> WITH NAMESPACE .)
    PLUS            reduce using rule 32 (withtype -> WITH NAMESPACE .)
    MINUS           reduce using rule 32 (withtype -> WITH NAMESPACE .)
    TIMES           reduce using rule 32 (withtype -> WITH NAMESPACE .)
    DIVIDE          reduce using rule 32 (withtype -> WITH NAMESPACE .)
    MOD             reduce using rule 32 (withtype -> WITH NAMESPACE .)
    POW             reduce using rule 32 (withtype -> WITH NAMESPACE .)
    SEMI_COLON      reduce using rule 32 (withtype -> WITH NAMESPACE .)
    COMMA           reduce using rule 32 (withtype -> WITH NAMESPACE .)
    $end            reduce using rule 32 (withtype -> WITH NAMESPACE .)
    RBRACE          reduce using rule 32 (withtype -> WITH NAMESPACE .)
    RSPAREN         reduce using rule 32 (withtype -> WITH NAMESPACE .)
    RPAREN          reduce using rule 32 (withtype -> WITH NAMESPACE .)
    TO              reduce using rule 32 (withtype -> WITH NAMESPACE .)
    STEP            reduce using rule 32 (withtype -> WITH NAMESPACE .)
    COLON           reduce using rule 32 (withtype -> WITH NAMESPACE .)


state 115

    (3) code -> statement terminator code .

    $end            reduce using rule 3 (code -> statement terminator code .)
    RBRACE          reduce using rule 3 (code -> statement terminator code .)


state 116

    (48) assignment -> assignment_code code RBRACE .

    SEMI_COLON      reduce using rule 48 (assignment -> assignment_code code RBRACE .)
    COMMA           reduce using rule 48 (assignment -> assignment_code code RBRACE .)
    $end            reduce using rule 48 (assignment -> assignment_code code RBRACE .)
    RBRACE          reduce using rule 48 (assignment -> assignment_code code RBRACE .)


state 117

    (49) assignment -> definition EQUAL primaryexp .
    (60) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (61) binaryexp -> primaryexp . comparisonoperator primaryexp
    (62) binaryexp -> primaryexp . mathoperator primaryexp
    (90) comparisonoperator -> . LT
    (91) comparisonoperator -> . GT
    (92) comparisonoperator -> . LTE
    (93) comparisonoperator -> . GTE
    (94) comparisonoperator -> . EQUALITY
    (95) comparisonoperator -> . INEQUALITY
    (96) comparisonoperator -> . AND
    (97) comparisonoperator -> . OR
    (98) mathoperator -> . PLUS
    (99) mathoperator -> . MINUS
    (100) mathoperator -> . TIMES
    (101) mathoperator -> . DIVIDE
    (102) mathoperator -> . MOD
    (103) mathoperator -> . POW

    SEMI_COLON      reduce using rule 49 (assignment -> definition EQUAL primaryexp .)
    COMMA           reduce using rule 49 (assignment -> definition EQUAL primaryexp .)
    $end            reduce using rule 49 (assignment -> definition EQUAL primaryexp .)
    RBRACE          reduce using rule 49 (assignment -> definition EQUAL primaryexp .)
    BINARY_FNC      shift and go to state 58
    LT              shift and go to state 61
    GT              shift and go to state 62
    LTE             shift and go to state 63
    GTE             shift and go to state 64
    EQUALITY        shift and go to state 65
    INEQUALITY      shift and go to state 66
    AND             shift and go to state 67
    OR              shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    MOD             shift and go to state 73
    POW             shift and go to state 74

    comparisonoperator             shift and go to state 59
    mathoperator                   shift and go to state 60

state 118

    (51) assignment_code -> definition EQUAL LBRACE .
    (73) bracedexp -> LBRACE . new_scope code RBRACE
    (74) new_scope -> .

  ! reduce/reduce conflict for NULAR_FNC resolved using rule 51 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for UNARY_FNC resolved using rule 51 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for PLUS resolved using rule 51 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for MINUS resolved using rule 51 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for NOT resolved using rule 51 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for SWITCH resolved using rule 51 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for PRIVATE resolved using rule 51 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for PRIVATE_ID resolved using rule 51 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for GLOBAL_ID resolved using rule 51 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for LPAREN resolved using rule 51 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for IF resolved using rule 51 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for WHILE resolved using rule 51 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for FOR resolved using rule 51 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for LBRACE resolved using rule 51 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for NUMBER_REAL resolved using rule 51 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for NUMBER_EXP resolved using rule 51 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for NUMBER_HEX resolved using rule 51 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for LSPAREN resolved using rule 51 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for STRING_SINGLE resolved using rule 51 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for STRING_DOUBLE resolved using rule 51 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for WITH resolved using rule 51 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for RBRACE resolved using rule 51 (assignment_code -> definition EQUAL LBRACE .)
    NULAR_FNC       reduce using rule 51 (assignment_code -> definition EQUAL LBRACE .)
    UNARY_FNC       reduce using rule 51 (assignment_code -> definition EQUAL LBRACE .)
    PLUS            reduce using rule 51 (assignment_code -> definition EQUAL LBRACE .)
    MINUS           reduce using rule 51 (assignment_code -> definition EQUAL LBRACE .)
    NOT             reduce using rule 51 (assignment_code -> definition EQUAL LBRACE .)
    SWITCH          reduce using rule 51 (assignment_code -> definition EQUAL LBRACE .)
    PRIVATE         reduce using rule 51 (assignment_code -> definition EQUAL LBRACE .)
    PRIVATE_ID      reduce using rule 51 (assignment_code -> definition EQUAL LBRACE .)
    GLOBAL_ID       reduce using rule 51 (assignment_code -> definition EQUAL LBRACE .)
    LPAREN          reduce using rule 51 (assignment_code -> definition EQUAL LBRACE .)
    IF              reduce using rule 51 (assignment_code -> definition EQUAL LBRACE .)
    WHILE           reduce using rule 51 (assignment_code -> definition EQUAL LBRACE .)
    FOR             reduce using rule 51 (assignment_code -> definition EQUAL LBRACE .)
    LBRACE          reduce using rule 51 (assignment_code -> definition EQUAL LBRACE .)
    NUMBER_REAL     reduce using rule 51 (assignment_code -> definition EQUAL LBRACE .)
    NUMBER_EXP      reduce using rule 51 (assignment_code -> definition EQUAL LBRACE .)
    NUMBER_HEX      reduce using rule 51 (assignment_code -> definition EQUAL LBRACE .)
    LSPAREN         reduce using rule 51 (assignment_code -> definition EQUAL LBRACE .)
    STRING_SINGLE   reduce using rule 51 (assignment_code -> definition EQUAL LBRACE .)
    STRING_DOUBLE   reduce using rule 51 (assignment_code -> definition EQUAL LBRACE .)
    WITH            reduce using rule 51 (assignment_code -> definition EQUAL LBRACE .)
    RBRACE          reduce using rule 51 (assignment_code -> definition EQUAL LBRACE .)

  ! NULAR_FNC       [ reduce using rule 74 (new_scope -> .) ]
  ! UNARY_FNC       [ reduce using rule 74 (new_scope -> .) ]
  ! PLUS            [ reduce using rule 74 (new_scope -> .) ]
  ! MINUS           [ reduce using rule 74 (new_scope -> .) ]
  ! NOT             [ reduce using rule 74 (new_scope -> .) ]
  ! SWITCH          [ reduce using rule 74 (new_scope -> .) ]
  ! PRIVATE         [ reduce using rule 74 (new_scope -> .) ]
  ! PRIVATE_ID      [ reduce using rule 74 (new_scope -> .) ]
  ! GLOBAL_ID       [ reduce using rule 74 (new_scope -> .) ]
  ! LPAREN          [ reduce using rule 74 (new_scope -> .) ]
  ! IF              [ reduce using rule 74 (new_scope -> .) ]
  ! WHILE           [ reduce using rule 74 (new_scope -> .) ]
  ! FOR             [ reduce using rule 74 (new_scope -> .) ]
  ! LBRACE          [ reduce using rule 74 (new_scope -> .) ]
  ! NUMBER_REAL     [ reduce using rule 74 (new_scope -> .) ]
  ! NUMBER_EXP      [ reduce using rule 74 (new_scope -> .) ]
  ! NUMBER_HEX      [ reduce using rule 74 (new_scope -> .) ]
  ! LSPAREN         [ reduce using rule 74 (new_scope -> .) ]
  ! STRING_SINGLE   [ reduce using rule 74 (new_scope -> .) ]
  ! STRING_DOUBLE   [ reduce using rule 74 (new_scope -> .) ]
  ! WITH            [ reduce using rule 74 (new_scope -> .) ]
  ! RBRACE          [ reduce using rule 74 (new_scope -> .) ]

    new_scope                      shift and go to state 100

state 119

    (60) binaryexp -> primaryexp BINARY_FNC primaryexp .
    (60) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (61) binaryexp -> primaryexp . comparisonoperator primaryexp
    (62) binaryexp -> primaryexp . mathoperator primaryexp
    (90) comparisonoperator -> . LT
    (91) comparisonoperator -> . GT
    (92) comparisonoperator -> . LTE
    (93) comparisonoperator -> . GTE
    (94) comparisonoperator -> . EQUALITY
    (95) comparisonoperator -> . INEQUALITY
    (96) comparisonoperator -> . AND
    (97) comparisonoperator -> . OR
    (98) mathoperator -> . PLUS
    (99) mathoperator -> . MINUS
    (100) mathoperator -> . TIMES
    (101) mathoperator -> . DIVIDE
    (102) mathoperator -> . MOD
    (103) mathoperator -> . POW

    SEMI_COLON      reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    COMMA           reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    $end            reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    BINARY_FNC      reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    LT              reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    GT              reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    LTE             reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    GTE             reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    EQUALITY        reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    INEQUALITY      reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    AND             reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    OR              reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    RBRACE          reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    RSPAREN         reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    RPAREN          reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    TO              reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    STEP            reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    DO              reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    COLON           reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    MOD             shift and go to state 73
    POW             shift and go to state 74

  ! PLUS            [ reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .) ]
  ! MINUS           [ reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .) ]
  ! TIMES           [ reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .) ]
  ! DIVIDE          [ reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .) ]
  ! MOD             [ reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .) ]
  ! POW             [ reduce using rule 60 (binaryexp -> primaryexp BINARY_FNC primaryexp .) ]
  ! BINARY_FNC      [ shift and go to state 58 ]
  ! LT              [ shift and go to state 61 ]
  ! GT              [ shift and go to state 62 ]
  ! LTE             [ shift and go to state 63 ]
  ! GTE             [ shift and go to state 64 ]
  ! EQUALITY        [ shift and go to state 65 ]
  ! INEQUALITY      [ shift and go to state 66 ]
  ! AND             [ shift and go to state 67 ]
  ! OR              [ shift and go to state 68 ]

    comparisonoperator             shift and go to state 59
    mathoperator                   shift and go to state 60

state 120

    (61) binaryexp -> primaryexp comparisonoperator primaryexp .
    (60) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (61) binaryexp -> primaryexp . comparisonoperator primaryexp
    (62) binaryexp -> primaryexp . mathoperator primaryexp
    (90) comparisonoperator -> . LT
    (91) comparisonoperator -> . GT
    (92) comparisonoperator -> . LTE
    (93) comparisonoperator -> . GTE
    (94) comparisonoperator -> . EQUALITY
    (95) comparisonoperator -> . INEQUALITY
    (96) comparisonoperator -> . AND
    (97) comparisonoperator -> . OR
    (98) mathoperator -> . PLUS
    (99) mathoperator -> . MINUS
    (100) mathoperator -> . TIMES
    (101) mathoperator -> . DIVIDE
    (102) mathoperator -> . MOD
    (103) mathoperator -> . POW

    SEMI_COLON      reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    COMMA           reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    $end            reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    BINARY_FNC      reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    LT              reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    GT              reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    LTE             reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    GTE             reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    EQUALITY        reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    INEQUALITY      reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    AND             reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    OR              reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    RBRACE          reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    RSPAREN         reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    RPAREN          reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    TO              reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    STEP            reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    DO              reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    COLON           reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    MOD             shift and go to state 73
    POW             shift and go to state 74

  ! PLUS            [ reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! MINUS           [ reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! TIMES           [ reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! DIVIDE          [ reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! MOD             [ reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! POW             [ reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! BINARY_FNC      [ shift and go to state 58 ]
  ! LT              [ shift and go to state 61 ]
  ! GT              [ shift and go to state 62 ]
  ! LTE             [ shift and go to state 63 ]
  ! GTE             [ shift and go to state 64 ]
  ! EQUALITY        [ shift and go to state 65 ]
  ! INEQUALITY      [ shift and go to state 66 ]
  ! AND             [ shift and go to state 67 ]
  ! OR              [ shift and go to state 68 ]

    comparisonoperator             shift and go to state 59
    mathoperator                   shift and go to state 60

state 121

    (62) binaryexp -> primaryexp mathoperator primaryexp .
    (60) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (61) binaryexp -> primaryexp . comparisonoperator primaryexp
    (62) binaryexp -> primaryexp . mathoperator primaryexp
    (90) comparisonoperator -> . LT
    (91) comparisonoperator -> . GT
    (92) comparisonoperator -> . LTE
    (93) comparisonoperator -> . GTE
    (94) comparisonoperator -> . EQUALITY
    (95) comparisonoperator -> . INEQUALITY
    (96) comparisonoperator -> . AND
    (97) comparisonoperator -> . OR
    (98) mathoperator -> . PLUS
    (99) mathoperator -> . MINUS
    (100) mathoperator -> . TIMES
    (101) mathoperator -> . DIVIDE
    (102) mathoperator -> . MOD
    (103) mathoperator -> . POW

    SEMI_COLON      reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .)
    COMMA           reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .)
    $end            reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .)
    BINARY_FNC      reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .)
    LT              reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .)
    GT              reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .)
    LTE             reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .)
    GTE             reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .)
    EQUALITY        reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .)
    INEQUALITY      reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .)
    AND             reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .)
    OR              reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .)
    RBRACE          reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .)
    RSPAREN         reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .)
    RPAREN          reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .)
    TO              reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .)
    STEP            reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .)
    DO              reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .)
    COLON           reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .)
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    MOD             shift and go to state 73
    POW             shift and go to state 74

  ! PLUS            [ reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .) ]
  ! MINUS           [ reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .) ]
  ! TIMES           [ reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .) ]
  ! DIVIDE          [ reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .) ]
  ! MOD             [ reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .) ]
  ! POW             [ reduce using rule 62 (binaryexp -> primaryexp mathoperator primaryexp .) ]
  ! BINARY_FNC      [ shift and go to state 58 ]
  ! LT              [ shift and go to state 61 ]
  ! GT              [ shift and go to state 62 ]
  ! LTE             [ shift and go to state 63 ]
  ! GTE             [ shift and go to state 64 ]
  ! EQUALITY        [ shift and go to state 65 ]
  ! INEQUALITY      [ shift and go to state 66 ]
  ! AND             [ shift and go to state 67 ]
  ! OR              [ shift and go to state 68 ]

    mathoperator                   shift and go to state 60
    comparisonoperator             shift and go to state 59

state 122

    (50) assignment -> variable EQUAL primaryexp .
    (60) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (61) binaryexp -> primaryexp . comparisonoperator primaryexp
    (62) binaryexp -> primaryexp . mathoperator primaryexp
    (90) comparisonoperator -> . LT
    (91) comparisonoperator -> . GT
    (92) comparisonoperator -> . LTE
    (93) comparisonoperator -> . GTE
    (94) comparisonoperator -> . EQUALITY
    (95) comparisonoperator -> . INEQUALITY
    (96) comparisonoperator -> . AND
    (97) comparisonoperator -> . OR
    (98) mathoperator -> . PLUS
    (99) mathoperator -> . MINUS
    (100) mathoperator -> . TIMES
    (101) mathoperator -> . DIVIDE
    (102) mathoperator -> . MOD
    (103) mathoperator -> . POW

    SEMI_COLON      reduce using rule 50 (assignment -> variable EQUAL primaryexp .)
    COMMA           reduce using rule 50 (assignment -> variable EQUAL primaryexp .)
    $end            reduce using rule 50 (assignment -> variable EQUAL primaryexp .)
    RBRACE          reduce using rule 50 (assignment -> variable EQUAL primaryexp .)
    BINARY_FNC      shift and go to state 58
    LT              shift and go to state 61
    GT              shift and go to state 62
    LTE             shift and go to state 63
    GTE             shift and go to state 64
    EQUALITY        shift and go to state 65
    INEQUALITY      shift and go to state 66
    AND             shift and go to state 67
    OR              shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    MOD             shift and go to state 73
    POW             shift and go to state 74

    comparisonoperator             shift and go to state 59
    mathoperator                   shift and go to state 60

state 123

    (52) assignment_code -> variable EQUAL LBRACE .
    (73) bracedexp -> LBRACE . new_scope code RBRACE
    (74) new_scope -> .

  ! reduce/reduce conflict for NULAR_FNC resolved using rule 52 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for UNARY_FNC resolved using rule 52 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for PLUS resolved using rule 52 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for MINUS resolved using rule 52 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for NOT resolved using rule 52 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for SWITCH resolved using rule 52 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for PRIVATE resolved using rule 52 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for PRIVATE_ID resolved using rule 52 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for GLOBAL_ID resolved using rule 52 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for LPAREN resolved using rule 52 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for IF resolved using rule 52 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for WHILE resolved using rule 52 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for FOR resolved using rule 52 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for LBRACE resolved using rule 52 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for NUMBER_REAL resolved using rule 52 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for NUMBER_EXP resolved using rule 52 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for NUMBER_HEX resolved using rule 52 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for LSPAREN resolved using rule 52 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for STRING_SINGLE resolved using rule 52 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for STRING_DOUBLE resolved using rule 52 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for WITH resolved using rule 52 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for RBRACE resolved using rule 52 (assignment_code -> variable EQUAL LBRACE .)
    NULAR_FNC       reduce using rule 52 (assignment_code -> variable EQUAL LBRACE .)
    UNARY_FNC       reduce using rule 52 (assignment_code -> variable EQUAL LBRACE .)
    PLUS            reduce using rule 52 (assignment_code -> variable EQUAL LBRACE .)
    MINUS           reduce using rule 52 (assignment_code -> variable EQUAL LBRACE .)
    NOT             reduce using rule 52 (assignment_code -> variable EQUAL LBRACE .)
    SWITCH          reduce using rule 52 (assignment_code -> variable EQUAL LBRACE .)
    PRIVATE         reduce using rule 52 (assignment_code -> variable EQUAL LBRACE .)
    PRIVATE_ID      reduce using rule 52 (assignment_code -> variable EQUAL LBRACE .)
    GLOBAL_ID       reduce using rule 52 (assignment_code -> variable EQUAL LBRACE .)
    LPAREN          reduce using rule 52 (assignment_code -> variable EQUAL LBRACE .)
    IF              reduce using rule 52 (assignment_code -> variable EQUAL LBRACE .)
    WHILE           reduce using rule 52 (assignment_code -> variable EQUAL LBRACE .)
    FOR             reduce using rule 52 (assignment_code -> variable EQUAL LBRACE .)
    LBRACE          reduce using rule 52 (assignment_code -> variable EQUAL LBRACE .)
    NUMBER_REAL     reduce using rule 52 (assignment_code -> variable EQUAL LBRACE .)
    NUMBER_EXP      reduce using rule 52 (assignment_code -> variable EQUAL LBRACE .)
    NUMBER_HEX      reduce using rule 52 (assignment_code -> variable EQUAL LBRACE .)
    LSPAREN         reduce using rule 52 (assignment_code -> variable EQUAL LBRACE .)
    STRING_SINGLE   reduce using rule 52 (assignment_code -> variable EQUAL LBRACE .)
    STRING_DOUBLE   reduce using rule 52 (assignment_code -> variable EQUAL LBRACE .)
    WITH            reduce using rule 52 (assignment_code -> variable EQUAL LBRACE .)
    RBRACE          reduce using rule 52 (assignment_code -> variable EQUAL LBRACE .)

  ! NULAR_FNC       [ reduce using rule 74 (new_scope -> .) ]
  ! UNARY_FNC       [ reduce using rule 74 (new_scope -> .) ]
  ! PLUS            [ reduce using rule 74 (new_scope -> .) ]
  ! MINUS           [ reduce using rule 74 (new_scope -> .) ]
  ! NOT             [ reduce using rule 74 (new_scope -> .) ]
  ! SWITCH          [ reduce using rule 74 (new_scope -> .) ]
  ! PRIVATE         [ reduce using rule 74 (new_scope -> .) ]
  ! PRIVATE_ID      [ reduce using rule 74 (new_scope -> .) ]
  ! GLOBAL_ID       [ reduce using rule 74 (new_scope -> .) ]
  ! LPAREN          [ reduce using rule 74 (new_scope -> .) ]
  ! IF              [ reduce using rule 74 (new_scope -> .) ]
  ! WHILE           [ reduce using rule 74 (new_scope -> .) ]
  ! FOR             [ reduce using rule 74 (new_scope -> .) ]
  ! LBRACE          [ reduce using rule 74 (new_scope -> .) ]
  ! NUMBER_REAL     [ reduce using rule 74 (new_scope -> .) ]
  ! NUMBER_EXP      [ reduce using rule 74 (new_scope -> .) ]
  ! NUMBER_HEX      [ reduce using rule 74 (new_scope -> .) ]
  ! LSPAREN         [ reduce using rule 74 (new_scope -> .) ]
  ! STRING_SINGLE   [ reduce using rule 74 (new_scope -> .) ]
  ! STRING_DOUBLE   [ reduce using rule 74 (new_scope -> .) ]
  ! WITH            [ reduce using rule 74 (new_scope -> .) ]
  ! RBRACE          [ reduce using rule 74 (new_scope -> .) ]

    new_scope                      shift and go to state 100

state 124

    (29) ifstatement -> iftype THEN bracedexp .
    (31) ifstatement -> iftype THEN bracedexp . ELSE bracedexp

    SEMI_COLON      reduce using rule 29 (ifstatement -> iftype THEN bracedexp .)
    COMMA           reduce using rule 29 (ifstatement -> iftype THEN bracedexp .)
    $end            reduce using rule 29 (ifstatement -> iftype THEN bracedexp .)
    RBRACE          reduce using rule 29 (ifstatement -> iftype THEN bracedexp .)
    ELSE            shift and go to state 143


state 125

    (30) ifstatement -> iftype EXITWITH bracedexp .

    SEMI_COLON      reduce using rule 30 (ifstatement -> iftype EXITWITH bracedexp .)
    COMMA           reduce using rule 30 (ifstatement -> iftype EXITWITH bracedexp .)
    $end            reduce using rule 30 (ifstatement -> iftype EXITWITH bracedexp .)
    RBRACE          reduce using rule 30 (ifstatement -> iftype EXITWITH bracedexp .)


state 126

    (37) foreachloop -> bracedexp FOREACH array .
    (66) primaryexp -> array .

  ! reduce/reduce conflict for SEMI_COLON resolved using rule 37 (foreachloop -> bracedexp FOREACH array .)
  ! reduce/reduce conflict for COMMA resolved using rule 37 (foreachloop -> bracedexp FOREACH array .)
  ! reduce/reduce conflict for $end resolved using rule 37 (foreachloop -> bracedexp FOREACH array .)
  ! reduce/reduce conflict for RBRACE resolved using rule 37 (foreachloop -> bracedexp FOREACH array .)
    SEMI_COLON      reduce using rule 37 (foreachloop -> bracedexp FOREACH array .)
    COMMA           reduce using rule 37 (foreachloop -> bracedexp FOREACH array .)
    $end            reduce using rule 37 (foreachloop -> bracedexp FOREACH array .)
    RBRACE          reduce using rule 37 (foreachloop -> bracedexp FOREACH array .)
    BINARY_FNC      reduce using rule 66 (primaryexp -> array .)
    LT              reduce using rule 66 (primaryexp -> array .)
    GT              reduce using rule 66 (primaryexp -> array .)
    LTE             reduce using rule 66 (primaryexp -> array .)
    GTE             reduce using rule 66 (primaryexp -> array .)
    EQUALITY        reduce using rule 66 (primaryexp -> array .)
    INEQUALITY      reduce using rule 66 (primaryexp -> array .)
    AND             reduce using rule 66 (primaryexp -> array .)
    OR              reduce using rule 66 (primaryexp -> array .)
    PLUS            reduce using rule 66 (primaryexp -> array .)
    MINUS           reduce using rule 66 (primaryexp -> array .)
    TIMES           reduce using rule 66 (primaryexp -> array .)
    DIVIDE          reduce using rule 66 (primaryexp -> array .)
    MOD             reduce using rule 66 (primaryexp -> array .)
    POW             reduce using rule 66 (primaryexp -> array .)

  ! SEMI_COLON      [ reduce using rule 66 (primaryexp -> array .) ]
  ! COMMA           [ reduce using rule 66 (primaryexp -> array .) ]
  ! $end            [ reduce using rule 66 (primaryexp -> array .) ]
  ! RBRACE          [ reduce using rule 66 (primaryexp -> array .) ]


state 127

    (38) foreachloop -> bracedexp FOREACH primaryexp .
    (60) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (61) binaryexp -> primaryexp . comparisonoperator primaryexp
    (62) binaryexp -> primaryexp . mathoperator primaryexp
    (90) comparisonoperator -> . LT
    (91) comparisonoperator -> . GT
    (92) comparisonoperator -> . LTE
    (93) comparisonoperator -> . GTE
    (94) comparisonoperator -> . EQUALITY
    (95) comparisonoperator -> . INEQUALITY
    (96) comparisonoperator -> . AND
    (97) comparisonoperator -> . OR
    (98) mathoperator -> . PLUS
    (99) mathoperator -> . MINUS
    (100) mathoperator -> . TIMES
    (101) mathoperator -> . DIVIDE
    (102) mathoperator -> . MOD
    (103) mathoperator -> . POW

    SEMI_COLON      reduce using rule 38 (foreachloop -> bracedexp FOREACH primaryexp .)
    COMMA           reduce using rule 38 (foreachloop -> bracedexp FOREACH primaryexp .)
    $end            reduce using rule 38 (foreachloop -> bracedexp FOREACH primaryexp .)
    RBRACE          reduce using rule 38 (foreachloop -> bracedexp FOREACH primaryexp .)
    BINARY_FNC      shift and go to state 58
    LT              shift and go to state 61
    GT              shift and go to state 62
    LTE             shift and go to state 63
    GTE             shift and go to state 64
    EQUALITY        shift and go to state 65
    INEQUALITY      shift and go to state 66
    AND             shift and go to state 67
    OR              shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    MOD             shift and go to state 73
    POW             shift and go to state 74

    comparisonoperator             shift and go to state 59
    mathoperator                   shift and go to state 60

state 128

    (36) whileloop -> whiletype DO bracedexp .

    SEMI_COLON      reduce using rule 36 (whileloop -> whiletype DO bracedexp .)
    COMMA           reduce using rule 36 (whileloop -> whiletype DO bracedexp .)
    $end            reduce using rule 36 (whileloop -> whiletype DO bracedexp .)
    RBRACE          reduce using rule 36 (whileloop -> whiletype DO bracedexp .)


state 129

    (42) forloop -> fortype DO bracedexp_noscope .

    SEMI_COLON      reduce using rule 42 (forloop -> fortype DO bracedexp_noscope .)
    COMMA           reduce using rule 42 (forloop -> fortype DO bracedexp_noscope .)
    $end            reduce using rule 42 (forloop -> fortype DO bracedexp_noscope .)
    RBRACE          reduce using rule 42 (forloop -> fortype DO bracedexp_noscope .)


state 130

    (45) bracedexp_noscope -> LBRACE . code RBRACE
    (1) code -> . empty
    (2) code -> . statement
    (3) code -> . statement terminator code
    (114) empty -> .
    (4) statement -> . controlstructure
    (5) statement -> . assignment
    (6) statement -> . binaryexp
    (7) statement -> . nularexp
    (8) statement -> . unaryexp
    (11) controlstructure -> . ifstatement
    (12) controlstructure -> . whileloop
    (13) controlstructure -> . forloop
    (14) controlstructure -> . withstatement
    (15) controlstructure -> . foreachloop
    (16) controlstructure -> . switchstatement
    (48) assignment -> . assignment_code code RBRACE
    (49) assignment -> . definition EQUAL primaryexp
    (50) assignment -> . variable EQUAL primaryexp
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (29) ifstatement -> . iftype THEN bracedexp
    (30) ifstatement -> . iftype EXITWITH bracedexp
    (31) ifstatement -> . iftype THEN bracedexp ELSE bracedexp
    (36) whileloop -> . whiletype DO bracedexp
    (42) forloop -> . fortype DO bracedexp_noscope
    (34) withstatement -> . withstatementinit bracedexp
    (37) foreachloop -> . bracedexp FOREACH array
    (38) foreachloop -> . bracedexp FOREACH primaryexp
    (24) switchstatement -> . SWITCH LPAREN primaryexp RPAREN DO LBRACE switchbody RBRACE
    (51) assignment_code -> . definition EQUAL LBRACE
    (52) assignment_code -> . variable EQUAL LBRACE
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (58) variable -> . PRIVATE_ID
    (59) variable -> . GLOBAL_ID
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (33) withstatementinit -> . withtype DO
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (53) arraydefinition -> . PRIVATE stringarray
    (32) withtype -> . WITH NAMESPACE

    RBRACE          reduce using rule 114 (empty -> .)
    NULAR_FNC       shift and go to state 19
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    SWITCH          shift and go to state 32
    PRIVATE         shift and go to state 35
    PRIVATE_ID      shift and go to state 36
    GLOBAL_ID       shift and go to state 38
    LPAREN          shift and go to state 33
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    LBRACE          shift and go to state 34
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    LSPAREN         shift and go to state 45
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    WITH            shift and go to state 52

    code                           shift and go to state 144
    empty                          shift and go to state 2
    statement                      shift and go to state 3
    controlstructure               shift and go to state 4
    assignment                     shift and go to state 5
    binaryexp                      shift and go to state 6
    nularexp                       shift and go to state 7
    unaryexp                       shift and go to state 8
    ifstatement                    shift and go to state 9
    whileloop                      shift and go to state 10
    forloop                        shift and go to state 11
    withstatement                  shift and go to state 12
    foreachloop                    shift and go to state 13
    switchstatement                shift and go to state 14
    assignment_code                shift and go to state 15
    definition                     shift and go to state 16
    primaryexp                     shift and go to state 17
    variable                       shift and go to state 18
    identifier                     shift and go to state 20
    vardefinition                  shift and go to state 25
    iftype                         shift and go to state 26
    bracedexp                      shift and go to state 27
    whiletype                      shift and go to state 28
    fortype                        shift and go to state 29
    withstatementinit              shift and go to state 30
    array                          shift and go to state 31
    string                         shift and go to state 37
    number                         shift and go to state 39
    helpertype                     shift and go to state 40
    arraydefinition                shift and go to state 41
    withtype                       shift and go to state 46

state 131

    (24) switchstatement -> SWITCH LPAREN primaryexp . RPAREN DO LBRACE switchbody RBRACE
    (60) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (61) binaryexp -> primaryexp . comparisonoperator primaryexp
    (62) binaryexp -> primaryexp . mathoperator primaryexp
    (90) comparisonoperator -> . LT
    (91) comparisonoperator -> . GT
    (92) comparisonoperator -> . LTE
    (93) comparisonoperator -> . GTE
    (94) comparisonoperator -> . EQUALITY
    (95) comparisonoperator -> . INEQUALITY
    (96) comparisonoperator -> . AND
    (97) comparisonoperator -> . OR
    (98) mathoperator -> . PLUS
    (99) mathoperator -> . MINUS
    (100) mathoperator -> . TIMES
    (101) mathoperator -> . DIVIDE
    (102) mathoperator -> . MOD
    (103) mathoperator -> . POW

    RPAREN          shift and go to state 145
    BINARY_FNC      shift and go to state 58
    LT              shift and go to state 61
    GT              shift and go to state 62
    LTE             shift and go to state 63
    GTE             shift and go to state 64
    EQUALITY        shift and go to state 65
    INEQUALITY      shift and go to state 66
    AND             shift and go to state 67
    OR              shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    MOD             shift and go to state 73
    POW             shift and go to state 74

    comparisonoperator             shift and go to state 59
    mathoperator                   shift and go to state 60

state 132

    (72) primaryexp -> LPAREN binaryexp RPAREN .

    BINARY_FNC      reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)
    LT              reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)
    GT              reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)
    LTE             reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)
    GTE             reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)
    EQUALITY        reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)
    INEQUALITY      reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)
    AND             reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)
    OR              reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)
    PLUS            reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)
    MINUS           reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)
    TIMES           reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)
    DIVIDE          reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)
    MOD             reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)
    POW             reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)
    SEMI_COLON      reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)
    COMMA           reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)
    $end            reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)
    RBRACE          reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)
    RSPAREN         reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)
    RPAREN          reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)
    TO              reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)
    STEP            reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)
    DO              reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)
    COLON           reduce using rule 72 (primaryexp -> LPAREN binaryexp RPAREN .)


state 133

    (73) bracedexp -> LBRACE new_scope code . RBRACE

    RBRACE          shift and go to state 146


state 134

    (79) stringarray -> LSPAREN RSPAREN .

    SEMI_COLON      reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)
    COMMA           reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)
    $end            reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)
    BINARY_FNC      reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)
    LT              reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)
    GT              reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)
    LTE             reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)
    GTE             reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)
    EQUALITY        reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)
    INEQUALITY      reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)
    AND             reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)
    OR              reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)
    PLUS            reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)
    MINUS           reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)
    TIMES           reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)
    DIVIDE          reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)
    MOD             reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)
    POW             reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)
    RBRACE          reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)
    RSPAREN         reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)
    RPAREN          reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)
    TO              reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)
    STEP            reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)
    DO              reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)
    COLON           reduce using rule 79 (stringarray -> LSPAREN RSPAREN .)


state 135

    (80) stringarray -> LSPAREN stringarrayelement . RSPAREN

    RSPAREN         shift and go to state 147


state 136

    (81) stringarrayelement -> string .
    (82) stringarrayelement -> string . COMMA stringarrayelement

    RSPAREN         reduce using rule 81 (stringarrayelement -> string .)
    COMMA           shift and go to state 148


state 137

    (43) forloop_condition -> LBRACE booleanexp . RBRACE

    RBRACE          shift and go to state 149


state 138

    (104) booleanexp -> primaryexp .
    (105) booleanexp -> primaryexp . comparisonoperator booleanexp
    (106) booleanexp -> primaryexp . comparisonoperator LBRACE booleanexp RBRACE
    (60) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (61) binaryexp -> primaryexp . comparisonoperator primaryexp
    (62) binaryexp -> primaryexp . mathoperator primaryexp
    (90) comparisonoperator -> . LT
    (91) comparisonoperator -> . GT
    (92) comparisonoperator -> . LTE
    (93) comparisonoperator -> . GTE
    (94) comparisonoperator -> . EQUALITY
    (95) comparisonoperator -> . INEQUALITY
    (96) comparisonoperator -> . AND
    (97) comparisonoperator -> . OR
    (98) mathoperator -> . PLUS
    (99) mathoperator -> . MINUS
    (100) mathoperator -> . TIMES
    (101) mathoperator -> . DIVIDE
    (102) mathoperator -> . MOD
    (103) mathoperator -> . POW

    RBRACE          reduce using rule 104 (booleanexp -> primaryexp .)
    BINARY_FNC      shift and go to state 58
    LT              shift and go to state 61
    GT              shift and go to state 62
    LTE             shift and go to state 63
    GTE             shift and go to state 64
    EQUALITY        shift and go to state 65
    INEQUALITY      shift and go to state 66
    AND             shift and go to state 67
    OR              shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    MOD             shift and go to state 73
    POW             shift and go to state 74

    comparisonoperator             shift and go to state 150
    mathoperator                   shift and go to state 60

state 139

    (39) fortype -> FOR new_scope string . FROM primaryexp TO primaryexp
    (40) fortype -> FOR new_scope string . FROM primaryexp TO primaryexp STEP primaryexp

    FROM            shift and go to state 151


state 140

    (41) fortype -> FOR new_scope LSPAREN . bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (45) bracedexp_noscope -> . LBRACE code RBRACE

    LBRACE          shift and go to state 130

    bracedexp_noscope              shift and go to state 152

state 141

    (76) array -> LSPAREN arrayelement RSPAREN .

    BINARY_FNC      reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)
    LT              reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)
    GT              reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)
    LTE             reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)
    GTE             reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)
    EQUALITY        reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)
    INEQUALITY      reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)
    AND             reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)
    OR              reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)
    PLUS            reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)
    MINUS           reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)
    TIMES           reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)
    DIVIDE          reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)
    MOD             reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)
    POW             reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)
    SEMI_COLON      reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)
    COMMA           reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)
    $end            reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)
    RBRACE          reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)
    RSPAREN         reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)
    RPAREN          reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)
    TO              reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)
    STEP            reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)
    DO              reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)
    COLON           reduce using rule 76 (array -> LSPAREN arrayelement RSPAREN .)


state 142

    (78) arrayelement -> primaryexp COMMA . arrayelement
    (77) arrayelement -> . primaryexp
    (78) arrayelement -> . primaryexp COMMA arrayelement
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (32) withtype -> . WITH NAMESPACE
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (53) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 33
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    PRIVATE_ID      shift and go to state 82
    GLOBAL_ID       shift and go to state 83
    LSPAREN         shift and go to state 45
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    NULAR_FNC       shift and go to state 19
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    LBRACE          shift and go to state 34
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    WITH            shift and go to state 52
    PRIVATE         shift and go to state 35

    primaryexp                     shift and go to state 112
    arrayelement                   shift and go to state 153
    number                         shift and go to state 39
    identifier                     shift and go to state 77
    helpertype                     shift and go to state 40
    array                          shift and go to state 31
    unaryexp                       shift and go to state 78
    nularexp                       shift and go to state 79
    string                         shift and go to state 37
    binaryexp                      shift and go to state 80
    bracedexp                      shift and go to state 81
    iftype                         shift and go to state 84
    whiletype                      shift and go to state 85
    fortype                        shift and go to state 86
    withtype                       shift and go to state 87
    vardefinition                  shift and go to state 25
    definition                     shift and go to state 88
    arraydefinition                shift and go to state 41

state 143

    (31) ifstatement -> iftype THEN bracedexp ELSE . bracedexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE

    LBRACE          shift and go to state 34

    bracedexp                      shift and go to state 154

state 144

    (45) bracedexp_noscope -> LBRACE code . RBRACE

    RBRACE          shift and go to state 155


state 145

    (24) switchstatement -> SWITCH LPAREN primaryexp RPAREN . DO LBRACE switchbody RBRACE

    DO              shift and go to state 156


state 146

    (73) bracedexp -> LBRACE new_scope code RBRACE .

    FOREACH         reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    BINARY_FNC      reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    LT              reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    GT              reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    LTE             reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    GTE             reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    EQUALITY        reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    INEQUALITY      reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    AND             reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    OR              reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    PLUS            reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    MINUS           reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    TIMES           reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    DIVIDE          reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    MOD             reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    POW             reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    SEMI_COLON      reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    COMMA           reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    $end            reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    RBRACE          reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    RSPAREN         reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    RPAREN          reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    TO              reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    STEP            reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    DO              reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    COLON           reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)
    ELSE            reduce using rule 73 (bracedexp -> LBRACE new_scope code RBRACE .)


state 147

    (80) stringarray -> LSPAREN stringarrayelement RSPAREN .

    SEMI_COLON      reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    COMMA           reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    $end            reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    BINARY_FNC      reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    LT              reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    GT              reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    LTE             reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    GTE             reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    EQUALITY        reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    INEQUALITY      reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    AND             reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    OR              reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    PLUS            reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    MINUS           reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    TIMES           reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    DIVIDE          reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    MOD             reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    POW             reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    RBRACE          reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    RSPAREN         reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    RPAREN          reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    TO              reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    STEP            reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    DO              reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    COLON           reduce using rule 80 (stringarray -> LSPAREN stringarrayelement RSPAREN .)


state 148

    (82) stringarrayelement -> string COMMA . stringarrayelement
    (81) stringarrayelement -> . string
    (82) stringarrayelement -> . string COMMA stringarrayelement
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE

    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51

    string                         shift and go to state 136
    stringarrayelement             shift and go to state 157

state 149

    (43) forloop_condition -> LBRACE booleanexp RBRACE .

    THEN            reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    EXITWITH        reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    BINARY_FNC      reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    LT              reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    GT              reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    LTE             reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    GTE             reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    EQUALITY        reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    INEQUALITY      reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    AND             reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    OR              reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    PLUS            reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    MINUS           reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    TIMES           reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    DIVIDE          reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    MOD             reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    POW             reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    SEMI_COLON      reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    COMMA           reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    $end            reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    RBRACE          reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    RSPAREN         reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    RPAREN          reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    TO              reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    STEP            reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    DO              reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)
    COLON           reduce using rule 43 (forloop_condition -> LBRACE booleanexp RBRACE .)


state 150

    (105) booleanexp -> primaryexp comparisonoperator . booleanexp
    (106) booleanexp -> primaryexp comparisonoperator . LBRACE booleanexp RBRACE
    (61) binaryexp -> primaryexp comparisonoperator . primaryexp
    (104) booleanexp -> . primaryexp
    (105) booleanexp -> . primaryexp comparisonoperator booleanexp
    (106) booleanexp -> . primaryexp comparisonoperator LBRACE booleanexp RBRACE
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (32) withtype -> . WITH NAMESPACE
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (53) arraydefinition -> . PRIVATE stringarray

    LBRACE          shift and go to state 160
    LPAREN          shift and go to state 33
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    PRIVATE_ID      shift and go to state 82
    GLOBAL_ID       shift and go to state 83
    LSPAREN         shift and go to state 45
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    NULAR_FNC       shift and go to state 19
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    WITH            shift and go to state 52
    PRIVATE         shift and go to state 35

    primaryexp                     shift and go to state 158
    booleanexp                     shift and go to state 159
    number                         shift and go to state 39
    identifier                     shift and go to state 77
    helpertype                     shift and go to state 40
    array                          shift and go to state 31
    unaryexp                       shift and go to state 78
    nularexp                       shift and go to state 79
    string                         shift and go to state 37
    binaryexp                      shift and go to state 80
    bracedexp                      shift and go to state 81
    iftype                         shift and go to state 84
    whiletype                      shift and go to state 85
    fortype                        shift and go to state 86
    withtype                       shift and go to state 87
    vardefinition                  shift and go to state 25
    definition                     shift and go to state 88
    arraydefinition                shift and go to state 41

state 151

    (39) fortype -> FOR new_scope string FROM . primaryexp TO primaryexp
    (40) fortype -> FOR new_scope string FROM . primaryexp TO primaryexp STEP primaryexp
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (32) withtype -> . WITH NAMESPACE
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (53) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 33
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    PRIVATE_ID      shift and go to state 82
    GLOBAL_ID       shift and go to state 83
    LSPAREN         shift and go to state 45
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    NULAR_FNC       shift and go to state 19
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    LBRACE          shift and go to state 34
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    WITH            shift and go to state 52
    PRIVATE         shift and go to state 35

    string                         shift and go to state 37
    primaryexp                     shift and go to state 161
    number                         shift and go to state 39
    identifier                     shift and go to state 77
    helpertype                     shift and go to state 40
    array                          shift and go to state 31
    unaryexp                       shift and go to state 78
    nularexp                       shift and go to state 79
    binaryexp                      shift and go to state 80
    bracedexp                      shift and go to state 81
    iftype                         shift and go to state 84
    whiletype                      shift and go to state 85
    fortype                        shift and go to state 86
    withtype                       shift and go to state 87
    vardefinition                  shift and go to state 25
    definition                     shift and go to state 88
    arraydefinition                shift and go to state 41

state 152

    (41) fortype -> FOR new_scope LSPAREN bracedexp_noscope . COMMA forloop_condition COMMA bracedexp_noscope RSPAREN

    COMMA           shift and go to state 162


state 153

    (78) arrayelement -> primaryexp COMMA arrayelement .

    RSPAREN         reduce using rule 78 (arrayelement -> primaryexp COMMA arrayelement .)


state 154

    (31) ifstatement -> iftype THEN bracedexp ELSE bracedexp .

    SEMI_COLON      reduce using rule 31 (ifstatement -> iftype THEN bracedexp ELSE bracedexp .)
    COMMA           reduce using rule 31 (ifstatement -> iftype THEN bracedexp ELSE bracedexp .)
    $end            reduce using rule 31 (ifstatement -> iftype THEN bracedexp ELSE bracedexp .)
    RBRACE          reduce using rule 31 (ifstatement -> iftype THEN bracedexp ELSE bracedexp .)


state 155

    (45) bracedexp_noscope -> LBRACE code RBRACE .

    SEMI_COLON      reduce using rule 45 (bracedexp_noscope -> LBRACE code RBRACE .)
    COMMA           reduce using rule 45 (bracedexp_noscope -> LBRACE code RBRACE .)
    $end            reduce using rule 45 (bracedexp_noscope -> LBRACE code RBRACE .)
    RBRACE          reduce using rule 45 (bracedexp_noscope -> LBRACE code RBRACE .)
    RSPAREN         reduce using rule 45 (bracedexp_noscope -> LBRACE code RBRACE .)


state 156

    (24) switchstatement -> SWITCH LPAREN primaryexp RPAREN DO . LBRACE switchbody RBRACE

    LBRACE          shift and go to state 163


state 157

    (82) stringarrayelement -> string COMMA stringarrayelement .

    RSPAREN         reduce using rule 82 (stringarrayelement -> string COMMA stringarrayelement .)


state 158

    (61) binaryexp -> primaryexp comparisonoperator primaryexp .
    (104) booleanexp -> primaryexp .
    (105) booleanexp -> primaryexp . comparisonoperator booleanexp
    (106) booleanexp -> primaryexp . comparisonoperator LBRACE booleanexp RBRACE
    (60) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (61) binaryexp -> primaryexp . comparisonoperator primaryexp
    (62) binaryexp -> primaryexp . mathoperator primaryexp
    (90) comparisonoperator -> . LT
    (91) comparisonoperator -> . GT
    (92) comparisonoperator -> . LTE
    (93) comparisonoperator -> . GTE
    (94) comparisonoperator -> . EQUALITY
    (95) comparisonoperator -> . INEQUALITY
    (96) comparisonoperator -> . AND
    (97) comparisonoperator -> . OR
    (98) mathoperator -> . PLUS
    (99) mathoperator -> . MINUS
    (100) mathoperator -> . TIMES
    (101) mathoperator -> . DIVIDE
    (102) mathoperator -> . MOD
    (103) mathoperator -> . POW

  ! reduce/reduce conflict for RBRACE resolved using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    BINARY_FNC      reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    LT              reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    GT              reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    LTE             reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    GTE             reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    EQUALITY        reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    INEQUALITY      reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    AND             reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    OR              reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    RBRACE          reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    MOD             shift and go to state 73
    POW             shift and go to state 74

  ! PLUS            [ reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! MINUS           [ reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! TIMES           [ reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! DIVIDE          [ reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! MOD             [ reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! POW             [ reduce using rule 61 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! RBRACE          [ reduce using rule 104 (booleanexp -> primaryexp .) ]
  ! BINARY_FNC      [ shift and go to state 58 ]
  ! LT              [ shift and go to state 61 ]
  ! GT              [ shift and go to state 62 ]
  ! LTE             [ shift and go to state 63 ]
  ! GTE             [ shift and go to state 64 ]
  ! EQUALITY        [ shift and go to state 65 ]
  ! INEQUALITY      [ shift and go to state 66 ]
  ! AND             [ shift and go to state 67 ]
  ! OR              [ shift and go to state 68 ]

    comparisonoperator             shift and go to state 150
    mathoperator                   shift and go to state 60

state 159

    (105) booleanexp -> primaryexp comparisonoperator booleanexp .

    RBRACE          reduce using rule 105 (booleanexp -> primaryexp comparisonoperator booleanexp .)


state 160

    (106) booleanexp -> primaryexp comparisonoperator LBRACE . booleanexp RBRACE
    (73) bracedexp -> LBRACE . new_scope code RBRACE
    (104) booleanexp -> . primaryexp
    (105) booleanexp -> . primaryexp comparisonoperator booleanexp
    (106) booleanexp -> . primaryexp comparisonoperator LBRACE booleanexp RBRACE
    (74) new_scope -> .
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (32) withtype -> . WITH NAMESPACE
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (53) arraydefinition -> . PRIVATE stringarray

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NUMBER_REAL resolved as shift
  ! shift/reduce conflict for NUMBER_EXP resolved as shift
  ! shift/reduce conflict for NUMBER_HEX resolved as shift
  ! shift/reduce conflict for PRIVATE_ID resolved as shift
  ! shift/reduce conflict for GLOBAL_ID resolved as shift
  ! shift/reduce conflict for LSPAREN resolved as shift
  ! shift/reduce conflict for UNARY_FNC resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULAR_FNC resolved as shift
  ! shift/reduce conflict for STRING_SINGLE resolved as shift
  ! shift/reduce conflict for STRING_DOUBLE resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WITH resolved as shift
  ! shift/reduce conflict for PRIVATE resolved as shift
    SWITCH          reduce using rule 74 (new_scope -> .)
    RBRACE          reduce using rule 74 (new_scope -> .)
    LPAREN          shift and go to state 33
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    PRIVATE_ID      shift and go to state 82
    GLOBAL_ID       shift and go to state 83
    LSPAREN         shift and go to state 45
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    NULAR_FNC       shift and go to state 19
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    LBRACE          shift and go to state 34
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    WITH            shift and go to state 52
    PRIVATE         shift and go to state 35

  ! NULAR_FNC       [ reduce using rule 74 (new_scope -> .) ]
  ! UNARY_FNC       [ reduce using rule 74 (new_scope -> .) ]
  ! PLUS            [ reduce using rule 74 (new_scope -> .) ]
  ! MINUS           [ reduce using rule 74 (new_scope -> .) ]
  ! NOT             [ reduce using rule 74 (new_scope -> .) ]
  ! PRIVATE         [ reduce using rule 74 (new_scope -> .) ]
  ! PRIVATE_ID      [ reduce using rule 74 (new_scope -> .) ]
  ! GLOBAL_ID       [ reduce using rule 74 (new_scope -> .) ]
  ! LPAREN          [ reduce using rule 74 (new_scope -> .) ]
  ! IF              [ reduce using rule 74 (new_scope -> .) ]
  ! WHILE           [ reduce using rule 74 (new_scope -> .) ]
  ! FOR             [ reduce using rule 74 (new_scope -> .) ]
  ! LBRACE          [ reduce using rule 74 (new_scope -> .) ]
  ! NUMBER_REAL     [ reduce using rule 74 (new_scope -> .) ]
  ! NUMBER_EXP      [ reduce using rule 74 (new_scope -> .) ]
  ! NUMBER_HEX      [ reduce using rule 74 (new_scope -> .) ]
  ! LSPAREN         [ reduce using rule 74 (new_scope -> .) ]
  ! STRING_SINGLE   [ reduce using rule 74 (new_scope -> .) ]
  ! STRING_DOUBLE   [ reduce using rule 74 (new_scope -> .) ]
  ! WITH            [ reduce using rule 74 (new_scope -> .) ]

    primaryexp                     shift and go to state 138
    booleanexp                     shift and go to state 164
    new_scope                      shift and go to state 100
    number                         shift and go to state 39
    identifier                     shift and go to state 77
    helpertype                     shift and go to state 40
    array                          shift and go to state 31
    unaryexp                       shift and go to state 78
    nularexp                       shift and go to state 79
    string                         shift and go to state 37
    binaryexp                      shift and go to state 80
    bracedexp                      shift and go to state 81
    iftype                         shift and go to state 84
    whiletype                      shift and go to state 85
    fortype                        shift and go to state 86
    withtype                       shift and go to state 87
    vardefinition                  shift and go to state 25
    definition                     shift and go to state 88
    arraydefinition                shift and go to state 41

state 161

    (39) fortype -> FOR new_scope string FROM primaryexp . TO primaryexp
    (40) fortype -> FOR new_scope string FROM primaryexp . TO primaryexp STEP primaryexp
    (60) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (61) binaryexp -> primaryexp . comparisonoperator primaryexp
    (62) binaryexp -> primaryexp . mathoperator primaryexp
    (90) comparisonoperator -> . LT
    (91) comparisonoperator -> . GT
    (92) comparisonoperator -> . LTE
    (93) comparisonoperator -> . GTE
    (94) comparisonoperator -> . EQUALITY
    (95) comparisonoperator -> . INEQUALITY
    (96) comparisonoperator -> . AND
    (97) comparisonoperator -> . OR
    (98) mathoperator -> . PLUS
    (99) mathoperator -> . MINUS
    (100) mathoperator -> . TIMES
    (101) mathoperator -> . DIVIDE
    (102) mathoperator -> . MOD
    (103) mathoperator -> . POW

    TO              shift and go to state 165
    BINARY_FNC      shift and go to state 58
    LT              shift and go to state 61
    GT              shift and go to state 62
    LTE             shift and go to state 63
    GTE             shift and go to state 64
    EQUALITY        shift and go to state 65
    INEQUALITY      shift and go to state 66
    AND             shift and go to state 67
    OR              shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    MOD             shift and go to state 73
    POW             shift and go to state 74

    comparisonoperator             shift and go to state 59
    mathoperator                   shift and go to state 60

state 162

    (41) fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA . forloop_condition COMMA bracedexp_noscope RSPAREN
    (43) forloop_condition -> . LBRACE booleanexp RBRACE
    (44) forloop_condition -> . identifier
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID

    LBRACE          shift and go to state 106
    PRIVATE_ID      shift and go to state 82
    GLOBAL_ID       shift and go to state 83

    forloop_condition              shift and go to state 166
    identifier                     shift and go to state 107

state 163

    (24) switchstatement -> SWITCH LPAREN primaryexp RPAREN DO LBRACE . switchbody RBRACE
    (25) switchbody -> . empty
    (26) switchbody -> . case
    (27) switchbody -> . case terminator switchbody
    (114) empty -> .
    (21) case -> . CASE primaryexp COLON bracedexp
    (22) case -> . CASE primaryexp
    (23) case -> . DEFAULT bracedexp

    RBRACE          reduce using rule 114 (empty -> .)
    CASE            shift and go to state 170
    DEFAULT         shift and go to state 171

    switchbody                     shift and go to state 167
    empty                          shift and go to state 168
    case                           shift and go to state 169

state 164

    (106) booleanexp -> primaryexp comparisonoperator LBRACE booleanexp . RBRACE

    RBRACE          shift and go to state 172


state 165

    (39) fortype -> FOR new_scope string FROM primaryexp TO . primaryexp
    (40) fortype -> FOR new_scope string FROM primaryexp TO . primaryexp STEP primaryexp
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (32) withtype -> . WITH NAMESPACE
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (53) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 33
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    PRIVATE_ID      shift and go to state 82
    GLOBAL_ID       shift and go to state 83
    LSPAREN         shift and go to state 45
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    NULAR_FNC       shift and go to state 19
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    LBRACE          shift and go to state 34
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    WITH            shift and go to state 52
    PRIVATE         shift and go to state 35

    string                         shift and go to state 37
    primaryexp                     shift and go to state 173
    number                         shift and go to state 39
    identifier                     shift and go to state 77
    helpertype                     shift and go to state 40
    array                          shift and go to state 31
    unaryexp                       shift and go to state 78
    nularexp                       shift and go to state 79
    binaryexp                      shift and go to state 80
    bracedexp                      shift and go to state 81
    iftype                         shift and go to state 84
    whiletype                      shift and go to state 85
    fortype                        shift and go to state 86
    withtype                       shift and go to state 87
    vardefinition                  shift and go to state 25
    definition                     shift and go to state 88
    arraydefinition                shift and go to state 41

state 166

    (41) fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition . COMMA bracedexp_noscope RSPAREN

    COMMA           shift and go to state 174


state 167

    (24) switchstatement -> SWITCH LPAREN primaryexp RPAREN DO LBRACE switchbody . RBRACE

    RBRACE          shift and go to state 175


state 168

    (25) switchbody -> empty .

    RBRACE          reduce using rule 25 (switchbody -> empty .)


state 169

    (26) switchbody -> case .
    (27) switchbody -> case . terminator switchbody
    (9) terminator -> . SEMI_COLON
    (10) terminator -> . COMMA

    RBRACE          reduce using rule 26 (switchbody -> case .)
    SEMI_COLON      shift and go to state 54
    COMMA           shift and go to state 55

    terminator                     shift and go to state 176

state 170

    (21) case -> CASE . primaryexp COLON bracedexp
    (22) case -> CASE . primaryexp
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (32) withtype -> . WITH NAMESPACE
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (53) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 33
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    PRIVATE_ID      shift and go to state 82
    GLOBAL_ID       shift and go to state 83
    LSPAREN         shift and go to state 45
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    NULAR_FNC       shift and go to state 19
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    LBRACE          shift and go to state 34
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    WITH            shift and go to state 52
    PRIVATE         shift and go to state 35

    primaryexp                     shift and go to state 177
    bracedexp                      shift and go to state 81
    number                         shift and go to state 39
    identifier                     shift and go to state 77
    helpertype                     shift and go to state 40
    array                          shift and go to state 31
    unaryexp                       shift and go to state 78
    nularexp                       shift and go to state 79
    string                         shift and go to state 37
    binaryexp                      shift and go to state 80
    iftype                         shift and go to state 84
    whiletype                      shift and go to state 85
    fortype                        shift and go to state 86
    withtype                       shift and go to state 87
    vardefinition                  shift and go to state 25
    definition                     shift and go to state 88
    arraydefinition                shift and go to state 41

state 171

    (23) case -> DEFAULT . bracedexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE

    LBRACE          shift and go to state 34

    bracedexp                      shift and go to state 178

state 172

    (106) booleanexp -> primaryexp comparisonoperator LBRACE booleanexp RBRACE .

    RBRACE          reduce using rule 106 (booleanexp -> primaryexp comparisonoperator LBRACE booleanexp RBRACE .)


state 173

    (39) fortype -> FOR new_scope string FROM primaryexp TO primaryexp .
    (40) fortype -> FOR new_scope string FROM primaryexp TO primaryexp . STEP primaryexp
    (60) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (61) binaryexp -> primaryexp . comparisonoperator primaryexp
    (62) binaryexp -> primaryexp . mathoperator primaryexp
    (90) comparisonoperator -> . LT
    (91) comparisonoperator -> . GT
    (92) comparisonoperator -> . LTE
    (93) comparisonoperator -> . GTE
    (94) comparisonoperator -> . EQUALITY
    (95) comparisonoperator -> . INEQUALITY
    (96) comparisonoperator -> . AND
    (97) comparisonoperator -> . OR
    (98) mathoperator -> . PLUS
    (99) mathoperator -> . MINUS
    (100) mathoperator -> . TIMES
    (101) mathoperator -> . DIVIDE
    (102) mathoperator -> . MOD
    (103) mathoperator -> . POW

  ! shift/reduce conflict for STEP resolved as shift
  ! shift/reduce conflict for BINARY_FNC resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for EQUALITY resolved as shift
  ! shift/reduce conflict for INEQUALITY resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    DO              reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    SEMI_COLON      reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    COMMA           reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    $end            reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    RBRACE          reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    RSPAREN         reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    RPAREN          reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    TO              reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    COLON           reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    STEP            shift and go to state 179
    BINARY_FNC      shift and go to state 58
    LT              shift and go to state 61
    GT              shift and go to state 62
    LTE             shift and go to state 63
    GTE             shift and go to state 64
    EQUALITY        shift and go to state 65
    INEQUALITY      shift and go to state 66
    AND             shift and go to state 67
    OR              shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    MOD             shift and go to state 73
    POW             shift and go to state 74

  ! BINARY_FNC      [ reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! LT              [ reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! GT              [ reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! LTE             [ reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! GTE             [ reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! EQUALITY        [ reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! INEQUALITY      [ reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! AND             [ reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! OR              [ reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! PLUS            [ reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! MINUS           [ reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! TIMES           [ reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! DIVIDE          [ reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! MOD             [ reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! POW             [ reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! STEP            [ reduce using rule 39 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]

    comparisonoperator             shift and go to state 59
    mathoperator                   shift and go to state 60

state 174

    (41) fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA . bracedexp_noscope RSPAREN
    (45) bracedexp_noscope -> . LBRACE code RBRACE

    LBRACE          shift and go to state 130

    bracedexp_noscope              shift and go to state 180

state 175

    (24) switchstatement -> SWITCH LPAREN primaryexp RPAREN DO LBRACE switchbody RBRACE .

    SEMI_COLON      reduce using rule 24 (switchstatement -> SWITCH LPAREN primaryexp RPAREN DO LBRACE switchbody RBRACE .)
    COMMA           reduce using rule 24 (switchstatement -> SWITCH LPAREN primaryexp RPAREN DO LBRACE switchbody RBRACE .)
    $end            reduce using rule 24 (switchstatement -> SWITCH LPAREN primaryexp RPAREN DO LBRACE switchbody RBRACE .)
    RBRACE          reduce using rule 24 (switchstatement -> SWITCH LPAREN primaryexp RPAREN DO LBRACE switchbody RBRACE .)


state 176

    (27) switchbody -> case terminator . switchbody
    (25) switchbody -> . empty
    (26) switchbody -> . case
    (27) switchbody -> . case terminator switchbody
    (114) empty -> .
    (21) case -> . CASE primaryexp COLON bracedexp
    (22) case -> . CASE primaryexp
    (23) case -> . DEFAULT bracedexp

    RBRACE          reduce using rule 114 (empty -> .)
    CASE            shift and go to state 170
    DEFAULT         shift and go to state 171

    case                           shift and go to state 169
    switchbody                     shift and go to state 181
    empty                          shift and go to state 168

state 177

    (21) case -> CASE primaryexp . COLON bracedexp
    (22) case -> CASE primaryexp .
    (60) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (61) binaryexp -> primaryexp . comparisonoperator primaryexp
    (62) binaryexp -> primaryexp . mathoperator primaryexp
    (90) comparisonoperator -> . LT
    (91) comparisonoperator -> . GT
    (92) comparisonoperator -> . LTE
    (93) comparisonoperator -> . GTE
    (94) comparisonoperator -> . EQUALITY
    (95) comparisonoperator -> . INEQUALITY
    (96) comparisonoperator -> . AND
    (97) comparisonoperator -> . OR
    (98) mathoperator -> . PLUS
    (99) mathoperator -> . MINUS
    (100) mathoperator -> . TIMES
    (101) mathoperator -> . DIVIDE
    (102) mathoperator -> . MOD
    (103) mathoperator -> . POW

    COLON           shift and go to state 182
    SEMI_COLON      reduce using rule 22 (case -> CASE primaryexp .)
    COMMA           reduce using rule 22 (case -> CASE primaryexp .)
    RBRACE          reduce using rule 22 (case -> CASE primaryexp .)
    BINARY_FNC      shift and go to state 58
    LT              shift and go to state 61
    GT              shift and go to state 62
    LTE             shift and go to state 63
    GTE             shift and go to state 64
    EQUALITY        shift and go to state 65
    INEQUALITY      shift and go to state 66
    AND             shift and go to state 67
    OR              shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    MOD             shift and go to state 73
    POW             shift and go to state 74

    comparisonoperator             shift and go to state 59
    mathoperator                   shift and go to state 60

state 178

    (23) case -> DEFAULT bracedexp .

    SEMI_COLON      reduce using rule 23 (case -> DEFAULT bracedexp .)
    COMMA           reduce using rule 23 (case -> DEFAULT bracedexp .)
    RBRACE          reduce using rule 23 (case -> DEFAULT bracedexp .)


state 179

    (40) fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP . primaryexp
    (63) primaryexp -> . number
    (64) primaryexp -> . identifier
    (65) primaryexp -> . helpertype
    (66) primaryexp -> . array
    (67) primaryexp -> . unaryexp
    (68) primaryexp -> . nularexp
    (69) primaryexp -> . string
    (70) primaryexp -> . binaryexp
    (71) primaryexp -> . bracedexp
    (72) primaryexp -> . LPAREN binaryexp RPAREN
    (109) number -> . NUMBER_REAL
    (110) number -> . NUMBER_EXP
    (111) number -> . NUMBER_HEX
    (56) identifier -> . PRIVATE_ID
    (57) identifier -> . GLOBAL_ID
    (17) helpertype -> . iftype
    (18) helpertype -> . whiletype
    (19) helpertype -> . fortype
    (20) helpertype -> . withtype
    (75) array -> . LSPAREN RSPAREN
    (76) array -> . LSPAREN arrayelement RSPAREN
    (85) unaryexp -> . UNARY_FNC primaryexp
    (86) unaryexp -> . PLUS primaryexp
    (87) unaryexp -> . MINUS primaryexp
    (88) unaryexp -> . NOT primaryexp
    (89) unaryexp -> . vardefinition
    (83) nularexp -> . NULAR_FNC
    (84) nularexp -> . identifier
    (112) string -> . STRING_SINGLE
    (113) string -> . STRING_DOUBLE
    (60) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (61) binaryexp -> . primaryexp comparisonoperator primaryexp
    (62) binaryexp -> . primaryexp mathoperator primaryexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE
    (28) iftype -> . IF forloop_condition
    (35) whiletype -> . WHILE forloop_condition
    (39) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (40) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (41) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (32) withtype -> . WITH NAMESPACE
    (46) vardefinition -> . definition
    (47) vardefinition -> . arraydefinition
    (54) definition -> . PRIVATE PRIVATE_ID
    (55) definition -> . PRIVATE string
    (53) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 33
    NUMBER_REAL     shift and go to state 47
    NUMBER_EXP      shift and go to state 48
    NUMBER_HEX      shift and go to state 49
    PRIVATE_ID      shift and go to state 82
    GLOBAL_ID       shift and go to state 83
    LSPAREN         shift and go to state 45
    UNARY_FNC       shift and go to state 21
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    NOT             shift and go to state 24
    NULAR_FNC       shift and go to state 19
    STRING_SINGLE   shift and go to state 50
    STRING_DOUBLE   shift and go to state 51
    LBRACE          shift and go to state 34
    IF              shift and go to state 42
    WHILE           shift and go to state 43
    FOR             shift and go to state 44
    WITH            shift and go to state 52
    PRIVATE         shift and go to state 35

    string                         shift and go to state 37
    primaryexp                     shift and go to state 183
    number                         shift and go to state 39
    identifier                     shift and go to state 77
    helpertype                     shift and go to state 40
    array                          shift and go to state 31
    unaryexp                       shift and go to state 78
    nularexp                       shift and go to state 79
    binaryexp                      shift and go to state 80
    bracedexp                      shift and go to state 81
    iftype                         shift and go to state 84
    whiletype                      shift and go to state 85
    fortype                        shift and go to state 86
    withtype                       shift and go to state 87
    vardefinition                  shift and go to state 25
    definition                     shift and go to state 88
    arraydefinition                shift and go to state 41

state 180

    (41) fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope . RSPAREN

    RSPAREN         shift and go to state 184


state 181

    (27) switchbody -> case terminator switchbody .

    RBRACE          reduce using rule 27 (switchbody -> case terminator switchbody .)


state 182

    (21) case -> CASE primaryexp COLON . bracedexp
    (73) bracedexp -> . LBRACE new_scope code RBRACE

    LBRACE          shift and go to state 34

    bracedexp                      shift and go to state 185

state 183

    (40) fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .
    (60) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (61) binaryexp -> primaryexp . comparisonoperator primaryexp
    (62) binaryexp -> primaryexp . mathoperator primaryexp
    (90) comparisonoperator -> . LT
    (91) comparisonoperator -> . GT
    (92) comparisonoperator -> . LTE
    (93) comparisonoperator -> . GTE
    (94) comparisonoperator -> . EQUALITY
    (95) comparisonoperator -> . INEQUALITY
    (96) comparisonoperator -> . AND
    (97) comparisonoperator -> . OR
    (98) mathoperator -> . PLUS
    (99) mathoperator -> . MINUS
    (100) mathoperator -> . TIMES
    (101) mathoperator -> . DIVIDE
    (102) mathoperator -> . MOD
    (103) mathoperator -> . POW

  ! shift/reduce conflict for BINARY_FNC resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for EQUALITY resolved as shift
  ! shift/reduce conflict for INEQUALITY resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    DO              reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    SEMI_COLON      reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    COMMA           reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    $end            reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    RBRACE          reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    RSPAREN         reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    RPAREN          reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    TO              reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    STEP            reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    COLON           reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    BINARY_FNC      shift and go to state 58
    LT              shift and go to state 61
    GT              shift and go to state 62
    LTE             shift and go to state 63
    GTE             shift and go to state 64
    EQUALITY        shift and go to state 65
    INEQUALITY      shift and go to state 66
    AND             shift and go to state 67
    OR              shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    DIVIDE          shift and go to state 72
    MOD             shift and go to state 73
    POW             shift and go to state 74

  ! BINARY_FNC      [ reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! LT              [ reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! GT              [ reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! LTE             [ reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! GTE             [ reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! EQUALITY        [ reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! INEQUALITY      [ reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! AND             [ reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! OR              [ reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! PLUS            [ reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! MINUS           [ reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! TIMES           [ reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! DIVIDE          [ reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! MOD             [ reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! POW             [ reduce using rule 40 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]

    comparisonoperator             shift and go to state 59
    mathoperator                   shift and go to state 60

state 184

    (41) fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .

    DO              reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    BINARY_FNC      reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    LT              reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    GT              reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    LTE             reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    GTE             reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    EQUALITY        reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    INEQUALITY      reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    AND             reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    OR              reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    PLUS            reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    MINUS           reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    TIMES           reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    DIVIDE          reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    MOD             reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    POW             reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    SEMI_COLON      reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    COMMA           reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    $end            reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    RBRACE          reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    RSPAREN         reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    RPAREN          reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    TO              reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    STEP            reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    COLON           reduce using rule 41 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)


state 185

    (21) case -> CASE primaryexp COLON bracedexp .

    SEMI_COLON      reduce using rule 21 (case -> CASE primaryexp COLON bracedexp .)
    COMMA           reduce using rule 21 (case -> CASE primaryexp COLON bracedexp .)
    RBRACE          reduce using rule 21 (case -> CASE primaryexp COLON bracedexp .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPAREN in state 160 resolved as shift
WARNING: shift/reduce conflict for NUMBER_REAL in state 160 resolved as shift
WARNING: shift/reduce conflict for NUMBER_EXP in state 160 resolved as shift
WARNING: shift/reduce conflict for NUMBER_HEX in state 160 resolved as shift
WARNING: shift/reduce conflict for PRIVATE_ID in state 160 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_ID in state 160 resolved as shift
WARNING: shift/reduce conflict for LSPAREN in state 160 resolved as shift
WARNING: shift/reduce conflict for UNARY_FNC in state 160 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 160 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 160 resolved as shift
WARNING: shift/reduce conflict for NOT in state 160 resolved as shift
WARNING: shift/reduce conflict for NULAR_FNC in state 160 resolved as shift
WARNING: shift/reduce conflict for STRING_SINGLE in state 160 resolved as shift
WARNING: shift/reduce conflict for STRING_DOUBLE in state 160 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 160 resolved as shift
WARNING: shift/reduce conflict for IF in state 160 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 160 resolved as shift
WARNING: shift/reduce conflict for FOR in state 160 resolved as shift
WARNING: shift/reduce conflict for WITH in state 160 resolved as shift
WARNING: shift/reduce conflict for PRIVATE in state 160 resolved as shift
WARNING: shift/reduce conflict for STEP in state 173 resolved as shift
WARNING: shift/reduce conflict for BINARY_FNC in state 173 resolved as shift
WARNING: shift/reduce conflict for LT in state 173 resolved as shift
WARNING: shift/reduce conflict for GT in state 173 resolved as shift
WARNING: shift/reduce conflict for LTE in state 173 resolved as shift
WARNING: shift/reduce conflict for GTE in state 173 resolved as shift
WARNING: shift/reduce conflict for EQUALITY in state 173 resolved as shift
WARNING: shift/reduce conflict for INEQUALITY in state 173 resolved as shift
WARNING: shift/reduce conflict for AND in state 173 resolved as shift
WARNING: shift/reduce conflict for OR in state 173 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 173 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 173 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 173 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 173 resolved as shift
WARNING: shift/reduce conflict for MOD in state 173 resolved as shift
WARNING: shift/reduce conflict for POW in state 173 resolved as shift
WARNING: shift/reduce conflict for BINARY_FNC in state 183 resolved as shift
WARNING: shift/reduce conflict for LT in state 183 resolved as shift
WARNING: shift/reduce conflict for GT in state 183 resolved as shift
WARNING: shift/reduce conflict for LTE in state 183 resolved as shift
WARNING: shift/reduce conflict for GTE in state 183 resolved as shift
WARNING: shift/reduce conflict for EQUALITY in state 183 resolved as shift
WARNING: shift/reduce conflict for INEQUALITY in state 183 resolved as shift
WARNING: shift/reduce conflict for AND in state 183 resolved as shift
WARNING: shift/reduce conflict for OR in state 183 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 183 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 183 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 183 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 183 resolved as shift
WARNING: shift/reduce conflict for MOD in state 183 resolved as shift
WARNING: shift/reduce conflict for POW in state 183 resolved as shift
WARNING: reduce/reduce conflict in state 20 resolved using rule (primaryexp -> identifier)
WARNING: rejected rule (nularexp -> identifier) in state 20
WARNING: reduce/reduce conflict in state 77 resolved using rule (primaryexp -> identifier)
WARNING: rejected rule (nularexp -> identifier) in state 77
WARNING: reduce/reduce conflict in state 118 resolved using rule (assignment_code -> definition EQUAL LBRACE)
WARNING: rejected rule (new_scope -> <empty>) in state 118
WARNING: reduce/reduce conflict in state 123 resolved using rule (assignment_code -> variable EQUAL LBRACE)
WARNING: rejected rule (new_scope -> <empty>) in state 123
WARNING: reduce/reduce conflict in state 126 resolved using rule (foreachloop -> bracedexp FOREACH array)
WARNING: rejected rule (primaryexp -> array) in state 126
WARNING: reduce/reduce conflict in state 158 resolved using rule (binaryexp -> primaryexp comparisonoperator primaryexp)
WARNING: rejected rule (booleanexp -> primaryexp) in state 158
