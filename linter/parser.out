Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOL
    COLON
    COMMENT_MULTI
    COMMENT_SINGLE
    FOREACH
    NEWLINE
    SWITCH

Grammar

Rule 0     S' -> code
Rule 1     code -> empty
Rule 2     code -> statement
Rule 3     code -> statement terminator code
Rule 4     statement -> controlstructure
Rule 5     statement -> assignment
Rule 6     statement -> binaryexp
Rule 7     statement -> nularexp
Rule 8     statement -> unaryexp
Rule 9     terminator -> SEMI_COLON
Rule 10    terminator -> COMMA
Rule 11    controlstructure -> ifstatement
Rule 12    controlstructure -> whileloop
Rule 13    controlstructure -> forloop
Rule 14    controlstructure -> withstatement
Rule 15    helpertype -> iftype
Rule 16    helpertype -> whiletype
Rule 17    helpertype -> fortype
Rule 18    helpertype -> withtype
Rule 19    iftype -> IF forloop_condition
Rule 20    ifstatement -> iftype THEN bracedexp
Rule 21    ifstatement -> iftype EXITWITH bracedexp
Rule 22    ifstatement -> iftype THEN bracedexp ELSE bracedexp
Rule 23    withtype -> WITH NAMESPACE
Rule 24    withstatementinit -> withtype DO
Rule 25    withstatement -> withstatementinit bracedexp
Rule 26    whiletype -> WHILE forloop_condition
Rule 27    whileloop -> whiletype DO bracedexp
Rule 28    fortype -> FOR new_scope string FROM primaryexp TO primaryexp
Rule 29    fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
Rule 30    fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
Rule 31    forloop -> fortype DO bracedexp_noscope
Rule 32    forloop_condition -> LBRACE booleanexp RBRACE
Rule 33    forloop_condition -> identifier
Rule 34    bracedexp_noscope -> LBRACE code RBRACE
Rule 35    vardefinition -> definition
Rule 36    vardefinition -> arraydefinition
Rule 37    assignment -> assignment_code code RBRACE
Rule 38    assignment -> definition EQUAL primaryexp
Rule 39    assignment -> variable EQUAL primaryexp
Rule 40    assignment_code -> definition EQUAL LBRACE
Rule 41    assignment_code -> variable EQUAL LBRACE
Rule 42    arraydefinition -> PRIVATE stringarray
Rule 43    definition -> PRIVATE PRIVATE_ID
Rule 44    definition -> PRIVATE string
Rule 45    identifier -> PRIVATE_ID
Rule 46    identifier -> GLOBAL_ID
Rule 47    variable -> PRIVATE_ID
Rule 48    variable -> GLOBAL_ID
Rule 49    binaryexp -> primaryexp BINARY_FNC primaryexp
Rule 50    binaryexp -> primaryexp comparisonoperator primaryexp
Rule 51    binaryexp -> primaryexp mathoperator primaryexp
Rule 52    primaryexp -> number
Rule 53    primaryexp -> identifier
Rule 54    primaryexp -> helpertype
Rule 55    primaryexp -> unaryexp
Rule 56    primaryexp -> nularexp
Rule 57    primaryexp -> string
Rule 58    primaryexp -> binaryexp
Rule 59    primaryexp -> bracedexp
Rule 60    primaryexp -> LPAREN binaryexp RPAREN
Rule 61    primaryexp -> array
Rule 62    bracedexp -> LBRACE new_scope code RBRACE
Rule 63    new_scope -> <empty>
Rule 64    array -> LSPAREN RSPAREN
Rule 65    array -> LSPAREN arrayelement RSPAREN
Rule 66    arrayelement -> binaryexp
Rule 67    arrayelement -> binaryexp COMMA arrayelement
Rule 68    stringarray -> LSPAREN RSPAREN
Rule 69    stringarray -> LSPAREN stringarrayelement RSPAREN
Rule 70    stringarrayelement -> string
Rule 71    stringarrayelement -> string COMMA stringarrayelement
Rule 72    nularexp -> NULAR_FNC
Rule 73    nularexp -> identifier
Rule 74    unaryexp -> UNARY_FNC primaryexp
Rule 75    unaryexp -> PLUS primaryexp
Rule 76    unaryexp -> MINUS primaryexp
Rule 77    unaryexp -> NOT primaryexp
Rule 78    unaryexp -> vardefinition
Rule 79    comparisonoperator -> LT
Rule 80    comparisonoperator -> GT
Rule 81    comparisonoperator -> LTE
Rule 82    comparisonoperator -> GTE
Rule 83    comparisonoperator -> EQUALITY
Rule 84    comparisonoperator -> INEQUALITY
Rule 85    comparisonoperator -> AND
Rule 86    comparisonoperator -> OR
Rule 87    mathoperator -> PLUS
Rule 88    mathoperator -> MINUS
Rule 89    mathoperator -> TIMES
Rule 90    mathoperator -> DIVIDE
Rule 91    mathoperator -> MOD
Rule 92    mathoperator -> POW
Rule 93    booleanexp -> primaryexp
Rule 94    booleanexp -> primaryexp comparisonoperator booleanexp
Rule 95    booleanexp -> primaryexp comparisonoperator LBRACE booleanexp RBRACE
Rule 96    configaccessor -> GT GT
Rule 97    configaccessor -> DIVIDE
Rule 98    number -> NUMBER_REAL
Rule 99    number -> NUMBER_EXP
Rule 100   number -> NUMBER_HEX
Rule 101   string -> STRING_SINGLE
Rule 102   string -> STRING_DOUBLE
Rule 103   empty -> <empty>

Terminals, with rules where they appear

AND                  : 85
BINARY_FNC           : 49
BOOL                 : 
COLON                : 
COMMA                : 10 30 30 67 71
COMMENT_MULTI        : 
COMMENT_SINGLE       : 
DIVIDE               : 90 97
DO                   : 24 27 31
ELSE                 : 22
EQUAL                : 38 39 40 41
EQUALITY             : 83
EXITWITH             : 21
FOR                  : 28 29 30
FOREACH              : 
FROM                 : 28 29
GLOBAL_ID            : 46 48
GT                   : 80 96 96
GTE                  : 82
IF                   : 19
INEQUALITY           : 84
LBRACE               : 32 34 40 41 62 95
LPAREN               : 60
LSPAREN              : 30 64 65 68 69
LT                   : 79
LTE                  : 81
MINUS                : 76 88
MOD                  : 91
NAMESPACE            : 23
NEWLINE              : 
NOT                  : 77
NULAR_FNC            : 72
NUMBER_EXP           : 99
NUMBER_HEX           : 100
NUMBER_REAL          : 98
OR                   : 86
PLUS                 : 75 87
POW                  : 92
PRIVATE              : 42 43 44
PRIVATE_ID           : 43 45 47
RBRACE               : 32 34 37 62 95
RPAREN               : 60
RSPAREN              : 30 64 65 68 69
SEMI_COLON           : 9
STEP                 : 29
STRING_DOUBLE        : 102
STRING_SINGLE        : 101
SWITCH               : 
THEN                 : 20 22
TIMES                : 89
TO                   : 28 29
UNARY_FNC            : 74
WHILE                : 26
WITH                 : 23
error                : 

Nonterminals, with rules where they appear

array                : 61
arraydefinition      : 36
arrayelement         : 65 67
assignment           : 5
assignment_code      : 37
binaryexp            : 6 58 60 66 67
booleanexp           : 32 94 95
bracedexp            : 20 21 22 22 25 27 59
bracedexp_noscope    : 30 30 31
code                 : 3 34 37 62 0
comparisonoperator   : 50 94 95
configaccessor       : 
controlstructure     : 4
definition           : 35 38 40
empty                : 1
forloop              : 13
forloop_condition    : 19 26 30
fortype              : 17 31
helpertype           : 54
identifier           : 33 53 73
ifstatement          : 11
iftype               : 15 20 21 22
mathoperator         : 51
new_scope            : 28 29 30 62
nularexp             : 7 56
number               : 52
primaryexp           : 28 28 29 29 29 38 39 49 49 50 50 51 51 74 75 76 77 93 94 95
statement            : 2 3
string               : 28 29 44 57 70 71
stringarray          : 42
stringarrayelement   : 69 71
terminator           : 3
unaryexp             : 8 55
vardefinition        : 78
variable             : 39 41
whileloop            : 12
whiletype            : 16 27
withstatement        : 14
withstatementinit    : 25
withtype             : 18 24

Parsing method: LALR

state 0

    (0) S' -> . code
    (1) code -> . empty
    (2) code -> . statement
    (3) code -> . statement terminator code
    (103) empty -> .
    (4) statement -> . controlstructure
    (5) statement -> . assignment
    (6) statement -> . binaryexp
    (7) statement -> . nularexp
    (8) statement -> . unaryexp
    (11) controlstructure -> . ifstatement
    (12) controlstructure -> . whileloop
    (13) controlstructure -> . forloop
    (14) controlstructure -> . withstatement
    (37) assignment -> . assignment_code code RBRACE
    (38) assignment -> . definition EQUAL primaryexp
    (39) assignment -> . variable EQUAL primaryexp
    (49) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (50) binaryexp -> . primaryexp comparisonoperator primaryexp
    (51) binaryexp -> . primaryexp mathoperator primaryexp
    (72) nularexp -> . NULAR_FNC
    (73) nularexp -> . identifier
    (74) unaryexp -> . UNARY_FNC primaryexp
    (75) unaryexp -> . PLUS primaryexp
    (76) unaryexp -> . MINUS primaryexp
    (77) unaryexp -> . NOT primaryexp
    (78) unaryexp -> . vardefinition
    (20) ifstatement -> . iftype THEN bracedexp
    (21) ifstatement -> . iftype EXITWITH bracedexp
    (22) ifstatement -> . iftype THEN bracedexp ELSE bracedexp
    (27) whileloop -> . whiletype DO bracedexp
    (31) forloop -> . fortype DO bracedexp_noscope
    (25) withstatement -> . withstatementinit bracedexp
    (40) assignment_code -> . definition EQUAL LBRACE
    (41) assignment_code -> . variable EQUAL LBRACE
    (43) definition -> . PRIVATE PRIVATE_ID
    (44) definition -> . PRIVATE string
    (47) variable -> . PRIVATE_ID
    (48) variable -> . GLOBAL_ID
    (52) primaryexp -> . number
    (53) primaryexp -> . identifier
    (54) primaryexp -> . helpertype
    (55) primaryexp -> . unaryexp
    (56) primaryexp -> . nularexp
    (57) primaryexp -> . string
    (58) primaryexp -> . binaryexp
    (59) primaryexp -> . bracedexp
    (60) primaryexp -> . LPAREN binaryexp RPAREN
    (61) primaryexp -> . array
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID
    (35) vardefinition -> . definition
    (36) vardefinition -> . arraydefinition
    (19) iftype -> . IF forloop_condition
    (26) whiletype -> . WHILE forloop_condition
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (24) withstatementinit -> . withtype DO
    (98) number -> . NUMBER_REAL
    (99) number -> . NUMBER_EXP
    (100) number -> . NUMBER_HEX
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE
    (62) bracedexp -> . LBRACE new_scope code RBRACE
    (64) array -> . LSPAREN RSPAREN
    (65) array -> . LSPAREN arrayelement RSPAREN
    (42) arraydefinition -> . PRIVATE stringarray
    (23) withtype -> . WITH NAMESPACE

    $end            reduce using rule 103 (empty -> .)
    NULAR_FNC       shift and go to state 17
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    PRIVATE         shift and go to state 30
    PRIVATE_ID      shift and go to state 31
    GLOBAL_ID       shift and go to state 33
    LPAREN          shift and go to state 36
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    NUMBER_REAL     shift and go to state 44
    NUMBER_EXP      shift and go to state 45
    NUMBER_HEX      shift and go to state 46
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 42
    WITH            shift and go to state 49

    code                           shift and go to state 1
    empty                          shift and go to state 2
    statement                      shift and go to state 3
    controlstructure               shift and go to state 4
    assignment                     shift and go to state 5
    binaryexp                      shift and go to state 6
    nularexp                       shift and go to state 7
    unaryexp                       shift and go to state 8
    ifstatement                    shift and go to state 9
    whileloop                      shift and go to state 10
    forloop                        shift and go to state 11
    withstatement                  shift and go to state 12
    assignment_code                shift and go to state 13
    definition                     shift and go to state 14
    primaryexp                     shift and go to state 15
    variable                       shift and go to state 16
    identifier                     shift and go to state 18
    vardefinition                  shift and go to state 23
    iftype                         shift and go to state 24
    bracedexp                      shift and go to state 25
    whiletype                      shift and go to state 26
    fortype                        shift and go to state 27
    withstatementinit              shift and go to state 28
    string                         shift and go to state 32
    number                         shift and go to state 34
    helpertype                     shift and go to state 35
    array                          shift and go to state 37
    arraydefinition                shift and go to state 38
    withtype                       shift and go to state 43

state 1

    (0) S' -> code .



state 2

    (1) code -> empty .

    $end            reduce using rule 1 (code -> empty .)
    RBRACE          reduce using rule 1 (code -> empty .)


state 3

    (2) code -> statement .
    (3) code -> statement . terminator code
    (9) terminator -> . SEMI_COLON
    (10) terminator -> . COMMA

    $end            reduce using rule 2 (code -> statement .)
    RBRACE          reduce using rule 2 (code -> statement .)
    SEMI_COLON      shift and go to state 51
    COMMA           shift and go to state 52

    terminator                     shift and go to state 50

state 4

    (4) statement -> controlstructure .

    SEMI_COLON      reduce using rule 4 (statement -> controlstructure .)
    COMMA           reduce using rule 4 (statement -> controlstructure .)
    $end            reduce using rule 4 (statement -> controlstructure .)
    RBRACE          reduce using rule 4 (statement -> controlstructure .)


state 5

    (5) statement -> assignment .

    SEMI_COLON      reduce using rule 5 (statement -> assignment .)
    COMMA           reduce using rule 5 (statement -> assignment .)
    $end            reduce using rule 5 (statement -> assignment .)
    RBRACE          reduce using rule 5 (statement -> assignment .)


state 6

    (6) statement -> binaryexp .
    (58) primaryexp -> binaryexp .

    SEMI_COLON      reduce using rule 6 (statement -> binaryexp .)
    COMMA           reduce using rule 6 (statement -> binaryexp .)
    $end            reduce using rule 6 (statement -> binaryexp .)
    RBRACE          reduce using rule 6 (statement -> binaryexp .)
    BINARY_FNC      reduce using rule 58 (primaryexp -> binaryexp .)
    LT              reduce using rule 58 (primaryexp -> binaryexp .)
    GT              reduce using rule 58 (primaryexp -> binaryexp .)
    LTE             reduce using rule 58 (primaryexp -> binaryexp .)
    GTE             reduce using rule 58 (primaryexp -> binaryexp .)
    EQUALITY        reduce using rule 58 (primaryexp -> binaryexp .)
    INEQUALITY      reduce using rule 58 (primaryexp -> binaryexp .)
    AND             reduce using rule 58 (primaryexp -> binaryexp .)
    OR              reduce using rule 58 (primaryexp -> binaryexp .)
    PLUS            reduce using rule 58 (primaryexp -> binaryexp .)
    MINUS           reduce using rule 58 (primaryexp -> binaryexp .)
    TIMES           reduce using rule 58 (primaryexp -> binaryexp .)
    DIVIDE          reduce using rule 58 (primaryexp -> binaryexp .)
    MOD             reduce using rule 58 (primaryexp -> binaryexp .)
    POW             reduce using rule 58 (primaryexp -> binaryexp .)


state 7

    (7) statement -> nularexp .
    (56) primaryexp -> nularexp .

    SEMI_COLON      reduce using rule 7 (statement -> nularexp .)
    COMMA           reduce using rule 7 (statement -> nularexp .)
    $end            reduce using rule 7 (statement -> nularexp .)
    RBRACE          reduce using rule 7 (statement -> nularexp .)
    BINARY_FNC      reduce using rule 56 (primaryexp -> nularexp .)
    LT              reduce using rule 56 (primaryexp -> nularexp .)
    GT              reduce using rule 56 (primaryexp -> nularexp .)
    LTE             reduce using rule 56 (primaryexp -> nularexp .)
    GTE             reduce using rule 56 (primaryexp -> nularexp .)
    EQUALITY        reduce using rule 56 (primaryexp -> nularexp .)
    INEQUALITY      reduce using rule 56 (primaryexp -> nularexp .)
    AND             reduce using rule 56 (primaryexp -> nularexp .)
    OR              reduce using rule 56 (primaryexp -> nularexp .)
    PLUS            reduce using rule 56 (primaryexp -> nularexp .)
    MINUS           reduce using rule 56 (primaryexp -> nularexp .)
    TIMES           reduce using rule 56 (primaryexp -> nularexp .)
    DIVIDE          reduce using rule 56 (primaryexp -> nularexp .)
    MOD             reduce using rule 56 (primaryexp -> nularexp .)
    POW             reduce using rule 56 (primaryexp -> nularexp .)


state 8

    (8) statement -> unaryexp .
    (55) primaryexp -> unaryexp .

    SEMI_COLON      reduce using rule 8 (statement -> unaryexp .)
    COMMA           reduce using rule 8 (statement -> unaryexp .)
    $end            reduce using rule 8 (statement -> unaryexp .)
    RBRACE          reduce using rule 8 (statement -> unaryexp .)
    BINARY_FNC      reduce using rule 55 (primaryexp -> unaryexp .)
    LT              reduce using rule 55 (primaryexp -> unaryexp .)
    GT              reduce using rule 55 (primaryexp -> unaryexp .)
    LTE             reduce using rule 55 (primaryexp -> unaryexp .)
    GTE             reduce using rule 55 (primaryexp -> unaryexp .)
    EQUALITY        reduce using rule 55 (primaryexp -> unaryexp .)
    INEQUALITY      reduce using rule 55 (primaryexp -> unaryexp .)
    AND             reduce using rule 55 (primaryexp -> unaryexp .)
    OR              reduce using rule 55 (primaryexp -> unaryexp .)
    PLUS            reduce using rule 55 (primaryexp -> unaryexp .)
    MINUS           reduce using rule 55 (primaryexp -> unaryexp .)
    TIMES           reduce using rule 55 (primaryexp -> unaryexp .)
    DIVIDE          reduce using rule 55 (primaryexp -> unaryexp .)
    MOD             reduce using rule 55 (primaryexp -> unaryexp .)
    POW             reduce using rule 55 (primaryexp -> unaryexp .)


state 9

    (11) controlstructure -> ifstatement .

    SEMI_COLON      reduce using rule 11 (controlstructure -> ifstatement .)
    COMMA           reduce using rule 11 (controlstructure -> ifstatement .)
    $end            reduce using rule 11 (controlstructure -> ifstatement .)
    RBRACE          reduce using rule 11 (controlstructure -> ifstatement .)


state 10

    (12) controlstructure -> whileloop .

    SEMI_COLON      reduce using rule 12 (controlstructure -> whileloop .)
    COMMA           reduce using rule 12 (controlstructure -> whileloop .)
    $end            reduce using rule 12 (controlstructure -> whileloop .)
    RBRACE          reduce using rule 12 (controlstructure -> whileloop .)


state 11

    (13) controlstructure -> forloop .

    SEMI_COLON      reduce using rule 13 (controlstructure -> forloop .)
    COMMA           reduce using rule 13 (controlstructure -> forloop .)
    $end            reduce using rule 13 (controlstructure -> forloop .)
    RBRACE          reduce using rule 13 (controlstructure -> forloop .)


state 12

    (14) controlstructure -> withstatement .

    SEMI_COLON      reduce using rule 14 (controlstructure -> withstatement .)
    COMMA           reduce using rule 14 (controlstructure -> withstatement .)
    $end            reduce using rule 14 (controlstructure -> withstatement .)
    RBRACE          reduce using rule 14 (controlstructure -> withstatement .)


state 13

    (37) assignment -> assignment_code . code RBRACE
    (1) code -> . empty
    (2) code -> . statement
    (3) code -> . statement terminator code
    (103) empty -> .
    (4) statement -> . controlstructure
    (5) statement -> . assignment
    (6) statement -> . binaryexp
    (7) statement -> . nularexp
    (8) statement -> . unaryexp
    (11) controlstructure -> . ifstatement
    (12) controlstructure -> . whileloop
    (13) controlstructure -> . forloop
    (14) controlstructure -> . withstatement
    (37) assignment -> . assignment_code code RBRACE
    (38) assignment -> . definition EQUAL primaryexp
    (39) assignment -> . variable EQUAL primaryexp
    (49) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (50) binaryexp -> . primaryexp comparisonoperator primaryexp
    (51) binaryexp -> . primaryexp mathoperator primaryexp
    (72) nularexp -> . NULAR_FNC
    (73) nularexp -> . identifier
    (74) unaryexp -> . UNARY_FNC primaryexp
    (75) unaryexp -> . PLUS primaryexp
    (76) unaryexp -> . MINUS primaryexp
    (77) unaryexp -> . NOT primaryexp
    (78) unaryexp -> . vardefinition
    (20) ifstatement -> . iftype THEN bracedexp
    (21) ifstatement -> . iftype EXITWITH bracedexp
    (22) ifstatement -> . iftype THEN bracedexp ELSE bracedexp
    (27) whileloop -> . whiletype DO bracedexp
    (31) forloop -> . fortype DO bracedexp_noscope
    (25) withstatement -> . withstatementinit bracedexp
    (40) assignment_code -> . definition EQUAL LBRACE
    (41) assignment_code -> . variable EQUAL LBRACE
    (43) definition -> . PRIVATE PRIVATE_ID
    (44) definition -> . PRIVATE string
    (47) variable -> . PRIVATE_ID
    (48) variable -> . GLOBAL_ID
    (52) primaryexp -> . number
    (53) primaryexp -> . identifier
    (54) primaryexp -> . helpertype
    (55) primaryexp -> . unaryexp
    (56) primaryexp -> . nularexp
    (57) primaryexp -> . string
    (58) primaryexp -> . binaryexp
    (59) primaryexp -> . bracedexp
    (60) primaryexp -> . LPAREN binaryexp RPAREN
    (61) primaryexp -> . array
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID
    (35) vardefinition -> . definition
    (36) vardefinition -> . arraydefinition
    (19) iftype -> . IF forloop_condition
    (26) whiletype -> . WHILE forloop_condition
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (24) withstatementinit -> . withtype DO
    (98) number -> . NUMBER_REAL
    (99) number -> . NUMBER_EXP
    (100) number -> . NUMBER_HEX
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE
    (62) bracedexp -> . LBRACE new_scope code RBRACE
    (64) array -> . LSPAREN RSPAREN
    (65) array -> . LSPAREN arrayelement RSPAREN
    (42) arraydefinition -> . PRIVATE stringarray
    (23) withtype -> . WITH NAMESPACE

    RBRACE          reduce using rule 103 (empty -> .)
    NULAR_FNC       shift and go to state 17
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    PRIVATE         shift and go to state 30
    PRIVATE_ID      shift and go to state 31
    GLOBAL_ID       shift and go to state 33
    LPAREN          shift and go to state 36
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    NUMBER_REAL     shift and go to state 44
    NUMBER_EXP      shift and go to state 45
    NUMBER_HEX      shift and go to state 46
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 42
    WITH            shift and go to state 49

    assignment_code                shift and go to state 13
    code                           shift and go to state 53
    empty                          shift and go to state 2
    statement                      shift and go to state 3
    controlstructure               shift and go to state 4
    assignment                     shift and go to state 5
    binaryexp                      shift and go to state 6
    nularexp                       shift and go to state 7
    unaryexp                       shift and go to state 8
    ifstatement                    shift and go to state 9
    whileloop                      shift and go to state 10
    forloop                        shift and go to state 11
    withstatement                  shift and go to state 12
    definition                     shift and go to state 14
    primaryexp                     shift and go to state 15
    variable                       shift and go to state 16
    identifier                     shift and go to state 18
    vardefinition                  shift and go to state 23
    iftype                         shift and go to state 24
    bracedexp                      shift and go to state 25
    whiletype                      shift and go to state 26
    fortype                        shift and go to state 27
    withstatementinit              shift and go to state 28
    string                         shift and go to state 32
    number                         shift and go to state 34
    helpertype                     shift and go to state 35
    array                          shift and go to state 37
    arraydefinition                shift and go to state 38
    withtype                       shift and go to state 43

state 14

    (38) assignment -> definition . EQUAL primaryexp
    (40) assignment_code -> definition . EQUAL LBRACE
    (35) vardefinition -> definition .

    EQUAL           shift and go to state 54
    SEMI_COLON      reduce using rule 35 (vardefinition -> definition .)
    COMMA           reduce using rule 35 (vardefinition -> definition .)
    $end            reduce using rule 35 (vardefinition -> definition .)
    BINARY_FNC      reduce using rule 35 (vardefinition -> definition .)
    LT              reduce using rule 35 (vardefinition -> definition .)
    GT              reduce using rule 35 (vardefinition -> definition .)
    LTE             reduce using rule 35 (vardefinition -> definition .)
    GTE             reduce using rule 35 (vardefinition -> definition .)
    EQUALITY        reduce using rule 35 (vardefinition -> definition .)
    INEQUALITY      reduce using rule 35 (vardefinition -> definition .)
    AND             reduce using rule 35 (vardefinition -> definition .)
    OR              reduce using rule 35 (vardefinition -> definition .)
    PLUS            reduce using rule 35 (vardefinition -> definition .)
    MINUS           reduce using rule 35 (vardefinition -> definition .)
    TIMES           reduce using rule 35 (vardefinition -> definition .)
    DIVIDE          reduce using rule 35 (vardefinition -> definition .)
    MOD             reduce using rule 35 (vardefinition -> definition .)
    POW             reduce using rule 35 (vardefinition -> definition .)
    RBRACE          reduce using rule 35 (vardefinition -> definition .)


state 15

    (49) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (50) binaryexp -> primaryexp . comparisonoperator primaryexp
    (51) binaryexp -> primaryexp . mathoperator primaryexp
    (79) comparisonoperator -> . LT
    (80) comparisonoperator -> . GT
    (81) comparisonoperator -> . LTE
    (82) comparisonoperator -> . GTE
    (83) comparisonoperator -> . EQUALITY
    (84) comparisonoperator -> . INEQUALITY
    (85) comparisonoperator -> . AND
    (86) comparisonoperator -> . OR
    (87) mathoperator -> . PLUS
    (88) mathoperator -> . MINUS
    (89) mathoperator -> . TIMES
    (90) mathoperator -> . DIVIDE
    (91) mathoperator -> . MOD
    (92) mathoperator -> . POW

    BINARY_FNC      shift and go to state 55
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61
    EQUALITY        shift and go to state 62
    INEQUALITY      shift and go to state 63
    AND             shift and go to state 64
    OR              shift and go to state 65
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POW             shift and go to state 71

    comparisonoperator             shift and go to state 56
    mathoperator                   shift and go to state 57

state 16

    (39) assignment -> variable . EQUAL primaryexp
    (41) assignment_code -> variable . EQUAL LBRACE

    EQUAL           shift and go to state 72


state 17

    (72) nularexp -> NULAR_FNC .

    SEMI_COLON      reduce using rule 72 (nularexp -> NULAR_FNC .)
    COMMA           reduce using rule 72 (nularexp -> NULAR_FNC .)
    $end            reduce using rule 72 (nularexp -> NULAR_FNC .)
    BINARY_FNC      reduce using rule 72 (nularexp -> NULAR_FNC .)
    LT              reduce using rule 72 (nularexp -> NULAR_FNC .)
    GT              reduce using rule 72 (nularexp -> NULAR_FNC .)
    LTE             reduce using rule 72 (nularexp -> NULAR_FNC .)
    GTE             reduce using rule 72 (nularexp -> NULAR_FNC .)
    EQUALITY        reduce using rule 72 (nularexp -> NULAR_FNC .)
    INEQUALITY      reduce using rule 72 (nularexp -> NULAR_FNC .)
    AND             reduce using rule 72 (nularexp -> NULAR_FNC .)
    OR              reduce using rule 72 (nularexp -> NULAR_FNC .)
    PLUS            reduce using rule 72 (nularexp -> NULAR_FNC .)
    MINUS           reduce using rule 72 (nularexp -> NULAR_FNC .)
    TIMES           reduce using rule 72 (nularexp -> NULAR_FNC .)
    DIVIDE          reduce using rule 72 (nularexp -> NULAR_FNC .)
    MOD             reduce using rule 72 (nularexp -> NULAR_FNC .)
    POW             reduce using rule 72 (nularexp -> NULAR_FNC .)
    RBRACE          reduce using rule 72 (nularexp -> NULAR_FNC .)
    RPAREN          reduce using rule 72 (nularexp -> NULAR_FNC .)
    RSPAREN         reduce using rule 72 (nularexp -> NULAR_FNC .)
    TO              reduce using rule 72 (nularexp -> NULAR_FNC .)
    STEP            reduce using rule 72 (nularexp -> NULAR_FNC .)
    DO              reduce using rule 72 (nularexp -> NULAR_FNC .)


state 18

    (73) nularexp -> identifier .
    (53) primaryexp -> identifier .

  ! reduce/reduce conflict for BINARY_FNC resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for LT resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for GT resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for LTE resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for GTE resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for EQUALITY resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for INEQUALITY resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for AND resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for OR resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for PLUS resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for MINUS resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for TIMES resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for MOD resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for POW resolved using rule 53 (primaryexp -> identifier .)
    SEMI_COLON      reduce using rule 73 (nularexp -> identifier .)
    COMMA           reduce using rule 73 (nularexp -> identifier .)
    $end            reduce using rule 73 (nularexp -> identifier .)
    RBRACE          reduce using rule 73 (nularexp -> identifier .)
    BINARY_FNC      reduce using rule 53 (primaryexp -> identifier .)
    LT              reduce using rule 53 (primaryexp -> identifier .)
    GT              reduce using rule 53 (primaryexp -> identifier .)
    LTE             reduce using rule 53 (primaryexp -> identifier .)
    GTE             reduce using rule 53 (primaryexp -> identifier .)
    EQUALITY        reduce using rule 53 (primaryexp -> identifier .)
    INEQUALITY      reduce using rule 53 (primaryexp -> identifier .)
    AND             reduce using rule 53 (primaryexp -> identifier .)
    OR              reduce using rule 53 (primaryexp -> identifier .)
    PLUS            reduce using rule 53 (primaryexp -> identifier .)
    MINUS           reduce using rule 53 (primaryexp -> identifier .)
    TIMES           reduce using rule 53 (primaryexp -> identifier .)
    DIVIDE          reduce using rule 53 (primaryexp -> identifier .)
    MOD             reduce using rule 53 (primaryexp -> identifier .)
    POW             reduce using rule 53 (primaryexp -> identifier .)

  ! BINARY_FNC      [ reduce using rule 73 (nularexp -> identifier .) ]
  ! LT              [ reduce using rule 73 (nularexp -> identifier .) ]
  ! GT              [ reduce using rule 73 (nularexp -> identifier .) ]
  ! LTE             [ reduce using rule 73 (nularexp -> identifier .) ]
  ! GTE             [ reduce using rule 73 (nularexp -> identifier .) ]
  ! EQUALITY        [ reduce using rule 73 (nularexp -> identifier .) ]
  ! INEQUALITY      [ reduce using rule 73 (nularexp -> identifier .) ]
  ! AND             [ reduce using rule 73 (nularexp -> identifier .) ]
  ! OR              [ reduce using rule 73 (nularexp -> identifier .) ]
  ! PLUS            [ reduce using rule 73 (nularexp -> identifier .) ]
  ! MINUS           [ reduce using rule 73 (nularexp -> identifier .) ]
  ! TIMES           [ reduce using rule 73 (nularexp -> identifier .) ]
  ! DIVIDE          [ reduce using rule 73 (nularexp -> identifier .) ]
  ! MOD             [ reduce using rule 73 (nularexp -> identifier .) ]
  ! POW             [ reduce using rule 73 (nularexp -> identifier .) ]


state 19

    (74) unaryexp -> UNARY_FNC . primaryexp
    (52) primaryexp -> . number
    (53) primaryexp -> . identifier
    (54) primaryexp -> . helpertype
    (55) primaryexp -> . unaryexp
    (56) primaryexp -> . nularexp
    (57) primaryexp -> . string
    (58) primaryexp -> . binaryexp
    (59) primaryexp -> . bracedexp
    (60) primaryexp -> . LPAREN binaryexp RPAREN
    (61) primaryexp -> . array
    (98) number -> . NUMBER_REAL
    (99) number -> . NUMBER_EXP
    (100) number -> . NUMBER_HEX
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (74) unaryexp -> . UNARY_FNC primaryexp
    (75) unaryexp -> . PLUS primaryexp
    (76) unaryexp -> . MINUS primaryexp
    (77) unaryexp -> . NOT primaryexp
    (78) unaryexp -> . vardefinition
    (72) nularexp -> . NULAR_FNC
    (73) nularexp -> . identifier
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE
    (49) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (50) binaryexp -> . primaryexp comparisonoperator primaryexp
    (51) binaryexp -> . primaryexp mathoperator primaryexp
    (62) bracedexp -> . LBRACE new_scope code RBRACE
    (64) array -> . LSPAREN RSPAREN
    (65) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF forloop_condition
    (26) whiletype -> . WHILE forloop_condition
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (35) vardefinition -> . definition
    (36) vardefinition -> . arraydefinition
    (43) definition -> . PRIVATE PRIVATE_ID
    (44) definition -> . PRIVATE string
    (42) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 44
    NUMBER_EXP      shift and go to state 45
    NUMBER_HEX      shift and go to state 46
    PRIVATE_ID      shift and go to state 78
    GLOBAL_ID       shift and go to state 79
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 42
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    WITH            shift and go to state 49
    PRIVATE         shift and go to state 30

    primaryexp                     shift and go to state 73
    number                         shift and go to state 34
    identifier                     shift and go to state 74
    helpertype                     shift and go to state 35
    unaryexp                       shift and go to state 75
    nularexp                       shift and go to state 76
    string                         shift and go to state 32
    binaryexp                      shift and go to state 77
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 80
    whiletype                      shift and go to state 81
    fortype                        shift and go to state 82
    withtype                       shift and go to state 83
    vardefinition                  shift and go to state 23
    definition                     shift and go to state 84
    arraydefinition                shift and go to state 38

state 20

    (75) unaryexp -> PLUS . primaryexp
    (52) primaryexp -> . number
    (53) primaryexp -> . identifier
    (54) primaryexp -> . helpertype
    (55) primaryexp -> . unaryexp
    (56) primaryexp -> . nularexp
    (57) primaryexp -> . string
    (58) primaryexp -> . binaryexp
    (59) primaryexp -> . bracedexp
    (60) primaryexp -> . LPAREN binaryexp RPAREN
    (61) primaryexp -> . array
    (98) number -> . NUMBER_REAL
    (99) number -> . NUMBER_EXP
    (100) number -> . NUMBER_HEX
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (74) unaryexp -> . UNARY_FNC primaryexp
    (75) unaryexp -> . PLUS primaryexp
    (76) unaryexp -> . MINUS primaryexp
    (77) unaryexp -> . NOT primaryexp
    (78) unaryexp -> . vardefinition
    (72) nularexp -> . NULAR_FNC
    (73) nularexp -> . identifier
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE
    (49) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (50) binaryexp -> . primaryexp comparisonoperator primaryexp
    (51) binaryexp -> . primaryexp mathoperator primaryexp
    (62) bracedexp -> . LBRACE new_scope code RBRACE
    (64) array -> . LSPAREN RSPAREN
    (65) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF forloop_condition
    (26) whiletype -> . WHILE forloop_condition
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (35) vardefinition -> . definition
    (36) vardefinition -> . arraydefinition
    (43) definition -> . PRIVATE PRIVATE_ID
    (44) definition -> . PRIVATE string
    (42) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 44
    NUMBER_EXP      shift and go to state 45
    NUMBER_HEX      shift and go to state 46
    PRIVATE_ID      shift and go to state 78
    GLOBAL_ID       shift and go to state 79
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 42
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    WITH            shift and go to state 49
    PRIVATE         shift and go to state 30

    primaryexp                     shift and go to state 85
    number                         shift and go to state 34
    identifier                     shift and go to state 74
    helpertype                     shift and go to state 35
    unaryexp                       shift and go to state 75
    nularexp                       shift and go to state 76
    string                         shift and go to state 32
    binaryexp                      shift and go to state 77
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 80
    whiletype                      shift and go to state 81
    fortype                        shift and go to state 82
    withtype                       shift and go to state 83
    vardefinition                  shift and go to state 23
    definition                     shift and go to state 84
    arraydefinition                shift and go to state 38

state 21

    (76) unaryexp -> MINUS . primaryexp
    (52) primaryexp -> . number
    (53) primaryexp -> . identifier
    (54) primaryexp -> . helpertype
    (55) primaryexp -> . unaryexp
    (56) primaryexp -> . nularexp
    (57) primaryexp -> . string
    (58) primaryexp -> . binaryexp
    (59) primaryexp -> . bracedexp
    (60) primaryexp -> . LPAREN binaryexp RPAREN
    (61) primaryexp -> . array
    (98) number -> . NUMBER_REAL
    (99) number -> . NUMBER_EXP
    (100) number -> . NUMBER_HEX
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (74) unaryexp -> . UNARY_FNC primaryexp
    (75) unaryexp -> . PLUS primaryexp
    (76) unaryexp -> . MINUS primaryexp
    (77) unaryexp -> . NOT primaryexp
    (78) unaryexp -> . vardefinition
    (72) nularexp -> . NULAR_FNC
    (73) nularexp -> . identifier
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE
    (49) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (50) binaryexp -> . primaryexp comparisonoperator primaryexp
    (51) binaryexp -> . primaryexp mathoperator primaryexp
    (62) bracedexp -> . LBRACE new_scope code RBRACE
    (64) array -> . LSPAREN RSPAREN
    (65) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF forloop_condition
    (26) whiletype -> . WHILE forloop_condition
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (35) vardefinition -> . definition
    (36) vardefinition -> . arraydefinition
    (43) definition -> . PRIVATE PRIVATE_ID
    (44) definition -> . PRIVATE string
    (42) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 44
    NUMBER_EXP      shift and go to state 45
    NUMBER_HEX      shift and go to state 46
    PRIVATE_ID      shift and go to state 78
    GLOBAL_ID       shift and go to state 79
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 42
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    WITH            shift and go to state 49
    PRIVATE         shift and go to state 30

    primaryexp                     shift and go to state 86
    number                         shift and go to state 34
    identifier                     shift and go to state 74
    helpertype                     shift and go to state 35
    unaryexp                       shift and go to state 75
    nularexp                       shift and go to state 76
    string                         shift and go to state 32
    binaryexp                      shift and go to state 77
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 80
    whiletype                      shift and go to state 81
    fortype                        shift and go to state 82
    withtype                       shift and go to state 83
    vardefinition                  shift and go to state 23
    definition                     shift and go to state 84
    arraydefinition                shift and go to state 38

state 22

    (77) unaryexp -> NOT . primaryexp
    (52) primaryexp -> . number
    (53) primaryexp -> . identifier
    (54) primaryexp -> . helpertype
    (55) primaryexp -> . unaryexp
    (56) primaryexp -> . nularexp
    (57) primaryexp -> . string
    (58) primaryexp -> . binaryexp
    (59) primaryexp -> . bracedexp
    (60) primaryexp -> . LPAREN binaryexp RPAREN
    (61) primaryexp -> . array
    (98) number -> . NUMBER_REAL
    (99) number -> . NUMBER_EXP
    (100) number -> . NUMBER_HEX
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (74) unaryexp -> . UNARY_FNC primaryexp
    (75) unaryexp -> . PLUS primaryexp
    (76) unaryexp -> . MINUS primaryexp
    (77) unaryexp -> . NOT primaryexp
    (78) unaryexp -> . vardefinition
    (72) nularexp -> . NULAR_FNC
    (73) nularexp -> . identifier
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE
    (49) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (50) binaryexp -> . primaryexp comparisonoperator primaryexp
    (51) binaryexp -> . primaryexp mathoperator primaryexp
    (62) bracedexp -> . LBRACE new_scope code RBRACE
    (64) array -> . LSPAREN RSPAREN
    (65) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF forloop_condition
    (26) whiletype -> . WHILE forloop_condition
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (35) vardefinition -> . definition
    (36) vardefinition -> . arraydefinition
    (43) definition -> . PRIVATE PRIVATE_ID
    (44) definition -> . PRIVATE string
    (42) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 44
    NUMBER_EXP      shift and go to state 45
    NUMBER_HEX      shift and go to state 46
    PRIVATE_ID      shift and go to state 78
    GLOBAL_ID       shift and go to state 79
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 42
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    WITH            shift and go to state 49
    PRIVATE         shift and go to state 30

    primaryexp                     shift and go to state 87
    number                         shift and go to state 34
    identifier                     shift and go to state 74
    helpertype                     shift and go to state 35
    unaryexp                       shift and go to state 75
    nularexp                       shift and go to state 76
    string                         shift and go to state 32
    binaryexp                      shift and go to state 77
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 80
    whiletype                      shift and go to state 81
    fortype                        shift and go to state 82
    withtype                       shift and go to state 83
    vardefinition                  shift and go to state 23
    definition                     shift and go to state 84
    arraydefinition                shift and go to state 38

state 23

    (78) unaryexp -> vardefinition .

    SEMI_COLON      reduce using rule 78 (unaryexp -> vardefinition .)
    COMMA           reduce using rule 78 (unaryexp -> vardefinition .)
    $end            reduce using rule 78 (unaryexp -> vardefinition .)
    BINARY_FNC      reduce using rule 78 (unaryexp -> vardefinition .)
    LT              reduce using rule 78 (unaryexp -> vardefinition .)
    GT              reduce using rule 78 (unaryexp -> vardefinition .)
    LTE             reduce using rule 78 (unaryexp -> vardefinition .)
    GTE             reduce using rule 78 (unaryexp -> vardefinition .)
    EQUALITY        reduce using rule 78 (unaryexp -> vardefinition .)
    INEQUALITY      reduce using rule 78 (unaryexp -> vardefinition .)
    AND             reduce using rule 78 (unaryexp -> vardefinition .)
    OR              reduce using rule 78 (unaryexp -> vardefinition .)
    PLUS            reduce using rule 78 (unaryexp -> vardefinition .)
    MINUS           reduce using rule 78 (unaryexp -> vardefinition .)
    TIMES           reduce using rule 78 (unaryexp -> vardefinition .)
    DIVIDE          reduce using rule 78 (unaryexp -> vardefinition .)
    MOD             reduce using rule 78 (unaryexp -> vardefinition .)
    POW             reduce using rule 78 (unaryexp -> vardefinition .)
    RBRACE          reduce using rule 78 (unaryexp -> vardefinition .)
    RPAREN          reduce using rule 78 (unaryexp -> vardefinition .)
    RSPAREN         reduce using rule 78 (unaryexp -> vardefinition .)
    TO              reduce using rule 78 (unaryexp -> vardefinition .)
    STEP            reduce using rule 78 (unaryexp -> vardefinition .)
    DO              reduce using rule 78 (unaryexp -> vardefinition .)


state 24

    (20) ifstatement -> iftype . THEN bracedexp
    (21) ifstatement -> iftype . EXITWITH bracedexp
    (22) ifstatement -> iftype . THEN bracedexp ELSE bracedexp
    (15) helpertype -> iftype .

    THEN            shift and go to state 88
    EXITWITH        shift and go to state 89
    BINARY_FNC      reduce using rule 15 (helpertype -> iftype .)
    LT              reduce using rule 15 (helpertype -> iftype .)
    GT              reduce using rule 15 (helpertype -> iftype .)
    LTE             reduce using rule 15 (helpertype -> iftype .)
    GTE             reduce using rule 15 (helpertype -> iftype .)
    EQUALITY        reduce using rule 15 (helpertype -> iftype .)
    INEQUALITY      reduce using rule 15 (helpertype -> iftype .)
    AND             reduce using rule 15 (helpertype -> iftype .)
    OR              reduce using rule 15 (helpertype -> iftype .)
    PLUS            reduce using rule 15 (helpertype -> iftype .)
    MINUS           reduce using rule 15 (helpertype -> iftype .)
    TIMES           reduce using rule 15 (helpertype -> iftype .)
    DIVIDE          reduce using rule 15 (helpertype -> iftype .)
    MOD             reduce using rule 15 (helpertype -> iftype .)
    POW             reduce using rule 15 (helpertype -> iftype .)


state 25

    (59) primaryexp -> bracedexp .

    BINARY_FNC      reduce using rule 59 (primaryexp -> bracedexp .)
    LT              reduce using rule 59 (primaryexp -> bracedexp .)
    GT              reduce using rule 59 (primaryexp -> bracedexp .)
    LTE             reduce using rule 59 (primaryexp -> bracedexp .)
    GTE             reduce using rule 59 (primaryexp -> bracedexp .)
    EQUALITY        reduce using rule 59 (primaryexp -> bracedexp .)
    INEQUALITY      reduce using rule 59 (primaryexp -> bracedexp .)
    AND             reduce using rule 59 (primaryexp -> bracedexp .)
    OR              reduce using rule 59 (primaryexp -> bracedexp .)
    PLUS            reduce using rule 59 (primaryexp -> bracedexp .)
    MINUS           reduce using rule 59 (primaryexp -> bracedexp .)
    TIMES           reduce using rule 59 (primaryexp -> bracedexp .)
    DIVIDE          reduce using rule 59 (primaryexp -> bracedexp .)
    MOD             reduce using rule 59 (primaryexp -> bracedexp .)
    POW             reduce using rule 59 (primaryexp -> bracedexp .)
    SEMI_COLON      reduce using rule 59 (primaryexp -> bracedexp .)
    COMMA           reduce using rule 59 (primaryexp -> bracedexp .)
    $end            reduce using rule 59 (primaryexp -> bracedexp .)
    RBRACE          reduce using rule 59 (primaryexp -> bracedexp .)
    RPAREN          reduce using rule 59 (primaryexp -> bracedexp .)
    RSPAREN         reduce using rule 59 (primaryexp -> bracedexp .)
    TO              reduce using rule 59 (primaryexp -> bracedexp .)
    STEP            reduce using rule 59 (primaryexp -> bracedexp .)
    DO              reduce using rule 59 (primaryexp -> bracedexp .)


state 26

    (27) whileloop -> whiletype . DO bracedexp
    (16) helpertype -> whiletype .

    DO              shift and go to state 90
    BINARY_FNC      reduce using rule 16 (helpertype -> whiletype .)
    LT              reduce using rule 16 (helpertype -> whiletype .)
    GT              reduce using rule 16 (helpertype -> whiletype .)
    LTE             reduce using rule 16 (helpertype -> whiletype .)
    GTE             reduce using rule 16 (helpertype -> whiletype .)
    EQUALITY        reduce using rule 16 (helpertype -> whiletype .)
    INEQUALITY      reduce using rule 16 (helpertype -> whiletype .)
    AND             reduce using rule 16 (helpertype -> whiletype .)
    OR              reduce using rule 16 (helpertype -> whiletype .)
    PLUS            reduce using rule 16 (helpertype -> whiletype .)
    MINUS           reduce using rule 16 (helpertype -> whiletype .)
    TIMES           reduce using rule 16 (helpertype -> whiletype .)
    DIVIDE          reduce using rule 16 (helpertype -> whiletype .)
    MOD             reduce using rule 16 (helpertype -> whiletype .)
    POW             reduce using rule 16 (helpertype -> whiletype .)


state 27

    (31) forloop -> fortype . DO bracedexp_noscope
    (17) helpertype -> fortype .

    DO              shift and go to state 91
    BINARY_FNC      reduce using rule 17 (helpertype -> fortype .)
    LT              reduce using rule 17 (helpertype -> fortype .)
    GT              reduce using rule 17 (helpertype -> fortype .)
    LTE             reduce using rule 17 (helpertype -> fortype .)
    GTE             reduce using rule 17 (helpertype -> fortype .)
    EQUALITY        reduce using rule 17 (helpertype -> fortype .)
    INEQUALITY      reduce using rule 17 (helpertype -> fortype .)
    AND             reduce using rule 17 (helpertype -> fortype .)
    OR              reduce using rule 17 (helpertype -> fortype .)
    PLUS            reduce using rule 17 (helpertype -> fortype .)
    MINUS           reduce using rule 17 (helpertype -> fortype .)
    TIMES           reduce using rule 17 (helpertype -> fortype .)
    DIVIDE          reduce using rule 17 (helpertype -> fortype .)
    MOD             reduce using rule 17 (helpertype -> fortype .)
    POW             reduce using rule 17 (helpertype -> fortype .)


state 28

    (25) withstatement -> withstatementinit . bracedexp
    (62) bracedexp -> . LBRACE new_scope code RBRACE

    LBRACE          shift and go to state 29

    bracedexp                      shift and go to state 92

state 29

    (62) bracedexp -> LBRACE . new_scope code RBRACE
    (63) new_scope -> .

    NULAR_FNC       reduce using rule 63 (new_scope -> .)
    UNARY_FNC       reduce using rule 63 (new_scope -> .)
    PLUS            reduce using rule 63 (new_scope -> .)
    MINUS           reduce using rule 63 (new_scope -> .)
    NOT             reduce using rule 63 (new_scope -> .)
    PRIVATE         reduce using rule 63 (new_scope -> .)
    PRIVATE_ID      reduce using rule 63 (new_scope -> .)
    GLOBAL_ID       reduce using rule 63 (new_scope -> .)
    LPAREN          reduce using rule 63 (new_scope -> .)
    IF              reduce using rule 63 (new_scope -> .)
    WHILE           reduce using rule 63 (new_scope -> .)
    FOR             reduce using rule 63 (new_scope -> .)
    NUMBER_REAL     reduce using rule 63 (new_scope -> .)
    NUMBER_EXP      reduce using rule 63 (new_scope -> .)
    NUMBER_HEX      reduce using rule 63 (new_scope -> .)
    STRING_SINGLE   reduce using rule 63 (new_scope -> .)
    STRING_DOUBLE   reduce using rule 63 (new_scope -> .)
    LBRACE          reduce using rule 63 (new_scope -> .)
    LSPAREN         reduce using rule 63 (new_scope -> .)
    WITH            reduce using rule 63 (new_scope -> .)
    RBRACE          reduce using rule 63 (new_scope -> .)

    new_scope                      shift and go to state 93

state 30

    (43) definition -> PRIVATE . PRIVATE_ID
    (44) definition -> PRIVATE . string
    (42) arraydefinition -> PRIVATE . stringarray
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE
    (68) stringarray -> . LSPAREN RSPAREN
    (69) stringarray -> . LSPAREN stringarrayelement RSPAREN

    PRIVATE_ID      shift and go to state 94
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48
    LSPAREN         shift and go to state 97

    string                         shift and go to state 95
    stringarray                    shift and go to state 96

state 31

    (47) variable -> PRIVATE_ID .
    (45) identifier -> PRIVATE_ID .

    EQUAL           reduce using rule 47 (variable -> PRIVATE_ID .)
    SEMI_COLON      reduce using rule 45 (identifier -> PRIVATE_ID .)
    COMMA           reduce using rule 45 (identifier -> PRIVATE_ID .)
    $end            reduce using rule 45 (identifier -> PRIVATE_ID .)
    BINARY_FNC      reduce using rule 45 (identifier -> PRIVATE_ID .)
    LT              reduce using rule 45 (identifier -> PRIVATE_ID .)
    GT              reduce using rule 45 (identifier -> PRIVATE_ID .)
    LTE             reduce using rule 45 (identifier -> PRIVATE_ID .)
    GTE             reduce using rule 45 (identifier -> PRIVATE_ID .)
    EQUALITY        reduce using rule 45 (identifier -> PRIVATE_ID .)
    INEQUALITY      reduce using rule 45 (identifier -> PRIVATE_ID .)
    AND             reduce using rule 45 (identifier -> PRIVATE_ID .)
    OR              reduce using rule 45 (identifier -> PRIVATE_ID .)
    PLUS            reduce using rule 45 (identifier -> PRIVATE_ID .)
    MINUS           reduce using rule 45 (identifier -> PRIVATE_ID .)
    TIMES           reduce using rule 45 (identifier -> PRIVATE_ID .)
    DIVIDE          reduce using rule 45 (identifier -> PRIVATE_ID .)
    MOD             reduce using rule 45 (identifier -> PRIVATE_ID .)
    POW             reduce using rule 45 (identifier -> PRIVATE_ID .)
    RBRACE          reduce using rule 45 (identifier -> PRIVATE_ID .)


state 32

    (57) primaryexp -> string .

    BINARY_FNC      reduce using rule 57 (primaryexp -> string .)
    LT              reduce using rule 57 (primaryexp -> string .)
    GT              reduce using rule 57 (primaryexp -> string .)
    LTE             reduce using rule 57 (primaryexp -> string .)
    GTE             reduce using rule 57 (primaryexp -> string .)
    EQUALITY        reduce using rule 57 (primaryexp -> string .)
    INEQUALITY      reduce using rule 57 (primaryexp -> string .)
    AND             reduce using rule 57 (primaryexp -> string .)
    OR              reduce using rule 57 (primaryexp -> string .)
    PLUS            reduce using rule 57 (primaryexp -> string .)
    MINUS           reduce using rule 57 (primaryexp -> string .)
    TIMES           reduce using rule 57 (primaryexp -> string .)
    DIVIDE          reduce using rule 57 (primaryexp -> string .)
    MOD             reduce using rule 57 (primaryexp -> string .)
    POW             reduce using rule 57 (primaryexp -> string .)
    SEMI_COLON      reduce using rule 57 (primaryexp -> string .)
    COMMA           reduce using rule 57 (primaryexp -> string .)
    $end            reduce using rule 57 (primaryexp -> string .)
    RBRACE          reduce using rule 57 (primaryexp -> string .)
    RPAREN          reduce using rule 57 (primaryexp -> string .)
    RSPAREN         reduce using rule 57 (primaryexp -> string .)
    TO              reduce using rule 57 (primaryexp -> string .)
    STEP            reduce using rule 57 (primaryexp -> string .)
    DO              reduce using rule 57 (primaryexp -> string .)


state 33

    (48) variable -> GLOBAL_ID .
    (46) identifier -> GLOBAL_ID .

    EQUAL           reduce using rule 48 (variable -> GLOBAL_ID .)
    SEMI_COLON      reduce using rule 46 (identifier -> GLOBAL_ID .)
    COMMA           reduce using rule 46 (identifier -> GLOBAL_ID .)
    $end            reduce using rule 46 (identifier -> GLOBAL_ID .)
    BINARY_FNC      reduce using rule 46 (identifier -> GLOBAL_ID .)
    LT              reduce using rule 46 (identifier -> GLOBAL_ID .)
    GT              reduce using rule 46 (identifier -> GLOBAL_ID .)
    LTE             reduce using rule 46 (identifier -> GLOBAL_ID .)
    GTE             reduce using rule 46 (identifier -> GLOBAL_ID .)
    EQUALITY        reduce using rule 46 (identifier -> GLOBAL_ID .)
    INEQUALITY      reduce using rule 46 (identifier -> GLOBAL_ID .)
    AND             reduce using rule 46 (identifier -> GLOBAL_ID .)
    OR              reduce using rule 46 (identifier -> GLOBAL_ID .)
    PLUS            reduce using rule 46 (identifier -> GLOBAL_ID .)
    MINUS           reduce using rule 46 (identifier -> GLOBAL_ID .)
    TIMES           reduce using rule 46 (identifier -> GLOBAL_ID .)
    DIVIDE          reduce using rule 46 (identifier -> GLOBAL_ID .)
    MOD             reduce using rule 46 (identifier -> GLOBAL_ID .)
    POW             reduce using rule 46 (identifier -> GLOBAL_ID .)
    RBRACE          reduce using rule 46 (identifier -> GLOBAL_ID .)


state 34

    (52) primaryexp -> number .

    BINARY_FNC      reduce using rule 52 (primaryexp -> number .)
    LT              reduce using rule 52 (primaryexp -> number .)
    GT              reduce using rule 52 (primaryexp -> number .)
    LTE             reduce using rule 52 (primaryexp -> number .)
    GTE             reduce using rule 52 (primaryexp -> number .)
    EQUALITY        reduce using rule 52 (primaryexp -> number .)
    INEQUALITY      reduce using rule 52 (primaryexp -> number .)
    AND             reduce using rule 52 (primaryexp -> number .)
    OR              reduce using rule 52 (primaryexp -> number .)
    PLUS            reduce using rule 52 (primaryexp -> number .)
    MINUS           reduce using rule 52 (primaryexp -> number .)
    TIMES           reduce using rule 52 (primaryexp -> number .)
    DIVIDE          reduce using rule 52 (primaryexp -> number .)
    MOD             reduce using rule 52 (primaryexp -> number .)
    POW             reduce using rule 52 (primaryexp -> number .)
    SEMI_COLON      reduce using rule 52 (primaryexp -> number .)
    COMMA           reduce using rule 52 (primaryexp -> number .)
    $end            reduce using rule 52 (primaryexp -> number .)
    RBRACE          reduce using rule 52 (primaryexp -> number .)
    RPAREN          reduce using rule 52 (primaryexp -> number .)
    RSPAREN         reduce using rule 52 (primaryexp -> number .)
    TO              reduce using rule 52 (primaryexp -> number .)
    STEP            reduce using rule 52 (primaryexp -> number .)
    DO              reduce using rule 52 (primaryexp -> number .)


state 35

    (54) primaryexp -> helpertype .

    BINARY_FNC      reduce using rule 54 (primaryexp -> helpertype .)
    LT              reduce using rule 54 (primaryexp -> helpertype .)
    GT              reduce using rule 54 (primaryexp -> helpertype .)
    LTE             reduce using rule 54 (primaryexp -> helpertype .)
    GTE             reduce using rule 54 (primaryexp -> helpertype .)
    EQUALITY        reduce using rule 54 (primaryexp -> helpertype .)
    INEQUALITY      reduce using rule 54 (primaryexp -> helpertype .)
    AND             reduce using rule 54 (primaryexp -> helpertype .)
    OR              reduce using rule 54 (primaryexp -> helpertype .)
    PLUS            reduce using rule 54 (primaryexp -> helpertype .)
    MINUS           reduce using rule 54 (primaryexp -> helpertype .)
    TIMES           reduce using rule 54 (primaryexp -> helpertype .)
    DIVIDE          reduce using rule 54 (primaryexp -> helpertype .)
    MOD             reduce using rule 54 (primaryexp -> helpertype .)
    POW             reduce using rule 54 (primaryexp -> helpertype .)
    SEMI_COLON      reduce using rule 54 (primaryexp -> helpertype .)
    COMMA           reduce using rule 54 (primaryexp -> helpertype .)
    $end            reduce using rule 54 (primaryexp -> helpertype .)
    RBRACE          reduce using rule 54 (primaryexp -> helpertype .)
    RPAREN          reduce using rule 54 (primaryexp -> helpertype .)
    RSPAREN         reduce using rule 54 (primaryexp -> helpertype .)
    TO              reduce using rule 54 (primaryexp -> helpertype .)
    STEP            reduce using rule 54 (primaryexp -> helpertype .)
    DO              reduce using rule 54 (primaryexp -> helpertype .)


state 36

    (60) primaryexp -> LPAREN . binaryexp RPAREN
    (49) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (50) binaryexp -> . primaryexp comparisonoperator primaryexp
    (51) binaryexp -> . primaryexp mathoperator primaryexp
    (52) primaryexp -> . number
    (53) primaryexp -> . identifier
    (54) primaryexp -> . helpertype
    (55) primaryexp -> . unaryexp
    (56) primaryexp -> . nularexp
    (57) primaryexp -> . string
    (58) primaryexp -> . binaryexp
    (59) primaryexp -> . bracedexp
    (60) primaryexp -> . LPAREN binaryexp RPAREN
    (61) primaryexp -> . array
    (98) number -> . NUMBER_REAL
    (99) number -> . NUMBER_EXP
    (100) number -> . NUMBER_HEX
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (74) unaryexp -> . UNARY_FNC primaryexp
    (75) unaryexp -> . PLUS primaryexp
    (76) unaryexp -> . MINUS primaryexp
    (77) unaryexp -> . NOT primaryexp
    (78) unaryexp -> . vardefinition
    (72) nularexp -> . NULAR_FNC
    (73) nularexp -> . identifier
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE
    (62) bracedexp -> . LBRACE new_scope code RBRACE
    (64) array -> . LSPAREN RSPAREN
    (65) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF forloop_condition
    (26) whiletype -> . WHILE forloop_condition
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (35) vardefinition -> . definition
    (36) vardefinition -> . arraydefinition
    (43) definition -> . PRIVATE PRIVATE_ID
    (44) definition -> . PRIVATE string
    (42) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 44
    NUMBER_EXP      shift and go to state 45
    NUMBER_HEX      shift and go to state 46
    PRIVATE_ID      shift and go to state 78
    GLOBAL_ID       shift and go to state 79
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 42
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    WITH            shift and go to state 49
    PRIVATE         shift and go to state 30

    binaryexp                      shift and go to state 98
    primaryexp                     shift and go to state 15
    number                         shift and go to state 34
    identifier                     shift and go to state 74
    helpertype                     shift and go to state 35
    unaryexp                       shift and go to state 75
    nularexp                       shift and go to state 76
    string                         shift and go to state 32
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 80
    whiletype                      shift and go to state 81
    fortype                        shift and go to state 82
    withtype                       shift and go to state 83
    vardefinition                  shift and go to state 23
    definition                     shift and go to state 84
    arraydefinition                shift and go to state 38

state 37

    (61) primaryexp -> array .

    BINARY_FNC      reduce using rule 61 (primaryexp -> array .)
    LT              reduce using rule 61 (primaryexp -> array .)
    GT              reduce using rule 61 (primaryexp -> array .)
    LTE             reduce using rule 61 (primaryexp -> array .)
    GTE             reduce using rule 61 (primaryexp -> array .)
    EQUALITY        reduce using rule 61 (primaryexp -> array .)
    INEQUALITY      reduce using rule 61 (primaryexp -> array .)
    AND             reduce using rule 61 (primaryexp -> array .)
    OR              reduce using rule 61 (primaryexp -> array .)
    PLUS            reduce using rule 61 (primaryexp -> array .)
    MINUS           reduce using rule 61 (primaryexp -> array .)
    TIMES           reduce using rule 61 (primaryexp -> array .)
    DIVIDE          reduce using rule 61 (primaryexp -> array .)
    MOD             reduce using rule 61 (primaryexp -> array .)
    POW             reduce using rule 61 (primaryexp -> array .)
    SEMI_COLON      reduce using rule 61 (primaryexp -> array .)
    COMMA           reduce using rule 61 (primaryexp -> array .)
    $end            reduce using rule 61 (primaryexp -> array .)
    RBRACE          reduce using rule 61 (primaryexp -> array .)
    RPAREN          reduce using rule 61 (primaryexp -> array .)
    RSPAREN         reduce using rule 61 (primaryexp -> array .)
    TO              reduce using rule 61 (primaryexp -> array .)
    STEP            reduce using rule 61 (primaryexp -> array .)
    DO              reduce using rule 61 (primaryexp -> array .)


state 38

    (36) vardefinition -> arraydefinition .

    SEMI_COLON      reduce using rule 36 (vardefinition -> arraydefinition .)
    COMMA           reduce using rule 36 (vardefinition -> arraydefinition .)
    $end            reduce using rule 36 (vardefinition -> arraydefinition .)
    BINARY_FNC      reduce using rule 36 (vardefinition -> arraydefinition .)
    LT              reduce using rule 36 (vardefinition -> arraydefinition .)
    GT              reduce using rule 36 (vardefinition -> arraydefinition .)
    LTE             reduce using rule 36 (vardefinition -> arraydefinition .)
    GTE             reduce using rule 36 (vardefinition -> arraydefinition .)
    EQUALITY        reduce using rule 36 (vardefinition -> arraydefinition .)
    INEQUALITY      reduce using rule 36 (vardefinition -> arraydefinition .)
    AND             reduce using rule 36 (vardefinition -> arraydefinition .)
    OR              reduce using rule 36 (vardefinition -> arraydefinition .)
    PLUS            reduce using rule 36 (vardefinition -> arraydefinition .)
    MINUS           reduce using rule 36 (vardefinition -> arraydefinition .)
    TIMES           reduce using rule 36 (vardefinition -> arraydefinition .)
    DIVIDE          reduce using rule 36 (vardefinition -> arraydefinition .)
    MOD             reduce using rule 36 (vardefinition -> arraydefinition .)
    POW             reduce using rule 36 (vardefinition -> arraydefinition .)
    RBRACE          reduce using rule 36 (vardefinition -> arraydefinition .)
    RPAREN          reduce using rule 36 (vardefinition -> arraydefinition .)
    RSPAREN         reduce using rule 36 (vardefinition -> arraydefinition .)
    TO              reduce using rule 36 (vardefinition -> arraydefinition .)
    STEP            reduce using rule 36 (vardefinition -> arraydefinition .)
    DO              reduce using rule 36 (vardefinition -> arraydefinition .)


state 39

    (19) iftype -> IF . forloop_condition
    (32) forloop_condition -> . LBRACE booleanexp RBRACE
    (33) forloop_condition -> . identifier
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID

    LBRACE          shift and go to state 100
    PRIVATE_ID      shift and go to state 78
    GLOBAL_ID       shift and go to state 79

    forloop_condition              shift and go to state 99
    identifier                     shift and go to state 101

state 40

    (26) whiletype -> WHILE . forloop_condition
    (32) forloop_condition -> . LBRACE booleanexp RBRACE
    (33) forloop_condition -> . identifier
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID

    LBRACE          shift and go to state 100
    PRIVATE_ID      shift and go to state 78
    GLOBAL_ID       shift and go to state 79

    forloop_condition              shift and go to state 102
    identifier                     shift and go to state 101

state 41

    (28) fortype -> FOR . new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> FOR . new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> FOR . new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (63) new_scope -> .

    LSPAREN         reduce using rule 63 (new_scope -> .)
    STRING_SINGLE   reduce using rule 63 (new_scope -> .)
    STRING_DOUBLE   reduce using rule 63 (new_scope -> .)

    new_scope                      shift and go to state 103

state 42

    (64) array -> LSPAREN . RSPAREN
    (65) array -> LSPAREN . arrayelement RSPAREN
    (66) arrayelement -> . binaryexp
    (67) arrayelement -> . binaryexp COMMA arrayelement
    (49) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (50) binaryexp -> . primaryexp comparisonoperator primaryexp
    (51) binaryexp -> . primaryexp mathoperator primaryexp
    (52) primaryexp -> . number
    (53) primaryexp -> . identifier
    (54) primaryexp -> . helpertype
    (55) primaryexp -> . unaryexp
    (56) primaryexp -> . nularexp
    (57) primaryexp -> . string
    (58) primaryexp -> . binaryexp
    (59) primaryexp -> . bracedexp
    (60) primaryexp -> . LPAREN binaryexp RPAREN
    (61) primaryexp -> . array
    (98) number -> . NUMBER_REAL
    (99) number -> . NUMBER_EXP
    (100) number -> . NUMBER_HEX
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (74) unaryexp -> . UNARY_FNC primaryexp
    (75) unaryexp -> . PLUS primaryexp
    (76) unaryexp -> . MINUS primaryexp
    (77) unaryexp -> . NOT primaryexp
    (78) unaryexp -> . vardefinition
    (72) nularexp -> . NULAR_FNC
    (73) nularexp -> . identifier
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE
    (62) bracedexp -> . LBRACE new_scope code RBRACE
    (64) array -> . LSPAREN RSPAREN
    (65) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF forloop_condition
    (26) whiletype -> . WHILE forloop_condition
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (35) vardefinition -> . definition
    (36) vardefinition -> . arraydefinition
    (43) definition -> . PRIVATE PRIVATE_ID
    (44) definition -> . PRIVATE string
    (42) arraydefinition -> . PRIVATE stringarray

    RSPAREN         shift and go to state 104
    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 44
    NUMBER_EXP      shift and go to state 45
    NUMBER_HEX      shift and go to state 46
    PRIVATE_ID      shift and go to state 78
    GLOBAL_ID       shift and go to state 79
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 42
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    WITH            shift and go to state 49
    PRIVATE         shift and go to state 30

    arrayelement                   shift and go to state 105
    binaryexp                      shift and go to state 106
    primaryexp                     shift and go to state 15
    number                         shift and go to state 34
    identifier                     shift and go to state 74
    helpertype                     shift and go to state 35
    unaryexp                       shift and go to state 75
    nularexp                       shift and go to state 76
    string                         shift and go to state 32
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 80
    whiletype                      shift and go to state 81
    fortype                        shift and go to state 82
    withtype                       shift and go to state 83
    vardefinition                  shift and go to state 23
    definition                     shift and go to state 84
    arraydefinition                shift and go to state 38

state 43

    (24) withstatementinit -> withtype . DO
    (18) helpertype -> withtype .

    DO              shift and go to state 107
    BINARY_FNC      reduce using rule 18 (helpertype -> withtype .)
    LT              reduce using rule 18 (helpertype -> withtype .)
    GT              reduce using rule 18 (helpertype -> withtype .)
    LTE             reduce using rule 18 (helpertype -> withtype .)
    GTE             reduce using rule 18 (helpertype -> withtype .)
    EQUALITY        reduce using rule 18 (helpertype -> withtype .)
    INEQUALITY      reduce using rule 18 (helpertype -> withtype .)
    AND             reduce using rule 18 (helpertype -> withtype .)
    OR              reduce using rule 18 (helpertype -> withtype .)
    PLUS            reduce using rule 18 (helpertype -> withtype .)
    MINUS           reduce using rule 18 (helpertype -> withtype .)
    TIMES           reduce using rule 18 (helpertype -> withtype .)
    DIVIDE          reduce using rule 18 (helpertype -> withtype .)
    MOD             reduce using rule 18 (helpertype -> withtype .)
    POW             reduce using rule 18 (helpertype -> withtype .)


state 44

    (98) number -> NUMBER_REAL .

    BINARY_FNC      reduce using rule 98 (number -> NUMBER_REAL .)
    LT              reduce using rule 98 (number -> NUMBER_REAL .)
    GT              reduce using rule 98 (number -> NUMBER_REAL .)
    LTE             reduce using rule 98 (number -> NUMBER_REAL .)
    GTE             reduce using rule 98 (number -> NUMBER_REAL .)
    EQUALITY        reduce using rule 98 (number -> NUMBER_REAL .)
    INEQUALITY      reduce using rule 98 (number -> NUMBER_REAL .)
    AND             reduce using rule 98 (number -> NUMBER_REAL .)
    OR              reduce using rule 98 (number -> NUMBER_REAL .)
    PLUS            reduce using rule 98 (number -> NUMBER_REAL .)
    MINUS           reduce using rule 98 (number -> NUMBER_REAL .)
    TIMES           reduce using rule 98 (number -> NUMBER_REAL .)
    DIVIDE          reduce using rule 98 (number -> NUMBER_REAL .)
    MOD             reduce using rule 98 (number -> NUMBER_REAL .)
    POW             reduce using rule 98 (number -> NUMBER_REAL .)
    SEMI_COLON      reduce using rule 98 (number -> NUMBER_REAL .)
    COMMA           reduce using rule 98 (number -> NUMBER_REAL .)
    $end            reduce using rule 98 (number -> NUMBER_REAL .)
    RBRACE          reduce using rule 98 (number -> NUMBER_REAL .)
    RPAREN          reduce using rule 98 (number -> NUMBER_REAL .)
    RSPAREN         reduce using rule 98 (number -> NUMBER_REAL .)
    TO              reduce using rule 98 (number -> NUMBER_REAL .)
    STEP            reduce using rule 98 (number -> NUMBER_REAL .)
    DO              reduce using rule 98 (number -> NUMBER_REAL .)


state 45

    (99) number -> NUMBER_EXP .

    BINARY_FNC      reduce using rule 99 (number -> NUMBER_EXP .)
    LT              reduce using rule 99 (number -> NUMBER_EXP .)
    GT              reduce using rule 99 (number -> NUMBER_EXP .)
    LTE             reduce using rule 99 (number -> NUMBER_EXP .)
    GTE             reduce using rule 99 (number -> NUMBER_EXP .)
    EQUALITY        reduce using rule 99 (number -> NUMBER_EXP .)
    INEQUALITY      reduce using rule 99 (number -> NUMBER_EXP .)
    AND             reduce using rule 99 (number -> NUMBER_EXP .)
    OR              reduce using rule 99 (number -> NUMBER_EXP .)
    PLUS            reduce using rule 99 (number -> NUMBER_EXP .)
    MINUS           reduce using rule 99 (number -> NUMBER_EXP .)
    TIMES           reduce using rule 99 (number -> NUMBER_EXP .)
    DIVIDE          reduce using rule 99 (number -> NUMBER_EXP .)
    MOD             reduce using rule 99 (number -> NUMBER_EXP .)
    POW             reduce using rule 99 (number -> NUMBER_EXP .)
    SEMI_COLON      reduce using rule 99 (number -> NUMBER_EXP .)
    COMMA           reduce using rule 99 (number -> NUMBER_EXP .)
    $end            reduce using rule 99 (number -> NUMBER_EXP .)
    RBRACE          reduce using rule 99 (number -> NUMBER_EXP .)
    RPAREN          reduce using rule 99 (number -> NUMBER_EXP .)
    RSPAREN         reduce using rule 99 (number -> NUMBER_EXP .)
    TO              reduce using rule 99 (number -> NUMBER_EXP .)
    STEP            reduce using rule 99 (number -> NUMBER_EXP .)
    DO              reduce using rule 99 (number -> NUMBER_EXP .)


state 46

    (100) number -> NUMBER_HEX .

    BINARY_FNC      reduce using rule 100 (number -> NUMBER_HEX .)
    LT              reduce using rule 100 (number -> NUMBER_HEX .)
    GT              reduce using rule 100 (number -> NUMBER_HEX .)
    LTE             reduce using rule 100 (number -> NUMBER_HEX .)
    GTE             reduce using rule 100 (number -> NUMBER_HEX .)
    EQUALITY        reduce using rule 100 (number -> NUMBER_HEX .)
    INEQUALITY      reduce using rule 100 (number -> NUMBER_HEX .)
    AND             reduce using rule 100 (number -> NUMBER_HEX .)
    OR              reduce using rule 100 (number -> NUMBER_HEX .)
    PLUS            reduce using rule 100 (number -> NUMBER_HEX .)
    MINUS           reduce using rule 100 (number -> NUMBER_HEX .)
    TIMES           reduce using rule 100 (number -> NUMBER_HEX .)
    DIVIDE          reduce using rule 100 (number -> NUMBER_HEX .)
    MOD             reduce using rule 100 (number -> NUMBER_HEX .)
    POW             reduce using rule 100 (number -> NUMBER_HEX .)
    SEMI_COLON      reduce using rule 100 (number -> NUMBER_HEX .)
    COMMA           reduce using rule 100 (number -> NUMBER_HEX .)
    $end            reduce using rule 100 (number -> NUMBER_HEX .)
    RBRACE          reduce using rule 100 (number -> NUMBER_HEX .)
    RPAREN          reduce using rule 100 (number -> NUMBER_HEX .)
    RSPAREN         reduce using rule 100 (number -> NUMBER_HEX .)
    TO              reduce using rule 100 (number -> NUMBER_HEX .)
    STEP            reduce using rule 100 (number -> NUMBER_HEX .)
    DO              reduce using rule 100 (number -> NUMBER_HEX .)


state 47

    (101) string -> STRING_SINGLE .

    BINARY_FNC      reduce using rule 101 (string -> STRING_SINGLE .)
    LT              reduce using rule 101 (string -> STRING_SINGLE .)
    GT              reduce using rule 101 (string -> STRING_SINGLE .)
    LTE             reduce using rule 101 (string -> STRING_SINGLE .)
    GTE             reduce using rule 101 (string -> STRING_SINGLE .)
    EQUALITY        reduce using rule 101 (string -> STRING_SINGLE .)
    INEQUALITY      reduce using rule 101 (string -> STRING_SINGLE .)
    AND             reduce using rule 101 (string -> STRING_SINGLE .)
    OR              reduce using rule 101 (string -> STRING_SINGLE .)
    PLUS            reduce using rule 101 (string -> STRING_SINGLE .)
    MINUS           reduce using rule 101 (string -> STRING_SINGLE .)
    TIMES           reduce using rule 101 (string -> STRING_SINGLE .)
    DIVIDE          reduce using rule 101 (string -> STRING_SINGLE .)
    MOD             reduce using rule 101 (string -> STRING_SINGLE .)
    POW             reduce using rule 101 (string -> STRING_SINGLE .)
    SEMI_COLON      reduce using rule 101 (string -> STRING_SINGLE .)
    COMMA           reduce using rule 101 (string -> STRING_SINGLE .)
    $end            reduce using rule 101 (string -> STRING_SINGLE .)
    RBRACE          reduce using rule 101 (string -> STRING_SINGLE .)
    RPAREN          reduce using rule 101 (string -> STRING_SINGLE .)
    RSPAREN         reduce using rule 101 (string -> STRING_SINGLE .)
    TO              reduce using rule 101 (string -> STRING_SINGLE .)
    STEP            reduce using rule 101 (string -> STRING_SINGLE .)
    DO              reduce using rule 101 (string -> STRING_SINGLE .)
    EQUAL           reduce using rule 101 (string -> STRING_SINGLE .)
    FROM            reduce using rule 101 (string -> STRING_SINGLE .)


state 48

    (102) string -> STRING_DOUBLE .

    BINARY_FNC      reduce using rule 102 (string -> STRING_DOUBLE .)
    LT              reduce using rule 102 (string -> STRING_DOUBLE .)
    GT              reduce using rule 102 (string -> STRING_DOUBLE .)
    LTE             reduce using rule 102 (string -> STRING_DOUBLE .)
    GTE             reduce using rule 102 (string -> STRING_DOUBLE .)
    EQUALITY        reduce using rule 102 (string -> STRING_DOUBLE .)
    INEQUALITY      reduce using rule 102 (string -> STRING_DOUBLE .)
    AND             reduce using rule 102 (string -> STRING_DOUBLE .)
    OR              reduce using rule 102 (string -> STRING_DOUBLE .)
    PLUS            reduce using rule 102 (string -> STRING_DOUBLE .)
    MINUS           reduce using rule 102 (string -> STRING_DOUBLE .)
    TIMES           reduce using rule 102 (string -> STRING_DOUBLE .)
    DIVIDE          reduce using rule 102 (string -> STRING_DOUBLE .)
    MOD             reduce using rule 102 (string -> STRING_DOUBLE .)
    POW             reduce using rule 102 (string -> STRING_DOUBLE .)
    SEMI_COLON      reduce using rule 102 (string -> STRING_DOUBLE .)
    COMMA           reduce using rule 102 (string -> STRING_DOUBLE .)
    $end            reduce using rule 102 (string -> STRING_DOUBLE .)
    RBRACE          reduce using rule 102 (string -> STRING_DOUBLE .)
    RPAREN          reduce using rule 102 (string -> STRING_DOUBLE .)
    RSPAREN         reduce using rule 102 (string -> STRING_DOUBLE .)
    TO              reduce using rule 102 (string -> STRING_DOUBLE .)
    STEP            reduce using rule 102 (string -> STRING_DOUBLE .)
    DO              reduce using rule 102 (string -> STRING_DOUBLE .)
    EQUAL           reduce using rule 102 (string -> STRING_DOUBLE .)
    FROM            reduce using rule 102 (string -> STRING_DOUBLE .)


state 49

    (23) withtype -> WITH . NAMESPACE

    NAMESPACE       shift and go to state 108


state 50

    (3) code -> statement terminator . code
    (1) code -> . empty
    (2) code -> . statement
    (3) code -> . statement terminator code
    (103) empty -> .
    (4) statement -> . controlstructure
    (5) statement -> . assignment
    (6) statement -> . binaryexp
    (7) statement -> . nularexp
    (8) statement -> . unaryexp
    (11) controlstructure -> . ifstatement
    (12) controlstructure -> . whileloop
    (13) controlstructure -> . forloop
    (14) controlstructure -> . withstatement
    (37) assignment -> . assignment_code code RBRACE
    (38) assignment -> . definition EQUAL primaryexp
    (39) assignment -> . variable EQUAL primaryexp
    (49) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (50) binaryexp -> . primaryexp comparisonoperator primaryexp
    (51) binaryexp -> . primaryexp mathoperator primaryexp
    (72) nularexp -> . NULAR_FNC
    (73) nularexp -> . identifier
    (74) unaryexp -> . UNARY_FNC primaryexp
    (75) unaryexp -> . PLUS primaryexp
    (76) unaryexp -> . MINUS primaryexp
    (77) unaryexp -> . NOT primaryexp
    (78) unaryexp -> . vardefinition
    (20) ifstatement -> . iftype THEN bracedexp
    (21) ifstatement -> . iftype EXITWITH bracedexp
    (22) ifstatement -> . iftype THEN bracedexp ELSE bracedexp
    (27) whileloop -> . whiletype DO bracedexp
    (31) forloop -> . fortype DO bracedexp_noscope
    (25) withstatement -> . withstatementinit bracedexp
    (40) assignment_code -> . definition EQUAL LBRACE
    (41) assignment_code -> . variable EQUAL LBRACE
    (43) definition -> . PRIVATE PRIVATE_ID
    (44) definition -> . PRIVATE string
    (47) variable -> . PRIVATE_ID
    (48) variable -> . GLOBAL_ID
    (52) primaryexp -> . number
    (53) primaryexp -> . identifier
    (54) primaryexp -> . helpertype
    (55) primaryexp -> . unaryexp
    (56) primaryexp -> . nularexp
    (57) primaryexp -> . string
    (58) primaryexp -> . binaryexp
    (59) primaryexp -> . bracedexp
    (60) primaryexp -> . LPAREN binaryexp RPAREN
    (61) primaryexp -> . array
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID
    (35) vardefinition -> . definition
    (36) vardefinition -> . arraydefinition
    (19) iftype -> . IF forloop_condition
    (26) whiletype -> . WHILE forloop_condition
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (24) withstatementinit -> . withtype DO
    (98) number -> . NUMBER_REAL
    (99) number -> . NUMBER_EXP
    (100) number -> . NUMBER_HEX
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE
    (62) bracedexp -> . LBRACE new_scope code RBRACE
    (64) array -> . LSPAREN RSPAREN
    (65) array -> . LSPAREN arrayelement RSPAREN
    (42) arraydefinition -> . PRIVATE stringarray
    (23) withtype -> . WITH NAMESPACE

    $end            reduce using rule 103 (empty -> .)
    RBRACE          reduce using rule 103 (empty -> .)
    NULAR_FNC       shift and go to state 17
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    PRIVATE         shift and go to state 30
    PRIVATE_ID      shift and go to state 31
    GLOBAL_ID       shift and go to state 33
    LPAREN          shift and go to state 36
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    NUMBER_REAL     shift and go to state 44
    NUMBER_EXP      shift and go to state 45
    NUMBER_HEX      shift and go to state 46
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 42
    WITH            shift and go to state 49

    statement                      shift and go to state 3
    code                           shift and go to state 109
    empty                          shift and go to state 2
    controlstructure               shift and go to state 4
    assignment                     shift and go to state 5
    binaryexp                      shift and go to state 6
    nularexp                       shift and go to state 7
    unaryexp                       shift and go to state 8
    ifstatement                    shift and go to state 9
    whileloop                      shift and go to state 10
    forloop                        shift and go to state 11
    withstatement                  shift and go to state 12
    assignment_code                shift and go to state 13
    definition                     shift and go to state 14
    primaryexp                     shift and go to state 15
    variable                       shift and go to state 16
    identifier                     shift and go to state 18
    vardefinition                  shift and go to state 23
    iftype                         shift and go to state 24
    bracedexp                      shift and go to state 25
    whiletype                      shift and go to state 26
    fortype                        shift and go to state 27
    withstatementinit              shift and go to state 28
    string                         shift and go to state 32
    number                         shift and go to state 34
    helpertype                     shift and go to state 35
    array                          shift and go to state 37
    arraydefinition                shift and go to state 38
    withtype                       shift and go to state 43

state 51

    (9) terminator -> SEMI_COLON .

    NULAR_FNC       reduce using rule 9 (terminator -> SEMI_COLON .)
    UNARY_FNC       reduce using rule 9 (terminator -> SEMI_COLON .)
    PLUS            reduce using rule 9 (terminator -> SEMI_COLON .)
    MINUS           reduce using rule 9 (terminator -> SEMI_COLON .)
    NOT             reduce using rule 9 (terminator -> SEMI_COLON .)
    PRIVATE         reduce using rule 9 (terminator -> SEMI_COLON .)
    PRIVATE_ID      reduce using rule 9 (terminator -> SEMI_COLON .)
    GLOBAL_ID       reduce using rule 9 (terminator -> SEMI_COLON .)
    LPAREN          reduce using rule 9 (terminator -> SEMI_COLON .)
    IF              reduce using rule 9 (terminator -> SEMI_COLON .)
    WHILE           reduce using rule 9 (terminator -> SEMI_COLON .)
    FOR             reduce using rule 9 (terminator -> SEMI_COLON .)
    NUMBER_REAL     reduce using rule 9 (terminator -> SEMI_COLON .)
    NUMBER_EXP      reduce using rule 9 (terminator -> SEMI_COLON .)
    NUMBER_HEX      reduce using rule 9 (terminator -> SEMI_COLON .)
    STRING_SINGLE   reduce using rule 9 (terminator -> SEMI_COLON .)
    STRING_DOUBLE   reduce using rule 9 (terminator -> SEMI_COLON .)
    LBRACE          reduce using rule 9 (terminator -> SEMI_COLON .)
    LSPAREN         reduce using rule 9 (terminator -> SEMI_COLON .)
    WITH            reduce using rule 9 (terminator -> SEMI_COLON .)
    $end            reduce using rule 9 (terminator -> SEMI_COLON .)
    RBRACE          reduce using rule 9 (terminator -> SEMI_COLON .)


state 52

    (10) terminator -> COMMA .

    NULAR_FNC       reduce using rule 10 (terminator -> COMMA .)
    UNARY_FNC       reduce using rule 10 (terminator -> COMMA .)
    PLUS            reduce using rule 10 (terminator -> COMMA .)
    MINUS           reduce using rule 10 (terminator -> COMMA .)
    NOT             reduce using rule 10 (terminator -> COMMA .)
    PRIVATE         reduce using rule 10 (terminator -> COMMA .)
    PRIVATE_ID      reduce using rule 10 (terminator -> COMMA .)
    GLOBAL_ID       reduce using rule 10 (terminator -> COMMA .)
    LPAREN          reduce using rule 10 (terminator -> COMMA .)
    IF              reduce using rule 10 (terminator -> COMMA .)
    WHILE           reduce using rule 10 (terminator -> COMMA .)
    FOR             reduce using rule 10 (terminator -> COMMA .)
    NUMBER_REAL     reduce using rule 10 (terminator -> COMMA .)
    NUMBER_EXP      reduce using rule 10 (terminator -> COMMA .)
    NUMBER_HEX      reduce using rule 10 (terminator -> COMMA .)
    STRING_SINGLE   reduce using rule 10 (terminator -> COMMA .)
    STRING_DOUBLE   reduce using rule 10 (terminator -> COMMA .)
    LBRACE          reduce using rule 10 (terminator -> COMMA .)
    LSPAREN         reduce using rule 10 (terminator -> COMMA .)
    WITH            reduce using rule 10 (terminator -> COMMA .)
    $end            reduce using rule 10 (terminator -> COMMA .)
    RBRACE          reduce using rule 10 (terminator -> COMMA .)


state 53

    (37) assignment -> assignment_code code . RBRACE

    RBRACE          shift and go to state 110


state 54

    (38) assignment -> definition EQUAL . primaryexp
    (40) assignment_code -> definition EQUAL . LBRACE
    (52) primaryexp -> . number
    (53) primaryexp -> . identifier
    (54) primaryexp -> . helpertype
    (55) primaryexp -> . unaryexp
    (56) primaryexp -> . nularexp
    (57) primaryexp -> . string
    (58) primaryexp -> . binaryexp
    (59) primaryexp -> . bracedexp
    (60) primaryexp -> . LPAREN binaryexp RPAREN
    (61) primaryexp -> . array
    (98) number -> . NUMBER_REAL
    (99) number -> . NUMBER_EXP
    (100) number -> . NUMBER_HEX
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (74) unaryexp -> . UNARY_FNC primaryexp
    (75) unaryexp -> . PLUS primaryexp
    (76) unaryexp -> . MINUS primaryexp
    (77) unaryexp -> . NOT primaryexp
    (78) unaryexp -> . vardefinition
    (72) nularexp -> . NULAR_FNC
    (73) nularexp -> . identifier
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE
    (49) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (50) binaryexp -> . primaryexp comparisonoperator primaryexp
    (51) binaryexp -> . primaryexp mathoperator primaryexp
    (62) bracedexp -> . LBRACE new_scope code RBRACE
    (64) array -> . LSPAREN RSPAREN
    (65) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF forloop_condition
    (26) whiletype -> . WHILE forloop_condition
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (35) vardefinition -> . definition
    (36) vardefinition -> . arraydefinition
    (43) definition -> . PRIVATE PRIVATE_ID
    (44) definition -> . PRIVATE string
    (42) arraydefinition -> . PRIVATE stringarray

    LBRACE          shift and go to state 112
    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 44
    NUMBER_EXP      shift and go to state 45
    NUMBER_HEX      shift and go to state 46
    PRIVATE_ID      shift and go to state 78
    GLOBAL_ID       shift and go to state 79
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48
    LSPAREN         shift and go to state 42
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    WITH            shift and go to state 49
    PRIVATE         shift and go to state 30

    definition                     shift and go to state 84
    primaryexp                     shift and go to state 111
    number                         shift and go to state 34
    identifier                     shift and go to state 74
    helpertype                     shift and go to state 35
    unaryexp                       shift and go to state 75
    nularexp                       shift and go to state 76
    string                         shift and go to state 32
    binaryexp                      shift and go to state 77
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 80
    whiletype                      shift and go to state 81
    fortype                        shift and go to state 82
    withtype                       shift and go to state 83
    vardefinition                  shift and go to state 23
    arraydefinition                shift and go to state 38

state 55

    (49) binaryexp -> primaryexp BINARY_FNC . primaryexp
    (52) primaryexp -> . number
    (53) primaryexp -> . identifier
    (54) primaryexp -> . helpertype
    (55) primaryexp -> . unaryexp
    (56) primaryexp -> . nularexp
    (57) primaryexp -> . string
    (58) primaryexp -> . binaryexp
    (59) primaryexp -> . bracedexp
    (60) primaryexp -> . LPAREN binaryexp RPAREN
    (61) primaryexp -> . array
    (98) number -> . NUMBER_REAL
    (99) number -> . NUMBER_EXP
    (100) number -> . NUMBER_HEX
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (74) unaryexp -> . UNARY_FNC primaryexp
    (75) unaryexp -> . PLUS primaryexp
    (76) unaryexp -> . MINUS primaryexp
    (77) unaryexp -> . NOT primaryexp
    (78) unaryexp -> . vardefinition
    (72) nularexp -> . NULAR_FNC
    (73) nularexp -> . identifier
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE
    (49) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (50) binaryexp -> . primaryexp comparisonoperator primaryexp
    (51) binaryexp -> . primaryexp mathoperator primaryexp
    (62) bracedexp -> . LBRACE new_scope code RBRACE
    (64) array -> . LSPAREN RSPAREN
    (65) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF forloop_condition
    (26) whiletype -> . WHILE forloop_condition
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (35) vardefinition -> . definition
    (36) vardefinition -> . arraydefinition
    (43) definition -> . PRIVATE PRIVATE_ID
    (44) definition -> . PRIVATE string
    (42) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 44
    NUMBER_EXP      shift and go to state 45
    NUMBER_HEX      shift and go to state 46
    PRIVATE_ID      shift and go to state 78
    GLOBAL_ID       shift and go to state 79
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 42
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    WITH            shift and go to state 49
    PRIVATE         shift and go to state 30

    primaryexp                     shift and go to state 113
    number                         shift and go to state 34
    identifier                     shift and go to state 74
    helpertype                     shift and go to state 35
    unaryexp                       shift and go to state 75
    nularexp                       shift and go to state 76
    string                         shift and go to state 32
    binaryexp                      shift and go to state 77
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 80
    whiletype                      shift and go to state 81
    fortype                        shift and go to state 82
    withtype                       shift and go to state 83
    vardefinition                  shift and go to state 23
    definition                     shift and go to state 84
    arraydefinition                shift and go to state 38

state 56

    (50) binaryexp -> primaryexp comparisonoperator . primaryexp
    (52) primaryexp -> . number
    (53) primaryexp -> . identifier
    (54) primaryexp -> . helpertype
    (55) primaryexp -> . unaryexp
    (56) primaryexp -> . nularexp
    (57) primaryexp -> . string
    (58) primaryexp -> . binaryexp
    (59) primaryexp -> . bracedexp
    (60) primaryexp -> . LPAREN binaryexp RPAREN
    (61) primaryexp -> . array
    (98) number -> . NUMBER_REAL
    (99) number -> . NUMBER_EXP
    (100) number -> . NUMBER_HEX
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (74) unaryexp -> . UNARY_FNC primaryexp
    (75) unaryexp -> . PLUS primaryexp
    (76) unaryexp -> . MINUS primaryexp
    (77) unaryexp -> . NOT primaryexp
    (78) unaryexp -> . vardefinition
    (72) nularexp -> . NULAR_FNC
    (73) nularexp -> . identifier
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE
    (49) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (50) binaryexp -> . primaryexp comparisonoperator primaryexp
    (51) binaryexp -> . primaryexp mathoperator primaryexp
    (62) bracedexp -> . LBRACE new_scope code RBRACE
    (64) array -> . LSPAREN RSPAREN
    (65) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF forloop_condition
    (26) whiletype -> . WHILE forloop_condition
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (35) vardefinition -> . definition
    (36) vardefinition -> . arraydefinition
    (43) definition -> . PRIVATE PRIVATE_ID
    (44) definition -> . PRIVATE string
    (42) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 44
    NUMBER_EXP      shift and go to state 45
    NUMBER_HEX      shift and go to state 46
    PRIVATE_ID      shift and go to state 78
    GLOBAL_ID       shift and go to state 79
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 42
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    WITH            shift and go to state 49
    PRIVATE         shift and go to state 30

    primaryexp                     shift and go to state 114
    number                         shift and go to state 34
    identifier                     shift and go to state 74
    helpertype                     shift and go to state 35
    unaryexp                       shift and go to state 75
    nularexp                       shift and go to state 76
    string                         shift and go to state 32
    binaryexp                      shift and go to state 77
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 80
    whiletype                      shift and go to state 81
    fortype                        shift and go to state 82
    withtype                       shift and go to state 83
    vardefinition                  shift and go to state 23
    definition                     shift and go to state 84
    arraydefinition                shift and go to state 38

state 57

    (51) binaryexp -> primaryexp mathoperator . primaryexp
    (52) primaryexp -> . number
    (53) primaryexp -> . identifier
    (54) primaryexp -> . helpertype
    (55) primaryexp -> . unaryexp
    (56) primaryexp -> . nularexp
    (57) primaryexp -> . string
    (58) primaryexp -> . binaryexp
    (59) primaryexp -> . bracedexp
    (60) primaryexp -> . LPAREN binaryexp RPAREN
    (61) primaryexp -> . array
    (98) number -> . NUMBER_REAL
    (99) number -> . NUMBER_EXP
    (100) number -> . NUMBER_HEX
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (74) unaryexp -> . UNARY_FNC primaryexp
    (75) unaryexp -> . PLUS primaryexp
    (76) unaryexp -> . MINUS primaryexp
    (77) unaryexp -> . NOT primaryexp
    (78) unaryexp -> . vardefinition
    (72) nularexp -> . NULAR_FNC
    (73) nularexp -> . identifier
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE
    (49) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (50) binaryexp -> . primaryexp comparisonoperator primaryexp
    (51) binaryexp -> . primaryexp mathoperator primaryexp
    (62) bracedexp -> . LBRACE new_scope code RBRACE
    (64) array -> . LSPAREN RSPAREN
    (65) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF forloop_condition
    (26) whiletype -> . WHILE forloop_condition
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (35) vardefinition -> . definition
    (36) vardefinition -> . arraydefinition
    (43) definition -> . PRIVATE PRIVATE_ID
    (44) definition -> . PRIVATE string
    (42) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 44
    NUMBER_EXP      shift and go to state 45
    NUMBER_HEX      shift and go to state 46
    PRIVATE_ID      shift and go to state 78
    GLOBAL_ID       shift and go to state 79
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 42
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    WITH            shift and go to state 49
    PRIVATE         shift and go to state 30

    primaryexp                     shift and go to state 115
    number                         shift and go to state 34
    identifier                     shift and go to state 74
    helpertype                     shift and go to state 35
    unaryexp                       shift and go to state 75
    nularexp                       shift and go to state 76
    string                         shift and go to state 32
    binaryexp                      shift and go to state 77
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 80
    whiletype                      shift and go to state 81
    fortype                        shift and go to state 82
    withtype                       shift and go to state 83
    vardefinition                  shift and go to state 23
    definition                     shift and go to state 84
    arraydefinition                shift and go to state 38

state 58

    (79) comparisonoperator -> LT .

    LPAREN          reduce using rule 79 (comparisonoperator -> LT .)
    NUMBER_REAL     reduce using rule 79 (comparisonoperator -> LT .)
    NUMBER_EXP      reduce using rule 79 (comparisonoperator -> LT .)
    NUMBER_HEX      reduce using rule 79 (comparisonoperator -> LT .)
    PRIVATE_ID      reduce using rule 79 (comparisonoperator -> LT .)
    GLOBAL_ID       reduce using rule 79 (comparisonoperator -> LT .)
    UNARY_FNC       reduce using rule 79 (comparisonoperator -> LT .)
    PLUS            reduce using rule 79 (comparisonoperator -> LT .)
    MINUS           reduce using rule 79 (comparisonoperator -> LT .)
    NOT             reduce using rule 79 (comparisonoperator -> LT .)
    NULAR_FNC       reduce using rule 79 (comparisonoperator -> LT .)
    STRING_SINGLE   reduce using rule 79 (comparisonoperator -> LT .)
    STRING_DOUBLE   reduce using rule 79 (comparisonoperator -> LT .)
    LBRACE          reduce using rule 79 (comparisonoperator -> LT .)
    LSPAREN         reduce using rule 79 (comparisonoperator -> LT .)
    IF              reduce using rule 79 (comparisonoperator -> LT .)
    WHILE           reduce using rule 79 (comparisonoperator -> LT .)
    FOR             reduce using rule 79 (comparisonoperator -> LT .)
    WITH            reduce using rule 79 (comparisonoperator -> LT .)
    PRIVATE         reduce using rule 79 (comparisonoperator -> LT .)


state 59

    (80) comparisonoperator -> GT .

    LPAREN          reduce using rule 80 (comparisonoperator -> GT .)
    NUMBER_REAL     reduce using rule 80 (comparisonoperator -> GT .)
    NUMBER_EXP      reduce using rule 80 (comparisonoperator -> GT .)
    NUMBER_HEX      reduce using rule 80 (comparisonoperator -> GT .)
    PRIVATE_ID      reduce using rule 80 (comparisonoperator -> GT .)
    GLOBAL_ID       reduce using rule 80 (comparisonoperator -> GT .)
    UNARY_FNC       reduce using rule 80 (comparisonoperator -> GT .)
    PLUS            reduce using rule 80 (comparisonoperator -> GT .)
    MINUS           reduce using rule 80 (comparisonoperator -> GT .)
    NOT             reduce using rule 80 (comparisonoperator -> GT .)
    NULAR_FNC       reduce using rule 80 (comparisonoperator -> GT .)
    STRING_SINGLE   reduce using rule 80 (comparisonoperator -> GT .)
    STRING_DOUBLE   reduce using rule 80 (comparisonoperator -> GT .)
    LBRACE          reduce using rule 80 (comparisonoperator -> GT .)
    LSPAREN         reduce using rule 80 (comparisonoperator -> GT .)
    IF              reduce using rule 80 (comparisonoperator -> GT .)
    WHILE           reduce using rule 80 (comparisonoperator -> GT .)
    FOR             reduce using rule 80 (comparisonoperator -> GT .)
    WITH            reduce using rule 80 (comparisonoperator -> GT .)
    PRIVATE         reduce using rule 80 (comparisonoperator -> GT .)


state 60

    (81) comparisonoperator -> LTE .

    LPAREN          reduce using rule 81 (comparisonoperator -> LTE .)
    NUMBER_REAL     reduce using rule 81 (comparisonoperator -> LTE .)
    NUMBER_EXP      reduce using rule 81 (comparisonoperator -> LTE .)
    NUMBER_HEX      reduce using rule 81 (comparisonoperator -> LTE .)
    PRIVATE_ID      reduce using rule 81 (comparisonoperator -> LTE .)
    GLOBAL_ID       reduce using rule 81 (comparisonoperator -> LTE .)
    UNARY_FNC       reduce using rule 81 (comparisonoperator -> LTE .)
    PLUS            reduce using rule 81 (comparisonoperator -> LTE .)
    MINUS           reduce using rule 81 (comparisonoperator -> LTE .)
    NOT             reduce using rule 81 (comparisonoperator -> LTE .)
    NULAR_FNC       reduce using rule 81 (comparisonoperator -> LTE .)
    STRING_SINGLE   reduce using rule 81 (comparisonoperator -> LTE .)
    STRING_DOUBLE   reduce using rule 81 (comparisonoperator -> LTE .)
    LBRACE          reduce using rule 81 (comparisonoperator -> LTE .)
    LSPAREN         reduce using rule 81 (comparisonoperator -> LTE .)
    IF              reduce using rule 81 (comparisonoperator -> LTE .)
    WHILE           reduce using rule 81 (comparisonoperator -> LTE .)
    FOR             reduce using rule 81 (comparisonoperator -> LTE .)
    WITH            reduce using rule 81 (comparisonoperator -> LTE .)
    PRIVATE         reduce using rule 81 (comparisonoperator -> LTE .)


state 61

    (82) comparisonoperator -> GTE .

    LPAREN          reduce using rule 82 (comparisonoperator -> GTE .)
    NUMBER_REAL     reduce using rule 82 (comparisonoperator -> GTE .)
    NUMBER_EXP      reduce using rule 82 (comparisonoperator -> GTE .)
    NUMBER_HEX      reduce using rule 82 (comparisonoperator -> GTE .)
    PRIVATE_ID      reduce using rule 82 (comparisonoperator -> GTE .)
    GLOBAL_ID       reduce using rule 82 (comparisonoperator -> GTE .)
    UNARY_FNC       reduce using rule 82 (comparisonoperator -> GTE .)
    PLUS            reduce using rule 82 (comparisonoperator -> GTE .)
    MINUS           reduce using rule 82 (comparisonoperator -> GTE .)
    NOT             reduce using rule 82 (comparisonoperator -> GTE .)
    NULAR_FNC       reduce using rule 82 (comparisonoperator -> GTE .)
    STRING_SINGLE   reduce using rule 82 (comparisonoperator -> GTE .)
    STRING_DOUBLE   reduce using rule 82 (comparisonoperator -> GTE .)
    LBRACE          reduce using rule 82 (comparisonoperator -> GTE .)
    LSPAREN         reduce using rule 82 (comparisonoperator -> GTE .)
    IF              reduce using rule 82 (comparisonoperator -> GTE .)
    WHILE           reduce using rule 82 (comparisonoperator -> GTE .)
    FOR             reduce using rule 82 (comparisonoperator -> GTE .)
    WITH            reduce using rule 82 (comparisonoperator -> GTE .)
    PRIVATE         reduce using rule 82 (comparisonoperator -> GTE .)


state 62

    (83) comparisonoperator -> EQUALITY .

    LPAREN          reduce using rule 83 (comparisonoperator -> EQUALITY .)
    NUMBER_REAL     reduce using rule 83 (comparisonoperator -> EQUALITY .)
    NUMBER_EXP      reduce using rule 83 (comparisonoperator -> EQUALITY .)
    NUMBER_HEX      reduce using rule 83 (comparisonoperator -> EQUALITY .)
    PRIVATE_ID      reduce using rule 83 (comparisonoperator -> EQUALITY .)
    GLOBAL_ID       reduce using rule 83 (comparisonoperator -> EQUALITY .)
    UNARY_FNC       reduce using rule 83 (comparisonoperator -> EQUALITY .)
    PLUS            reduce using rule 83 (comparisonoperator -> EQUALITY .)
    MINUS           reduce using rule 83 (comparisonoperator -> EQUALITY .)
    NOT             reduce using rule 83 (comparisonoperator -> EQUALITY .)
    NULAR_FNC       reduce using rule 83 (comparisonoperator -> EQUALITY .)
    STRING_SINGLE   reduce using rule 83 (comparisonoperator -> EQUALITY .)
    STRING_DOUBLE   reduce using rule 83 (comparisonoperator -> EQUALITY .)
    LBRACE          reduce using rule 83 (comparisonoperator -> EQUALITY .)
    LSPAREN         reduce using rule 83 (comparisonoperator -> EQUALITY .)
    IF              reduce using rule 83 (comparisonoperator -> EQUALITY .)
    WHILE           reduce using rule 83 (comparisonoperator -> EQUALITY .)
    FOR             reduce using rule 83 (comparisonoperator -> EQUALITY .)
    WITH            reduce using rule 83 (comparisonoperator -> EQUALITY .)
    PRIVATE         reduce using rule 83 (comparisonoperator -> EQUALITY .)


state 63

    (84) comparisonoperator -> INEQUALITY .

    LPAREN          reduce using rule 84 (comparisonoperator -> INEQUALITY .)
    NUMBER_REAL     reduce using rule 84 (comparisonoperator -> INEQUALITY .)
    NUMBER_EXP      reduce using rule 84 (comparisonoperator -> INEQUALITY .)
    NUMBER_HEX      reduce using rule 84 (comparisonoperator -> INEQUALITY .)
    PRIVATE_ID      reduce using rule 84 (comparisonoperator -> INEQUALITY .)
    GLOBAL_ID       reduce using rule 84 (comparisonoperator -> INEQUALITY .)
    UNARY_FNC       reduce using rule 84 (comparisonoperator -> INEQUALITY .)
    PLUS            reduce using rule 84 (comparisonoperator -> INEQUALITY .)
    MINUS           reduce using rule 84 (comparisonoperator -> INEQUALITY .)
    NOT             reduce using rule 84 (comparisonoperator -> INEQUALITY .)
    NULAR_FNC       reduce using rule 84 (comparisonoperator -> INEQUALITY .)
    STRING_SINGLE   reduce using rule 84 (comparisonoperator -> INEQUALITY .)
    STRING_DOUBLE   reduce using rule 84 (comparisonoperator -> INEQUALITY .)
    LBRACE          reduce using rule 84 (comparisonoperator -> INEQUALITY .)
    LSPAREN         reduce using rule 84 (comparisonoperator -> INEQUALITY .)
    IF              reduce using rule 84 (comparisonoperator -> INEQUALITY .)
    WHILE           reduce using rule 84 (comparisonoperator -> INEQUALITY .)
    FOR             reduce using rule 84 (comparisonoperator -> INEQUALITY .)
    WITH            reduce using rule 84 (comparisonoperator -> INEQUALITY .)
    PRIVATE         reduce using rule 84 (comparisonoperator -> INEQUALITY .)


state 64

    (85) comparisonoperator -> AND .

    LPAREN          reduce using rule 85 (comparisonoperator -> AND .)
    NUMBER_REAL     reduce using rule 85 (comparisonoperator -> AND .)
    NUMBER_EXP      reduce using rule 85 (comparisonoperator -> AND .)
    NUMBER_HEX      reduce using rule 85 (comparisonoperator -> AND .)
    PRIVATE_ID      reduce using rule 85 (comparisonoperator -> AND .)
    GLOBAL_ID       reduce using rule 85 (comparisonoperator -> AND .)
    UNARY_FNC       reduce using rule 85 (comparisonoperator -> AND .)
    PLUS            reduce using rule 85 (comparisonoperator -> AND .)
    MINUS           reduce using rule 85 (comparisonoperator -> AND .)
    NOT             reduce using rule 85 (comparisonoperator -> AND .)
    NULAR_FNC       reduce using rule 85 (comparisonoperator -> AND .)
    STRING_SINGLE   reduce using rule 85 (comparisonoperator -> AND .)
    STRING_DOUBLE   reduce using rule 85 (comparisonoperator -> AND .)
    LBRACE          reduce using rule 85 (comparisonoperator -> AND .)
    LSPAREN         reduce using rule 85 (comparisonoperator -> AND .)
    IF              reduce using rule 85 (comparisonoperator -> AND .)
    WHILE           reduce using rule 85 (comparisonoperator -> AND .)
    FOR             reduce using rule 85 (comparisonoperator -> AND .)
    WITH            reduce using rule 85 (comparisonoperator -> AND .)
    PRIVATE         reduce using rule 85 (comparisonoperator -> AND .)


state 65

    (86) comparisonoperator -> OR .

    LPAREN          reduce using rule 86 (comparisonoperator -> OR .)
    NUMBER_REAL     reduce using rule 86 (comparisonoperator -> OR .)
    NUMBER_EXP      reduce using rule 86 (comparisonoperator -> OR .)
    NUMBER_HEX      reduce using rule 86 (comparisonoperator -> OR .)
    PRIVATE_ID      reduce using rule 86 (comparisonoperator -> OR .)
    GLOBAL_ID       reduce using rule 86 (comparisonoperator -> OR .)
    UNARY_FNC       reduce using rule 86 (comparisonoperator -> OR .)
    PLUS            reduce using rule 86 (comparisonoperator -> OR .)
    MINUS           reduce using rule 86 (comparisonoperator -> OR .)
    NOT             reduce using rule 86 (comparisonoperator -> OR .)
    NULAR_FNC       reduce using rule 86 (comparisonoperator -> OR .)
    STRING_SINGLE   reduce using rule 86 (comparisonoperator -> OR .)
    STRING_DOUBLE   reduce using rule 86 (comparisonoperator -> OR .)
    LBRACE          reduce using rule 86 (comparisonoperator -> OR .)
    LSPAREN         reduce using rule 86 (comparisonoperator -> OR .)
    IF              reduce using rule 86 (comparisonoperator -> OR .)
    WHILE           reduce using rule 86 (comparisonoperator -> OR .)
    FOR             reduce using rule 86 (comparisonoperator -> OR .)
    WITH            reduce using rule 86 (comparisonoperator -> OR .)
    PRIVATE         reduce using rule 86 (comparisonoperator -> OR .)


state 66

    (87) mathoperator -> PLUS .

    LPAREN          reduce using rule 87 (mathoperator -> PLUS .)
    NUMBER_REAL     reduce using rule 87 (mathoperator -> PLUS .)
    NUMBER_EXP      reduce using rule 87 (mathoperator -> PLUS .)
    NUMBER_HEX      reduce using rule 87 (mathoperator -> PLUS .)
    PRIVATE_ID      reduce using rule 87 (mathoperator -> PLUS .)
    GLOBAL_ID       reduce using rule 87 (mathoperator -> PLUS .)
    UNARY_FNC       reduce using rule 87 (mathoperator -> PLUS .)
    PLUS            reduce using rule 87 (mathoperator -> PLUS .)
    MINUS           reduce using rule 87 (mathoperator -> PLUS .)
    NOT             reduce using rule 87 (mathoperator -> PLUS .)
    NULAR_FNC       reduce using rule 87 (mathoperator -> PLUS .)
    STRING_SINGLE   reduce using rule 87 (mathoperator -> PLUS .)
    STRING_DOUBLE   reduce using rule 87 (mathoperator -> PLUS .)
    LBRACE          reduce using rule 87 (mathoperator -> PLUS .)
    LSPAREN         reduce using rule 87 (mathoperator -> PLUS .)
    IF              reduce using rule 87 (mathoperator -> PLUS .)
    WHILE           reduce using rule 87 (mathoperator -> PLUS .)
    FOR             reduce using rule 87 (mathoperator -> PLUS .)
    WITH            reduce using rule 87 (mathoperator -> PLUS .)
    PRIVATE         reduce using rule 87 (mathoperator -> PLUS .)


state 67

    (88) mathoperator -> MINUS .

    LPAREN          reduce using rule 88 (mathoperator -> MINUS .)
    NUMBER_REAL     reduce using rule 88 (mathoperator -> MINUS .)
    NUMBER_EXP      reduce using rule 88 (mathoperator -> MINUS .)
    NUMBER_HEX      reduce using rule 88 (mathoperator -> MINUS .)
    PRIVATE_ID      reduce using rule 88 (mathoperator -> MINUS .)
    GLOBAL_ID       reduce using rule 88 (mathoperator -> MINUS .)
    UNARY_FNC       reduce using rule 88 (mathoperator -> MINUS .)
    PLUS            reduce using rule 88 (mathoperator -> MINUS .)
    MINUS           reduce using rule 88 (mathoperator -> MINUS .)
    NOT             reduce using rule 88 (mathoperator -> MINUS .)
    NULAR_FNC       reduce using rule 88 (mathoperator -> MINUS .)
    STRING_SINGLE   reduce using rule 88 (mathoperator -> MINUS .)
    STRING_DOUBLE   reduce using rule 88 (mathoperator -> MINUS .)
    LBRACE          reduce using rule 88 (mathoperator -> MINUS .)
    LSPAREN         reduce using rule 88 (mathoperator -> MINUS .)
    IF              reduce using rule 88 (mathoperator -> MINUS .)
    WHILE           reduce using rule 88 (mathoperator -> MINUS .)
    FOR             reduce using rule 88 (mathoperator -> MINUS .)
    WITH            reduce using rule 88 (mathoperator -> MINUS .)
    PRIVATE         reduce using rule 88 (mathoperator -> MINUS .)


state 68

    (89) mathoperator -> TIMES .

    LPAREN          reduce using rule 89 (mathoperator -> TIMES .)
    NUMBER_REAL     reduce using rule 89 (mathoperator -> TIMES .)
    NUMBER_EXP      reduce using rule 89 (mathoperator -> TIMES .)
    NUMBER_HEX      reduce using rule 89 (mathoperator -> TIMES .)
    PRIVATE_ID      reduce using rule 89 (mathoperator -> TIMES .)
    GLOBAL_ID       reduce using rule 89 (mathoperator -> TIMES .)
    UNARY_FNC       reduce using rule 89 (mathoperator -> TIMES .)
    PLUS            reduce using rule 89 (mathoperator -> TIMES .)
    MINUS           reduce using rule 89 (mathoperator -> TIMES .)
    NOT             reduce using rule 89 (mathoperator -> TIMES .)
    NULAR_FNC       reduce using rule 89 (mathoperator -> TIMES .)
    STRING_SINGLE   reduce using rule 89 (mathoperator -> TIMES .)
    STRING_DOUBLE   reduce using rule 89 (mathoperator -> TIMES .)
    LBRACE          reduce using rule 89 (mathoperator -> TIMES .)
    LSPAREN         reduce using rule 89 (mathoperator -> TIMES .)
    IF              reduce using rule 89 (mathoperator -> TIMES .)
    WHILE           reduce using rule 89 (mathoperator -> TIMES .)
    FOR             reduce using rule 89 (mathoperator -> TIMES .)
    WITH            reduce using rule 89 (mathoperator -> TIMES .)
    PRIVATE         reduce using rule 89 (mathoperator -> TIMES .)


state 69

    (90) mathoperator -> DIVIDE .

    LPAREN          reduce using rule 90 (mathoperator -> DIVIDE .)
    NUMBER_REAL     reduce using rule 90 (mathoperator -> DIVIDE .)
    NUMBER_EXP      reduce using rule 90 (mathoperator -> DIVIDE .)
    NUMBER_HEX      reduce using rule 90 (mathoperator -> DIVIDE .)
    PRIVATE_ID      reduce using rule 90 (mathoperator -> DIVIDE .)
    GLOBAL_ID       reduce using rule 90 (mathoperator -> DIVIDE .)
    UNARY_FNC       reduce using rule 90 (mathoperator -> DIVIDE .)
    PLUS            reduce using rule 90 (mathoperator -> DIVIDE .)
    MINUS           reduce using rule 90 (mathoperator -> DIVIDE .)
    NOT             reduce using rule 90 (mathoperator -> DIVIDE .)
    NULAR_FNC       reduce using rule 90 (mathoperator -> DIVIDE .)
    STRING_SINGLE   reduce using rule 90 (mathoperator -> DIVIDE .)
    STRING_DOUBLE   reduce using rule 90 (mathoperator -> DIVIDE .)
    LBRACE          reduce using rule 90 (mathoperator -> DIVIDE .)
    LSPAREN         reduce using rule 90 (mathoperator -> DIVIDE .)
    IF              reduce using rule 90 (mathoperator -> DIVIDE .)
    WHILE           reduce using rule 90 (mathoperator -> DIVIDE .)
    FOR             reduce using rule 90 (mathoperator -> DIVIDE .)
    WITH            reduce using rule 90 (mathoperator -> DIVIDE .)
    PRIVATE         reduce using rule 90 (mathoperator -> DIVIDE .)


state 70

    (91) mathoperator -> MOD .

    LPAREN          reduce using rule 91 (mathoperator -> MOD .)
    NUMBER_REAL     reduce using rule 91 (mathoperator -> MOD .)
    NUMBER_EXP      reduce using rule 91 (mathoperator -> MOD .)
    NUMBER_HEX      reduce using rule 91 (mathoperator -> MOD .)
    PRIVATE_ID      reduce using rule 91 (mathoperator -> MOD .)
    GLOBAL_ID       reduce using rule 91 (mathoperator -> MOD .)
    UNARY_FNC       reduce using rule 91 (mathoperator -> MOD .)
    PLUS            reduce using rule 91 (mathoperator -> MOD .)
    MINUS           reduce using rule 91 (mathoperator -> MOD .)
    NOT             reduce using rule 91 (mathoperator -> MOD .)
    NULAR_FNC       reduce using rule 91 (mathoperator -> MOD .)
    STRING_SINGLE   reduce using rule 91 (mathoperator -> MOD .)
    STRING_DOUBLE   reduce using rule 91 (mathoperator -> MOD .)
    LBRACE          reduce using rule 91 (mathoperator -> MOD .)
    LSPAREN         reduce using rule 91 (mathoperator -> MOD .)
    IF              reduce using rule 91 (mathoperator -> MOD .)
    WHILE           reduce using rule 91 (mathoperator -> MOD .)
    FOR             reduce using rule 91 (mathoperator -> MOD .)
    WITH            reduce using rule 91 (mathoperator -> MOD .)
    PRIVATE         reduce using rule 91 (mathoperator -> MOD .)


state 71

    (92) mathoperator -> POW .

    LPAREN          reduce using rule 92 (mathoperator -> POW .)
    NUMBER_REAL     reduce using rule 92 (mathoperator -> POW .)
    NUMBER_EXP      reduce using rule 92 (mathoperator -> POW .)
    NUMBER_HEX      reduce using rule 92 (mathoperator -> POW .)
    PRIVATE_ID      reduce using rule 92 (mathoperator -> POW .)
    GLOBAL_ID       reduce using rule 92 (mathoperator -> POW .)
    UNARY_FNC       reduce using rule 92 (mathoperator -> POW .)
    PLUS            reduce using rule 92 (mathoperator -> POW .)
    MINUS           reduce using rule 92 (mathoperator -> POW .)
    NOT             reduce using rule 92 (mathoperator -> POW .)
    NULAR_FNC       reduce using rule 92 (mathoperator -> POW .)
    STRING_SINGLE   reduce using rule 92 (mathoperator -> POW .)
    STRING_DOUBLE   reduce using rule 92 (mathoperator -> POW .)
    LBRACE          reduce using rule 92 (mathoperator -> POW .)
    LSPAREN         reduce using rule 92 (mathoperator -> POW .)
    IF              reduce using rule 92 (mathoperator -> POW .)
    WHILE           reduce using rule 92 (mathoperator -> POW .)
    FOR             reduce using rule 92 (mathoperator -> POW .)
    WITH            reduce using rule 92 (mathoperator -> POW .)
    PRIVATE         reduce using rule 92 (mathoperator -> POW .)


state 72

    (39) assignment -> variable EQUAL . primaryexp
    (41) assignment_code -> variable EQUAL . LBRACE
    (52) primaryexp -> . number
    (53) primaryexp -> . identifier
    (54) primaryexp -> . helpertype
    (55) primaryexp -> . unaryexp
    (56) primaryexp -> . nularexp
    (57) primaryexp -> . string
    (58) primaryexp -> . binaryexp
    (59) primaryexp -> . bracedexp
    (60) primaryexp -> . LPAREN binaryexp RPAREN
    (61) primaryexp -> . array
    (98) number -> . NUMBER_REAL
    (99) number -> . NUMBER_EXP
    (100) number -> . NUMBER_HEX
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (74) unaryexp -> . UNARY_FNC primaryexp
    (75) unaryexp -> . PLUS primaryexp
    (76) unaryexp -> . MINUS primaryexp
    (77) unaryexp -> . NOT primaryexp
    (78) unaryexp -> . vardefinition
    (72) nularexp -> . NULAR_FNC
    (73) nularexp -> . identifier
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE
    (49) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (50) binaryexp -> . primaryexp comparisonoperator primaryexp
    (51) binaryexp -> . primaryexp mathoperator primaryexp
    (62) bracedexp -> . LBRACE new_scope code RBRACE
    (64) array -> . LSPAREN RSPAREN
    (65) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF forloop_condition
    (26) whiletype -> . WHILE forloop_condition
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (35) vardefinition -> . definition
    (36) vardefinition -> . arraydefinition
    (43) definition -> . PRIVATE PRIVATE_ID
    (44) definition -> . PRIVATE string
    (42) arraydefinition -> . PRIVATE stringarray

    LBRACE          shift and go to state 117
    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 44
    NUMBER_EXP      shift and go to state 45
    NUMBER_HEX      shift and go to state 46
    PRIVATE_ID      shift and go to state 78
    GLOBAL_ID       shift and go to state 79
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48
    LSPAREN         shift and go to state 42
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    WITH            shift and go to state 49
    PRIVATE         shift and go to state 30

    primaryexp                     shift and go to state 116
    number                         shift and go to state 34
    identifier                     shift and go to state 74
    helpertype                     shift and go to state 35
    unaryexp                       shift and go to state 75
    nularexp                       shift and go to state 76
    string                         shift and go to state 32
    binaryexp                      shift and go to state 77
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 80
    whiletype                      shift and go to state 81
    fortype                        shift and go to state 82
    withtype                       shift and go to state 83
    vardefinition                  shift and go to state 23
    definition                     shift and go to state 84
    arraydefinition                shift and go to state 38

state 73

    (74) unaryexp -> UNARY_FNC primaryexp .
    (49) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (50) binaryexp -> primaryexp . comparisonoperator primaryexp
    (51) binaryexp -> primaryexp . mathoperator primaryexp
    (79) comparisonoperator -> . LT
    (80) comparisonoperator -> . GT
    (81) comparisonoperator -> . LTE
    (82) comparisonoperator -> . GTE
    (83) comparisonoperator -> . EQUALITY
    (84) comparisonoperator -> . INEQUALITY
    (85) comparisonoperator -> . AND
    (86) comparisonoperator -> . OR
    (87) mathoperator -> . PLUS
    (88) mathoperator -> . MINUS
    (89) mathoperator -> . TIMES
    (90) mathoperator -> . DIVIDE
    (91) mathoperator -> . MOD
    (92) mathoperator -> . POW

    SEMI_COLON      reduce using rule 74 (unaryexp -> UNARY_FNC primaryexp .)
    COMMA           reduce using rule 74 (unaryexp -> UNARY_FNC primaryexp .)
    $end            reduce using rule 74 (unaryexp -> UNARY_FNC primaryexp .)
    BINARY_FNC      reduce using rule 74 (unaryexp -> UNARY_FNC primaryexp .)
    LT              reduce using rule 74 (unaryexp -> UNARY_FNC primaryexp .)
    GT              reduce using rule 74 (unaryexp -> UNARY_FNC primaryexp .)
    LTE             reduce using rule 74 (unaryexp -> UNARY_FNC primaryexp .)
    GTE             reduce using rule 74 (unaryexp -> UNARY_FNC primaryexp .)
    EQUALITY        reduce using rule 74 (unaryexp -> UNARY_FNC primaryexp .)
    INEQUALITY      reduce using rule 74 (unaryexp -> UNARY_FNC primaryexp .)
    AND             reduce using rule 74 (unaryexp -> UNARY_FNC primaryexp .)
    OR              reduce using rule 74 (unaryexp -> UNARY_FNC primaryexp .)
    PLUS            reduce using rule 74 (unaryexp -> UNARY_FNC primaryexp .)
    MINUS           reduce using rule 74 (unaryexp -> UNARY_FNC primaryexp .)
    TIMES           reduce using rule 74 (unaryexp -> UNARY_FNC primaryexp .)
    DIVIDE          reduce using rule 74 (unaryexp -> UNARY_FNC primaryexp .)
    MOD             reduce using rule 74 (unaryexp -> UNARY_FNC primaryexp .)
    POW             reduce using rule 74 (unaryexp -> UNARY_FNC primaryexp .)
    RBRACE          reduce using rule 74 (unaryexp -> UNARY_FNC primaryexp .)
    RPAREN          reduce using rule 74 (unaryexp -> UNARY_FNC primaryexp .)
    RSPAREN         reduce using rule 74 (unaryexp -> UNARY_FNC primaryexp .)
    TO              reduce using rule 74 (unaryexp -> UNARY_FNC primaryexp .)
    STEP            reduce using rule 74 (unaryexp -> UNARY_FNC primaryexp .)
    DO              reduce using rule 74 (unaryexp -> UNARY_FNC primaryexp .)

  ! BINARY_FNC      [ shift and go to state 55 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! LTE             [ shift and go to state 60 ]
  ! GTE             [ shift and go to state 61 ]
  ! EQUALITY        [ shift and go to state 62 ]
  ! INEQUALITY      [ shift and go to state 63 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 65 ]
  ! PLUS            [ shift and go to state 66 ]
  ! MINUS           [ shift and go to state 67 ]
  ! TIMES           [ shift and go to state 68 ]
  ! DIVIDE          [ shift and go to state 69 ]
  ! MOD             [ shift and go to state 70 ]
  ! POW             [ shift and go to state 71 ]

    comparisonoperator             shift and go to state 56
    mathoperator                   shift and go to state 57

state 74

    (53) primaryexp -> identifier .
    (73) nularexp -> identifier .

  ! reduce/reduce conflict for BINARY_FNC resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for LT resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for GT resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for LTE resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for GTE resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for EQUALITY resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for INEQUALITY resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for AND resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for OR resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for PLUS resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for MINUS resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for TIMES resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for MOD resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for POW resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for SEMI_COLON resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for COMMA resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for $end resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for RBRACE resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for RPAREN resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for RSPAREN resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for TO resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for STEP resolved using rule 53 (primaryexp -> identifier .)
  ! reduce/reduce conflict for DO resolved using rule 53 (primaryexp -> identifier .)
    BINARY_FNC      reduce using rule 53 (primaryexp -> identifier .)
    LT              reduce using rule 53 (primaryexp -> identifier .)
    GT              reduce using rule 53 (primaryexp -> identifier .)
    LTE             reduce using rule 53 (primaryexp -> identifier .)
    GTE             reduce using rule 53 (primaryexp -> identifier .)
    EQUALITY        reduce using rule 53 (primaryexp -> identifier .)
    INEQUALITY      reduce using rule 53 (primaryexp -> identifier .)
    AND             reduce using rule 53 (primaryexp -> identifier .)
    OR              reduce using rule 53 (primaryexp -> identifier .)
    PLUS            reduce using rule 53 (primaryexp -> identifier .)
    MINUS           reduce using rule 53 (primaryexp -> identifier .)
    TIMES           reduce using rule 53 (primaryexp -> identifier .)
    DIVIDE          reduce using rule 53 (primaryexp -> identifier .)
    MOD             reduce using rule 53 (primaryexp -> identifier .)
    POW             reduce using rule 53 (primaryexp -> identifier .)
    SEMI_COLON      reduce using rule 53 (primaryexp -> identifier .)
    COMMA           reduce using rule 53 (primaryexp -> identifier .)
    $end            reduce using rule 53 (primaryexp -> identifier .)
    RBRACE          reduce using rule 53 (primaryexp -> identifier .)
    RPAREN          reduce using rule 53 (primaryexp -> identifier .)
    RSPAREN         reduce using rule 53 (primaryexp -> identifier .)
    TO              reduce using rule 53 (primaryexp -> identifier .)
    STEP            reduce using rule 53 (primaryexp -> identifier .)
    DO              reduce using rule 53 (primaryexp -> identifier .)

  ! BINARY_FNC      [ reduce using rule 73 (nularexp -> identifier .) ]
  ! LT              [ reduce using rule 73 (nularexp -> identifier .) ]
  ! GT              [ reduce using rule 73 (nularexp -> identifier .) ]
  ! LTE             [ reduce using rule 73 (nularexp -> identifier .) ]
  ! GTE             [ reduce using rule 73 (nularexp -> identifier .) ]
  ! EQUALITY        [ reduce using rule 73 (nularexp -> identifier .) ]
  ! INEQUALITY      [ reduce using rule 73 (nularexp -> identifier .) ]
  ! AND             [ reduce using rule 73 (nularexp -> identifier .) ]
  ! OR              [ reduce using rule 73 (nularexp -> identifier .) ]
  ! PLUS            [ reduce using rule 73 (nularexp -> identifier .) ]
  ! MINUS           [ reduce using rule 73 (nularexp -> identifier .) ]
  ! TIMES           [ reduce using rule 73 (nularexp -> identifier .) ]
  ! DIVIDE          [ reduce using rule 73 (nularexp -> identifier .) ]
  ! MOD             [ reduce using rule 73 (nularexp -> identifier .) ]
  ! POW             [ reduce using rule 73 (nularexp -> identifier .) ]
  ! SEMI_COLON      [ reduce using rule 73 (nularexp -> identifier .) ]
  ! COMMA           [ reduce using rule 73 (nularexp -> identifier .) ]
  ! $end            [ reduce using rule 73 (nularexp -> identifier .) ]
  ! RBRACE          [ reduce using rule 73 (nularexp -> identifier .) ]
  ! RPAREN          [ reduce using rule 73 (nularexp -> identifier .) ]
  ! RSPAREN         [ reduce using rule 73 (nularexp -> identifier .) ]
  ! TO              [ reduce using rule 73 (nularexp -> identifier .) ]
  ! STEP            [ reduce using rule 73 (nularexp -> identifier .) ]
  ! DO              [ reduce using rule 73 (nularexp -> identifier .) ]


state 75

    (55) primaryexp -> unaryexp .

    BINARY_FNC      reduce using rule 55 (primaryexp -> unaryexp .)
    LT              reduce using rule 55 (primaryexp -> unaryexp .)
    GT              reduce using rule 55 (primaryexp -> unaryexp .)
    LTE             reduce using rule 55 (primaryexp -> unaryexp .)
    GTE             reduce using rule 55 (primaryexp -> unaryexp .)
    EQUALITY        reduce using rule 55 (primaryexp -> unaryexp .)
    INEQUALITY      reduce using rule 55 (primaryexp -> unaryexp .)
    AND             reduce using rule 55 (primaryexp -> unaryexp .)
    OR              reduce using rule 55 (primaryexp -> unaryexp .)
    PLUS            reduce using rule 55 (primaryexp -> unaryexp .)
    MINUS           reduce using rule 55 (primaryexp -> unaryexp .)
    TIMES           reduce using rule 55 (primaryexp -> unaryexp .)
    DIVIDE          reduce using rule 55 (primaryexp -> unaryexp .)
    MOD             reduce using rule 55 (primaryexp -> unaryexp .)
    POW             reduce using rule 55 (primaryexp -> unaryexp .)
    SEMI_COLON      reduce using rule 55 (primaryexp -> unaryexp .)
    COMMA           reduce using rule 55 (primaryexp -> unaryexp .)
    $end            reduce using rule 55 (primaryexp -> unaryexp .)
    RBRACE          reduce using rule 55 (primaryexp -> unaryexp .)
    RPAREN          reduce using rule 55 (primaryexp -> unaryexp .)
    RSPAREN         reduce using rule 55 (primaryexp -> unaryexp .)
    TO              reduce using rule 55 (primaryexp -> unaryexp .)
    STEP            reduce using rule 55 (primaryexp -> unaryexp .)
    DO              reduce using rule 55 (primaryexp -> unaryexp .)


state 76

    (56) primaryexp -> nularexp .

    BINARY_FNC      reduce using rule 56 (primaryexp -> nularexp .)
    LT              reduce using rule 56 (primaryexp -> nularexp .)
    GT              reduce using rule 56 (primaryexp -> nularexp .)
    LTE             reduce using rule 56 (primaryexp -> nularexp .)
    GTE             reduce using rule 56 (primaryexp -> nularexp .)
    EQUALITY        reduce using rule 56 (primaryexp -> nularexp .)
    INEQUALITY      reduce using rule 56 (primaryexp -> nularexp .)
    AND             reduce using rule 56 (primaryexp -> nularexp .)
    OR              reduce using rule 56 (primaryexp -> nularexp .)
    PLUS            reduce using rule 56 (primaryexp -> nularexp .)
    MINUS           reduce using rule 56 (primaryexp -> nularexp .)
    TIMES           reduce using rule 56 (primaryexp -> nularexp .)
    DIVIDE          reduce using rule 56 (primaryexp -> nularexp .)
    MOD             reduce using rule 56 (primaryexp -> nularexp .)
    POW             reduce using rule 56 (primaryexp -> nularexp .)
    SEMI_COLON      reduce using rule 56 (primaryexp -> nularexp .)
    COMMA           reduce using rule 56 (primaryexp -> nularexp .)
    $end            reduce using rule 56 (primaryexp -> nularexp .)
    RBRACE          reduce using rule 56 (primaryexp -> nularexp .)
    RPAREN          reduce using rule 56 (primaryexp -> nularexp .)
    RSPAREN         reduce using rule 56 (primaryexp -> nularexp .)
    TO              reduce using rule 56 (primaryexp -> nularexp .)
    STEP            reduce using rule 56 (primaryexp -> nularexp .)
    DO              reduce using rule 56 (primaryexp -> nularexp .)


state 77

    (58) primaryexp -> binaryexp .

    BINARY_FNC      reduce using rule 58 (primaryexp -> binaryexp .)
    LT              reduce using rule 58 (primaryexp -> binaryexp .)
    GT              reduce using rule 58 (primaryexp -> binaryexp .)
    LTE             reduce using rule 58 (primaryexp -> binaryexp .)
    GTE             reduce using rule 58 (primaryexp -> binaryexp .)
    EQUALITY        reduce using rule 58 (primaryexp -> binaryexp .)
    INEQUALITY      reduce using rule 58 (primaryexp -> binaryexp .)
    AND             reduce using rule 58 (primaryexp -> binaryexp .)
    OR              reduce using rule 58 (primaryexp -> binaryexp .)
    PLUS            reduce using rule 58 (primaryexp -> binaryexp .)
    MINUS           reduce using rule 58 (primaryexp -> binaryexp .)
    TIMES           reduce using rule 58 (primaryexp -> binaryexp .)
    DIVIDE          reduce using rule 58 (primaryexp -> binaryexp .)
    MOD             reduce using rule 58 (primaryexp -> binaryexp .)
    POW             reduce using rule 58 (primaryexp -> binaryexp .)
    SEMI_COLON      reduce using rule 58 (primaryexp -> binaryexp .)
    COMMA           reduce using rule 58 (primaryexp -> binaryexp .)
    $end            reduce using rule 58 (primaryexp -> binaryexp .)
    RBRACE          reduce using rule 58 (primaryexp -> binaryexp .)
    RPAREN          reduce using rule 58 (primaryexp -> binaryexp .)
    RSPAREN         reduce using rule 58 (primaryexp -> binaryexp .)
    TO              reduce using rule 58 (primaryexp -> binaryexp .)
    STEP            reduce using rule 58 (primaryexp -> binaryexp .)
    DO              reduce using rule 58 (primaryexp -> binaryexp .)


state 78

    (45) identifier -> PRIVATE_ID .

    BINARY_FNC      reduce using rule 45 (identifier -> PRIVATE_ID .)
    LT              reduce using rule 45 (identifier -> PRIVATE_ID .)
    GT              reduce using rule 45 (identifier -> PRIVATE_ID .)
    LTE             reduce using rule 45 (identifier -> PRIVATE_ID .)
    GTE             reduce using rule 45 (identifier -> PRIVATE_ID .)
    EQUALITY        reduce using rule 45 (identifier -> PRIVATE_ID .)
    INEQUALITY      reduce using rule 45 (identifier -> PRIVATE_ID .)
    AND             reduce using rule 45 (identifier -> PRIVATE_ID .)
    OR              reduce using rule 45 (identifier -> PRIVATE_ID .)
    PLUS            reduce using rule 45 (identifier -> PRIVATE_ID .)
    MINUS           reduce using rule 45 (identifier -> PRIVATE_ID .)
    TIMES           reduce using rule 45 (identifier -> PRIVATE_ID .)
    DIVIDE          reduce using rule 45 (identifier -> PRIVATE_ID .)
    MOD             reduce using rule 45 (identifier -> PRIVATE_ID .)
    POW             reduce using rule 45 (identifier -> PRIVATE_ID .)
    SEMI_COLON      reduce using rule 45 (identifier -> PRIVATE_ID .)
    COMMA           reduce using rule 45 (identifier -> PRIVATE_ID .)
    $end            reduce using rule 45 (identifier -> PRIVATE_ID .)
    RBRACE          reduce using rule 45 (identifier -> PRIVATE_ID .)
    RPAREN          reduce using rule 45 (identifier -> PRIVATE_ID .)
    RSPAREN         reduce using rule 45 (identifier -> PRIVATE_ID .)
    TO              reduce using rule 45 (identifier -> PRIVATE_ID .)
    STEP            reduce using rule 45 (identifier -> PRIVATE_ID .)
    DO              reduce using rule 45 (identifier -> PRIVATE_ID .)
    THEN            reduce using rule 45 (identifier -> PRIVATE_ID .)
    EXITWITH        reduce using rule 45 (identifier -> PRIVATE_ID .)


state 79

    (46) identifier -> GLOBAL_ID .

    BINARY_FNC      reduce using rule 46 (identifier -> GLOBAL_ID .)
    LT              reduce using rule 46 (identifier -> GLOBAL_ID .)
    GT              reduce using rule 46 (identifier -> GLOBAL_ID .)
    LTE             reduce using rule 46 (identifier -> GLOBAL_ID .)
    GTE             reduce using rule 46 (identifier -> GLOBAL_ID .)
    EQUALITY        reduce using rule 46 (identifier -> GLOBAL_ID .)
    INEQUALITY      reduce using rule 46 (identifier -> GLOBAL_ID .)
    AND             reduce using rule 46 (identifier -> GLOBAL_ID .)
    OR              reduce using rule 46 (identifier -> GLOBAL_ID .)
    PLUS            reduce using rule 46 (identifier -> GLOBAL_ID .)
    MINUS           reduce using rule 46 (identifier -> GLOBAL_ID .)
    TIMES           reduce using rule 46 (identifier -> GLOBAL_ID .)
    DIVIDE          reduce using rule 46 (identifier -> GLOBAL_ID .)
    MOD             reduce using rule 46 (identifier -> GLOBAL_ID .)
    POW             reduce using rule 46 (identifier -> GLOBAL_ID .)
    SEMI_COLON      reduce using rule 46 (identifier -> GLOBAL_ID .)
    COMMA           reduce using rule 46 (identifier -> GLOBAL_ID .)
    $end            reduce using rule 46 (identifier -> GLOBAL_ID .)
    RBRACE          reduce using rule 46 (identifier -> GLOBAL_ID .)
    RPAREN          reduce using rule 46 (identifier -> GLOBAL_ID .)
    RSPAREN         reduce using rule 46 (identifier -> GLOBAL_ID .)
    TO              reduce using rule 46 (identifier -> GLOBAL_ID .)
    STEP            reduce using rule 46 (identifier -> GLOBAL_ID .)
    DO              reduce using rule 46 (identifier -> GLOBAL_ID .)
    THEN            reduce using rule 46 (identifier -> GLOBAL_ID .)
    EXITWITH        reduce using rule 46 (identifier -> GLOBAL_ID .)


state 80

    (15) helpertype -> iftype .

    BINARY_FNC      reduce using rule 15 (helpertype -> iftype .)
    LT              reduce using rule 15 (helpertype -> iftype .)
    GT              reduce using rule 15 (helpertype -> iftype .)
    LTE             reduce using rule 15 (helpertype -> iftype .)
    GTE             reduce using rule 15 (helpertype -> iftype .)
    EQUALITY        reduce using rule 15 (helpertype -> iftype .)
    INEQUALITY      reduce using rule 15 (helpertype -> iftype .)
    AND             reduce using rule 15 (helpertype -> iftype .)
    OR              reduce using rule 15 (helpertype -> iftype .)
    PLUS            reduce using rule 15 (helpertype -> iftype .)
    MINUS           reduce using rule 15 (helpertype -> iftype .)
    TIMES           reduce using rule 15 (helpertype -> iftype .)
    DIVIDE          reduce using rule 15 (helpertype -> iftype .)
    MOD             reduce using rule 15 (helpertype -> iftype .)
    POW             reduce using rule 15 (helpertype -> iftype .)
    SEMI_COLON      reduce using rule 15 (helpertype -> iftype .)
    COMMA           reduce using rule 15 (helpertype -> iftype .)
    $end            reduce using rule 15 (helpertype -> iftype .)
    RBRACE          reduce using rule 15 (helpertype -> iftype .)
    RPAREN          reduce using rule 15 (helpertype -> iftype .)
    RSPAREN         reduce using rule 15 (helpertype -> iftype .)
    TO              reduce using rule 15 (helpertype -> iftype .)
    STEP            reduce using rule 15 (helpertype -> iftype .)
    DO              reduce using rule 15 (helpertype -> iftype .)


state 81

    (16) helpertype -> whiletype .

    BINARY_FNC      reduce using rule 16 (helpertype -> whiletype .)
    LT              reduce using rule 16 (helpertype -> whiletype .)
    GT              reduce using rule 16 (helpertype -> whiletype .)
    LTE             reduce using rule 16 (helpertype -> whiletype .)
    GTE             reduce using rule 16 (helpertype -> whiletype .)
    EQUALITY        reduce using rule 16 (helpertype -> whiletype .)
    INEQUALITY      reduce using rule 16 (helpertype -> whiletype .)
    AND             reduce using rule 16 (helpertype -> whiletype .)
    OR              reduce using rule 16 (helpertype -> whiletype .)
    PLUS            reduce using rule 16 (helpertype -> whiletype .)
    MINUS           reduce using rule 16 (helpertype -> whiletype .)
    TIMES           reduce using rule 16 (helpertype -> whiletype .)
    DIVIDE          reduce using rule 16 (helpertype -> whiletype .)
    MOD             reduce using rule 16 (helpertype -> whiletype .)
    POW             reduce using rule 16 (helpertype -> whiletype .)
    SEMI_COLON      reduce using rule 16 (helpertype -> whiletype .)
    COMMA           reduce using rule 16 (helpertype -> whiletype .)
    $end            reduce using rule 16 (helpertype -> whiletype .)
    RBRACE          reduce using rule 16 (helpertype -> whiletype .)
    RPAREN          reduce using rule 16 (helpertype -> whiletype .)
    RSPAREN         reduce using rule 16 (helpertype -> whiletype .)
    TO              reduce using rule 16 (helpertype -> whiletype .)
    STEP            reduce using rule 16 (helpertype -> whiletype .)
    DO              reduce using rule 16 (helpertype -> whiletype .)


state 82

    (17) helpertype -> fortype .

    BINARY_FNC      reduce using rule 17 (helpertype -> fortype .)
    LT              reduce using rule 17 (helpertype -> fortype .)
    GT              reduce using rule 17 (helpertype -> fortype .)
    LTE             reduce using rule 17 (helpertype -> fortype .)
    GTE             reduce using rule 17 (helpertype -> fortype .)
    EQUALITY        reduce using rule 17 (helpertype -> fortype .)
    INEQUALITY      reduce using rule 17 (helpertype -> fortype .)
    AND             reduce using rule 17 (helpertype -> fortype .)
    OR              reduce using rule 17 (helpertype -> fortype .)
    PLUS            reduce using rule 17 (helpertype -> fortype .)
    MINUS           reduce using rule 17 (helpertype -> fortype .)
    TIMES           reduce using rule 17 (helpertype -> fortype .)
    DIVIDE          reduce using rule 17 (helpertype -> fortype .)
    MOD             reduce using rule 17 (helpertype -> fortype .)
    POW             reduce using rule 17 (helpertype -> fortype .)
    SEMI_COLON      reduce using rule 17 (helpertype -> fortype .)
    COMMA           reduce using rule 17 (helpertype -> fortype .)
    $end            reduce using rule 17 (helpertype -> fortype .)
    RBRACE          reduce using rule 17 (helpertype -> fortype .)
    RPAREN          reduce using rule 17 (helpertype -> fortype .)
    RSPAREN         reduce using rule 17 (helpertype -> fortype .)
    TO              reduce using rule 17 (helpertype -> fortype .)
    STEP            reduce using rule 17 (helpertype -> fortype .)
    DO              reduce using rule 17 (helpertype -> fortype .)


state 83

    (18) helpertype -> withtype .

    BINARY_FNC      reduce using rule 18 (helpertype -> withtype .)
    LT              reduce using rule 18 (helpertype -> withtype .)
    GT              reduce using rule 18 (helpertype -> withtype .)
    LTE             reduce using rule 18 (helpertype -> withtype .)
    GTE             reduce using rule 18 (helpertype -> withtype .)
    EQUALITY        reduce using rule 18 (helpertype -> withtype .)
    INEQUALITY      reduce using rule 18 (helpertype -> withtype .)
    AND             reduce using rule 18 (helpertype -> withtype .)
    OR              reduce using rule 18 (helpertype -> withtype .)
    PLUS            reduce using rule 18 (helpertype -> withtype .)
    MINUS           reduce using rule 18 (helpertype -> withtype .)
    TIMES           reduce using rule 18 (helpertype -> withtype .)
    DIVIDE          reduce using rule 18 (helpertype -> withtype .)
    MOD             reduce using rule 18 (helpertype -> withtype .)
    POW             reduce using rule 18 (helpertype -> withtype .)
    SEMI_COLON      reduce using rule 18 (helpertype -> withtype .)
    COMMA           reduce using rule 18 (helpertype -> withtype .)
    $end            reduce using rule 18 (helpertype -> withtype .)
    RBRACE          reduce using rule 18 (helpertype -> withtype .)
    RPAREN          reduce using rule 18 (helpertype -> withtype .)
    RSPAREN         reduce using rule 18 (helpertype -> withtype .)
    TO              reduce using rule 18 (helpertype -> withtype .)
    STEP            reduce using rule 18 (helpertype -> withtype .)
    DO              reduce using rule 18 (helpertype -> withtype .)


state 84

    (35) vardefinition -> definition .

    BINARY_FNC      reduce using rule 35 (vardefinition -> definition .)
    LT              reduce using rule 35 (vardefinition -> definition .)
    GT              reduce using rule 35 (vardefinition -> definition .)
    LTE             reduce using rule 35 (vardefinition -> definition .)
    GTE             reduce using rule 35 (vardefinition -> definition .)
    EQUALITY        reduce using rule 35 (vardefinition -> definition .)
    INEQUALITY      reduce using rule 35 (vardefinition -> definition .)
    AND             reduce using rule 35 (vardefinition -> definition .)
    OR              reduce using rule 35 (vardefinition -> definition .)
    PLUS            reduce using rule 35 (vardefinition -> definition .)
    MINUS           reduce using rule 35 (vardefinition -> definition .)
    TIMES           reduce using rule 35 (vardefinition -> definition .)
    DIVIDE          reduce using rule 35 (vardefinition -> definition .)
    MOD             reduce using rule 35 (vardefinition -> definition .)
    POW             reduce using rule 35 (vardefinition -> definition .)
    SEMI_COLON      reduce using rule 35 (vardefinition -> definition .)
    COMMA           reduce using rule 35 (vardefinition -> definition .)
    $end            reduce using rule 35 (vardefinition -> definition .)
    RBRACE          reduce using rule 35 (vardefinition -> definition .)
    RPAREN          reduce using rule 35 (vardefinition -> definition .)
    RSPAREN         reduce using rule 35 (vardefinition -> definition .)
    TO              reduce using rule 35 (vardefinition -> definition .)
    STEP            reduce using rule 35 (vardefinition -> definition .)
    DO              reduce using rule 35 (vardefinition -> definition .)


state 85

    (75) unaryexp -> PLUS primaryexp .
    (49) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (50) binaryexp -> primaryexp . comparisonoperator primaryexp
    (51) binaryexp -> primaryexp . mathoperator primaryexp
    (79) comparisonoperator -> . LT
    (80) comparisonoperator -> . GT
    (81) comparisonoperator -> . LTE
    (82) comparisonoperator -> . GTE
    (83) comparisonoperator -> . EQUALITY
    (84) comparisonoperator -> . INEQUALITY
    (85) comparisonoperator -> . AND
    (86) comparisonoperator -> . OR
    (87) mathoperator -> . PLUS
    (88) mathoperator -> . MINUS
    (89) mathoperator -> . TIMES
    (90) mathoperator -> . DIVIDE
    (91) mathoperator -> . MOD
    (92) mathoperator -> . POW

    SEMI_COLON      reduce using rule 75 (unaryexp -> PLUS primaryexp .)
    COMMA           reduce using rule 75 (unaryexp -> PLUS primaryexp .)
    $end            reduce using rule 75 (unaryexp -> PLUS primaryexp .)
    BINARY_FNC      reduce using rule 75 (unaryexp -> PLUS primaryexp .)
    LT              reduce using rule 75 (unaryexp -> PLUS primaryexp .)
    GT              reduce using rule 75 (unaryexp -> PLUS primaryexp .)
    LTE             reduce using rule 75 (unaryexp -> PLUS primaryexp .)
    GTE             reduce using rule 75 (unaryexp -> PLUS primaryexp .)
    EQUALITY        reduce using rule 75 (unaryexp -> PLUS primaryexp .)
    INEQUALITY      reduce using rule 75 (unaryexp -> PLUS primaryexp .)
    AND             reduce using rule 75 (unaryexp -> PLUS primaryexp .)
    OR              reduce using rule 75 (unaryexp -> PLUS primaryexp .)
    PLUS            reduce using rule 75 (unaryexp -> PLUS primaryexp .)
    MINUS           reduce using rule 75 (unaryexp -> PLUS primaryexp .)
    TIMES           reduce using rule 75 (unaryexp -> PLUS primaryexp .)
    DIVIDE          reduce using rule 75 (unaryexp -> PLUS primaryexp .)
    MOD             reduce using rule 75 (unaryexp -> PLUS primaryexp .)
    POW             reduce using rule 75 (unaryexp -> PLUS primaryexp .)
    RBRACE          reduce using rule 75 (unaryexp -> PLUS primaryexp .)
    RPAREN          reduce using rule 75 (unaryexp -> PLUS primaryexp .)
    RSPAREN         reduce using rule 75 (unaryexp -> PLUS primaryexp .)
    TO              reduce using rule 75 (unaryexp -> PLUS primaryexp .)
    STEP            reduce using rule 75 (unaryexp -> PLUS primaryexp .)
    DO              reduce using rule 75 (unaryexp -> PLUS primaryexp .)

  ! BINARY_FNC      [ shift and go to state 55 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! LTE             [ shift and go to state 60 ]
  ! GTE             [ shift and go to state 61 ]
  ! EQUALITY        [ shift and go to state 62 ]
  ! INEQUALITY      [ shift and go to state 63 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 65 ]
  ! PLUS            [ shift and go to state 66 ]
  ! MINUS           [ shift and go to state 67 ]
  ! TIMES           [ shift and go to state 68 ]
  ! DIVIDE          [ shift and go to state 69 ]
  ! MOD             [ shift and go to state 70 ]
  ! POW             [ shift and go to state 71 ]

    comparisonoperator             shift and go to state 56
    mathoperator                   shift and go to state 57

state 86

    (76) unaryexp -> MINUS primaryexp .
    (49) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (50) binaryexp -> primaryexp . comparisonoperator primaryexp
    (51) binaryexp -> primaryexp . mathoperator primaryexp
    (79) comparisonoperator -> . LT
    (80) comparisonoperator -> . GT
    (81) comparisonoperator -> . LTE
    (82) comparisonoperator -> . GTE
    (83) comparisonoperator -> . EQUALITY
    (84) comparisonoperator -> . INEQUALITY
    (85) comparisonoperator -> . AND
    (86) comparisonoperator -> . OR
    (87) mathoperator -> . PLUS
    (88) mathoperator -> . MINUS
    (89) mathoperator -> . TIMES
    (90) mathoperator -> . DIVIDE
    (91) mathoperator -> . MOD
    (92) mathoperator -> . POW

    SEMI_COLON      reduce using rule 76 (unaryexp -> MINUS primaryexp .)
    COMMA           reduce using rule 76 (unaryexp -> MINUS primaryexp .)
    $end            reduce using rule 76 (unaryexp -> MINUS primaryexp .)
    BINARY_FNC      reduce using rule 76 (unaryexp -> MINUS primaryexp .)
    LT              reduce using rule 76 (unaryexp -> MINUS primaryexp .)
    GT              reduce using rule 76 (unaryexp -> MINUS primaryexp .)
    LTE             reduce using rule 76 (unaryexp -> MINUS primaryexp .)
    GTE             reduce using rule 76 (unaryexp -> MINUS primaryexp .)
    EQUALITY        reduce using rule 76 (unaryexp -> MINUS primaryexp .)
    INEQUALITY      reduce using rule 76 (unaryexp -> MINUS primaryexp .)
    AND             reduce using rule 76 (unaryexp -> MINUS primaryexp .)
    OR              reduce using rule 76 (unaryexp -> MINUS primaryexp .)
    PLUS            reduce using rule 76 (unaryexp -> MINUS primaryexp .)
    MINUS           reduce using rule 76 (unaryexp -> MINUS primaryexp .)
    TIMES           reduce using rule 76 (unaryexp -> MINUS primaryexp .)
    DIVIDE          reduce using rule 76 (unaryexp -> MINUS primaryexp .)
    MOD             reduce using rule 76 (unaryexp -> MINUS primaryexp .)
    POW             reduce using rule 76 (unaryexp -> MINUS primaryexp .)
    RBRACE          reduce using rule 76 (unaryexp -> MINUS primaryexp .)
    RPAREN          reduce using rule 76 (unaryexp -> MINUS primaryexp .)
    RSPAREN         reduce using rule 76 (unaryexp -> MINUS primaryexp .)
    TO              reduce using rule 76 (unaryexp -> MINUS primaryexp .)
    STEP            reduce using rule 76 (unaryexp -> MINUS primaryexp .)
    DO              reduce using rule 76 (unaryexp -> MINUS primaryexp .)

  ! BINARY_FNC      [ shift and go to state 55 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! LTE             [ shift and go to state 60 ]
  ! GTE             [ shift and go to state 61 ]
  ! EQUALITY        [ shift and go to state 62 ]
  ! INEQUALITY      [ shift and go to state 63 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 65 ]
  ! PLUS            [ shift and go to state 66 ]
  ! MINUS           [ shift and go to state 67 ]
  ! TIMES           [ shift and go to state 68 ]
  ! DIVIDE          [ shift and go to state 69 ]
  ! MOD             [ shift and go to state 70 ]
  ! POW             [ shift and go to state 71 ]

    comparisonoperator             shift and go to state 56
    mathoperator                   shift and go to state 57

state 87

    (77) unaryexp -> NOT primaryexp .
    (49) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (50) binaryexp -> primaryexp . comparisonoperator primaryexp
    (51) binaryexp -> primaryexp . mathoperator primaryexp
    (79) comparisonoperator -> . LT
    (80) comparisonoperator -> . GT
    (81) comparisonoperator -> . LTE
    (82) comparisonoperator -> . GTE
    (83) comparisonoperator -> . EQUALITY
    (84) comparisonoperator -> . INEQUALITY
    (85) comparisonoperator -> . AND
    (86) comparisonoperator -> . OR
    (87) mathoperator -> . PLUS
    (88) mathoperator -> . MINUS
    (89) mathoperator -> . TIMES
    (90) mathoperator -> . DIVIDE
    (91) mathoperator -> . MOD
    (92) mathoperator -> . POW

    SEMI_COLON      reduce using rule 77 (unaryexp -> NOT primaryexp .)
    COMMA           reduce using rule 77 (unaryexp -> NOT primaryexp .)
    $end            reduce using rule 77 (unaryexp -> NOT primaryexp .)
    BINARY_FNC      reduce using rule 77 (unaryexp -> NOT primaryexp .)
    LT              reduce using rule 77 (unaryexp -> NOT primaryexp .)
    GT              reduce using rule 77 (unaryexp -> NOT primaryexp .)
    LTE             reduce using rule 77 (unaryexp -> NOT primaryexp .)
    GTE             reduce using rule 77 (unaryexp -> NOT primaryexp .)
    EQUALITY        reduce using rule 77 (unaryexp -> NOT primaryexp .)
    INEQUALITY      reduce using rule 77 (unaryexp -> NOT primaryexp .)
    AND             reduce using rule 77 (unaryexp -> NOT primaryexp .)
    OR              reduce using rule 77 (unaryexp -> NOT primaryexp .)
    PLUS            reduce using rule 77 (unaryexp -> NOT primaryexp .)
    MINUS           reduce using rule 77 (unaryexp -> NOT primaryexp .)
    TIMES           reduce using rule 77 (unaryexp -> NOT primaryexp .)
    DIVIDE          reduce using rule 77 (unaryexp -> NOT primaryexp .)
    MOD             reduce using rule 77 (unaryexp -> NOT primaryexp .)
    POW             reduce using rule 77 (unaryexp -> NOT primaryexp .)
    RBRACE          reduce using rule 77 (unaryexp -> NOT primaryexp .)
    RPAREN          reduce using rule 77 (unaryexp -> NOT primaryexp .)
    RSPAREN         reduce using rule 77 (unaryexp -> NOT primaryexp .)
    TO              reduce using rule 77 (unaryexp -> NOT primaryexp .)
    STEP            reduce using rule 77 (unaryexp -> NOT primaryexp .)
    DO              reduce using rule 77 (unaryexp -> NOT primaryexp .)

  ! BINARY_FNC      [ shift and go to state 55 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! LTE             [ shift and go to state 60 ]
  ! GTE             [ shift and go to state 61 ]
  ! EQUALITY        [ shift and go to state 62 ]
  ! INEQUALITY      [ shift and go to state 63 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 65 ]
  ! PLUS            [ shift and go to state 66 ]
  ! MINUS           [ shift and go to state 67 ]
  ! TIMES           [ shift and go to state 68 ]
  ! DIVIDE          [ shift and go to state 69 ]
  ! MOD             [ shift and go to state 70 ]
  ! POW             [ shift and go to state 71 ]

    comparisonoperator             shift and go to state 56
    mathoperator                   shift and go to state 57

state 88

    (20) ifstatement -> iftype THEN . bracedexp
    (22) ifstatement -> iftype THEN . bracedexp ELSE bracedexp
    (62) bracedexp -> . LBRACE new_scope code RBRACE

    LBRACE          shift and go to state 29

    bracedexp                      shift and go to state 118

state 89

    (21) ifstatement -> iftype EXITWITH . bracedexp
    (62) bracedexp -> . LBRACE new_scope code RBRACE

    LBRACE          shift and go to state 29

    bracedexp                      shift and go to state 119

state 90

    (27) whileloop -> whiletype DO . bracedexp
    (62) bracedexp -> . LBRACE new_scope code RBRACE

    LBRACE          shift and go to state 29

    bracedexp                      shift and go to state 120

state 91

    (31) forloop -> fortype DO . bracedexp_noscope
    (34) bracedexp_noscope -> . LBRACE code RBRACE

    LBRACE          shift and go to state 122

    bracedexp_noscope              shift and go to state 121

state 92

    (25) withstatement -> withstatementinit bracedexp .

    SEMI_COLON      reduce using rule 25 (withstatement -> withstatementinit bracedexp .)
    COMMA           reduce using rule 25 (withstatement -> withstatementinit bracedexp .)
    $end            reduce using rule 25 (withstatement -> withstatementinit bracedexp .)
    RBRACE          reduce using rule 25 (withstatement -> withstatementinit bracedexp .)


state 93

    (62) bracedexp -> LBRACE new_scope . code RBRACE
    (1) code -> . empty
    (2) code -> . statement
    (3) code -> . statement terminator code
    (103) empty -> .
    (4) statement -> . controlstructure
    (5) statement -> . assignment
    (6) statement -> . binaryexp
    (7) statement -> . nularexp
    (8) statement -> . unaryexp
    (11) controlstructure -> . ifstatement
    (12) controlstructure -> . whileloop
    (13) controlstructure -> . forloop
    (14) controlstructure -> . withstatement
    (37) assignment -> . assignment_code code RBRACE
    (38) assignment -> . definition EQUAL primaryexp
    (39) assignment -> . variable EQUAL primaryexp
    (49) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (50) binaryexp -> . primaryexp comparisonoperator primaryexp
    (51) binaryexp -> . primaryexp mathoperator primaryexp
    (72) nularexp -> . NULAR_FNC
    (73) nularexp -> . identifier
    (74) unaryexp -> . UNARY_FNC primaryexp
    (75) unaryexp -> . PLUS primaryexp
    (76) unaryexp -> . MINUS primaryexp
    (77) unaryexp -> . NOT primaryexp
    (78) unaryexp -> . vardefinition
    (20) ifstatement -> . iftype THEN bracedexp
    (21) ifstatement -> . iftype EXITWITH bracedexp
    (22) ifstatement -> . iftype THEN bracedexp ELSE bracedexp
    (27) whileloop -> . whiletype DO bracedexp
    (31) forloop -> . fortype DO bracedexp_noscope
    (25) withstatement -> . withstatementinit bracedexp
    (40) assignment_code -> . definition EQUAL LBRACE
    (41) assignment_code -> . variable EQUAL LBRACE
    (43) definition -> . PRIVATE PRIVATE_ID
    (44) definition -> . PRIVATE string
    (47) variable -> . PRIVATE_ID
    (48) variable -> . GLOBAL_ID
    (52) primaryexp -> . number
    (53) primaryexp -> . identifier
    (54) primaryexp -> . helpertype
    (55) primaryexp -> . unaryexp
    (56) primaryexp -> . nularexp
    (57) primaryexp -> . string
    (58) primaryexp -> . binaryexp
    (59) primaryexp -> . bracedexp
    (60) primaryexp -> . LPAREN binaryexp RPAREN
    (61) primaryexp -> . array
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID
    (35) vardefinition -> . definition
    (36) vardefinition -> . arraydefinition
    (19) iftype -> . IF forloop_condition
    (26) whiletype -> . WHILE forloop_condition
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (24) withstatementinit -> . withtype DO
    (98) number -> . NUMBER_REAL
    (99) number -> . NUMBER_EXP
    (100) number -> . NUMBER_HEX
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE
    (62) bracedexp -> . LBRACE new_scope code RBRACE
    (64) array -> . LSPAREN RSPAREN
    (65) array -> . LSPAREN arrayelement RSPAREN
    (42) arraydefinition -> . PRIVATE stringarray
    (23) withtype -> . WITH NAMESPACE

    RBRACE          reduce using rule 103 (empty -> .)
    NULAR_FNC       shift and go to state 17
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    PRIVATE         shift and go to state 30
    PRIVATE_ID      shift and go to state 31
    GLOBAL_ID       shift and go to state 33
    LPAREN          shift and go to state 36
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    NUMBER_REAL     shift and go to state 44
    NUMBER_EXP      shift and go to state 45
    NUMBER_HEX      shift and go to state 46
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 42
    WITH            shift and go to state 49

    code                           shift and go to state 123
    empty                          shift and go to state 2
    statement                      shift and go to state 3
    controlstructure               shift and go to state 4
    assignment                     shift and go to state 5
    binaryexp                      shift and go to state 6
    nularexp                       shift and go to state 7
    unaryexp                       shift and go to state 8
    ifstatement                    shift and go to state 9
    whileloop                      shift and go to state 10
    forloop                        shift and go to state 11
    withstatement                  shift and go to state 12
    assignment_code                shift and go to state 13
    definition                     shift and go to state 14
    primaryexp                     shift and go to state 15
    variable                       shift and go to state 16
    identifier                     shift and go to state 18
    vardefinition                  shift and go to state 23
    iftype                         shift and go to state 24
    bracedexp                      shift and go to state 25
    whiletype                      shift and go to state 26
    fortype                        shift and go to state 27
    withstatementinit              shift and go to state 28
    string                         shift and go to state 32
    number                         shift and go to state 34
    helpertype                     shift and go to state 35
    array                          shift and go to state 37
    arraydefinition                shift and go to state 38
    withtype                       shift and go to state 43

state 94

    (43) definition -> PRIVATE PRIVATE_ID .

    EQUAL           reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)
    SEMI_COLON      reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)
    COMMA           reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)
    $end            reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)
    BINARY_FNC      reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)
    LT              reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)
    GT              reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)
    LTE             reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)
    GTE             reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)
    EQUALITY        reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)
    INEQUALITY      reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)
    AND             reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)
    OR              reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)
    PLUS            reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)
    MINUS           reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)
    TIMES           reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)
    DIVIDE          reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)
    MOD             reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)
    POW             reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)
    RBRACE          reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)
    RPAREN          reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)
    RSPAREN         reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)
    TO              reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)
    STEP            reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)
    DO              reduce using rule 43 (definition -> PRIVATE PRIVATE_ID .)


state 95

    (44) definition -> PRIVATE string .

    EQUAL           reduce using rule 44 (definition -> PRIVATE string .)
    SEMI_COLON      reduce using rule 44 (definition -> PRIVATE string .)
    COMMA           reduce using rule 44 (definition -> PRIVATE string .)
    $end            reduce using rule 44 (definition -> PRIVATE string .)
    BINARY_FNC      reduce using rule 44 (definition -> PRIVATE string .)
    LT              reduce using rule 44 (definition -> PRIVATE string .)
    GT              reduce using rule 44 (definition -> PRIVATE string .)
    LTE             reduce using rule 44 (definition -> PRIVATE string .)
    GTE             reduce using rule 44 (definition -> PRIVATE string .)
    EQUALITY        reduce using rule 44 (definition -> PRIVATE string .)
    INEQUALITY      reduce using rule 44 (definition -> PRIVATE string .)
    AND             reduce using rule 44 (definition -> PRIVATE string .)
    OR              reduce using rule 44 (definition -> PRIVATE string .)
    PLUS            reduce using rule 44 (definition -> PRIVATE string .)
    MINUS           reduce using rule 44 (definition -> PRIVATE string .)
    TIMES           reduce using rule 44 (definition -> PRIVATE string .)
    DIVIDE          reduce using rule 44 (definition -> PRIVATE string .)
    MOD             reduce using rule 44 (definition -> PRIVATE string .)
    POW             reduce using rule 44 (definition -> PRIVATE string .)
    RBRACE          reduce using rule 44 (definition -> PRIVATE string .)
    RPAREN          reduce using rule 44 (definition -> PRIVATE string .)
    RSPAREN         reduce using rule 44 (definition -> PRIVATE string .)
    TO              reduce using rule 44 (definition -> PRIVATE string .)
    STEP            reduce using rule 44 (definition -> PRIVATE string .)
    DO              reduce using rule 44 (definition -> PRIVATE string .)


state 96

    (42) arraydefinition -> PRIVATE stringarray .

    SEMI_COLON      reduce using rule 42 (arraydefinition -> PRIVATE stringarray .)
    COMMA           reduce using rule 42 (arraydefinition -> PRIVATE stringarray .)
    $end            reduce using rule 42 (arraydefinition -> PRIVATE stringarray .)
    BINARY_FNC      reduce using rule 42 (arraydefinition -> PRIVATE stringarray .)
    LT              reduce using rule 42 (arraydefinition -> PRIVATE stringarray .)
    GT              reduce using rule 42 (arraydefinition -> PRIVATE stringarray .)
    LTE             reduce using rule 42 (arraydefinition -> PRIVATE stringarray .)
    GTE             reduce using rule 42 (arraydefinition -> PRIVATE stringarray .)
    EQUALITY        reduce using rule 42 (arraydefinition -> PRIVATE stringarray .)
    INEQUALITY      reduce using rule 42 (arraydefinition -> PRIVATE stringarray .)
    AND             reduce using rule 42 (arraydefinition -> PRIVATE stringarray .)
    OR              reduce using rule 42 (arraydefinition -> PRIVATE stringarray .)
    PLUS            reduce using rule 42 (arraydefinition -> PRIVATE stringarray .)
    MINUS           reduce using rule 42 (arraydefinition -> PRIVATE stringarray .)
    TIMES           reduce using rule 42 (arraydefinition -> PRIVATE stringarray .)
    DIVIDE          reduce using rule 42 (arraydefinition -> PRIVATE stringarray .)
    MOD             reduce using rule 42 (arraydefinition -> PRIVATE stringarray .)
    POW             reduce using rule 42 (arraydefinition -> PRIVATE stringarray .)
    RBRACE          reduce using rule 42 (arraydefinition -> PRIVATE stringarray .)
    RPAREN          reduce using rule 42 (arraydefinition -> PRIVATE stringarray .)
    RSPAREN         reduce using rule 42 (arraydefinition -> PRIVATE stringarray .)
    TO              reduce using rule 42 (arraydefinition -> PRIVATE stringarray .)
    STEP            reduce using rule 42 (arraydefinition -> PRIVATE stringarray .)
    DO              reduce using rule 42 (arraydefinition -> PRIVATE stringarray .)


state 97

    (68) stringarray -> LSPAREN . RSPAREN
    (69) stringarray -> LSPAREN . stringarrayelement RSPAREN
    (70) stringarrayelement -> . string
    (71) stringarrayelement -> . string COMMA stringarrayelement
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE

    RSPAREN         shift and go to state 124
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48

    stringarrayelement             shift and go to state 125
    string                         shift and go to state 126

state 98

    (60) primaryexp -> LPAREN binaryexp . RPAREN
    (58) primaryexp -> binaryexp .

    RPAREN          shift and go to state 127
    BINARY_FNC      reduce using rule 58 (primaryexp -> binaryexp .)
    LT              reduce using rule 58 (primaryexp -> binaryexp .)
    GT              reduce using rule 58 (primaryexp -> binaryexp .)
    LTE             reduce using rule 58 (primaryexp -> binaryexp .)
    GTE             reduce using rule 58 (primaryexp -> binaryexp .)
    EQUALITY        reduce using rule 58 (primaryexp -> binaryexp .)
    INEQUALITY      reduce using rule 58 (primaryexp -> binaryexp .)
    AND             reduce using rule 58 (primaryexp -> binaryexp .)
    OR              reduce using rule 58 (primaryexp -> binaryexp .)
    PLUS            reduce using rule 58 (primaryexp -> binaryexp .)
    MINUS           reduce using rule 58 (primaryexp -> binaryexp .)
    TIMES           reduce using rule 58 (primaryexp -> binaryexp .)
    DIVIDE          reduce using rule 58 (primaryexp -> binaryexp .)
    MOD             reduce using rule 58 (primaryexp -> binaryexp .)
    POW             reduce using rule 58 (primaryexp -> binaryexp .)


state 99

    (19) iftype -> IF forloop_condition .

    THEN            reduce using rule 19 (iftype -> IF forloop_condition .)
    EXITWITH        reduce using rule 19 (iftype -> IF forloop_condition .)
    BINARY_FNC      reduce using rule 19 (iftype -> IF forloop_condition .)
    LT              reduce using rule 19 (iftype -> IF forloop_condition .)
    GT              reduce using rule 19 (iftype -> IF forloop_condition .)
    LTE             reduce using rule 19 (iftype -> IF forloop_condition .)
    GTE             reduce using rule 19 (iftype -> IF forloop_condition .)
    EQUALITY        reduce using rule 19 (iftype -> IF forloop_condition .)
    INEQUALITY      reduce using rule 19 (iftype -> IF forloop_condition .)
    AND             reduce using rule 19 (iftype -> IF forloop_condition .)
    OR              reduce using rule 19 (iftype -> IF forloop_condition .)
    PLUS            reduce using rule 19 (iftype -> IF forloop_condition .)
    MINUS           reduce using rule 19 (iftype -> IF forloop_condition .)
    TIMES           reduce using rule 19 (iftype -> IF forloop_condition .)
    DIVIDE          reduce using rule 19 (iftype -> IF forloop_condition .)
    MOD             reduce using rule 19 (iftype -> IF forloop_condition .)
    POW             reduce using rule 19 (iftype -> IF forloop_condition .)
    SEMI_COLON      reduce using rule 19 (iftype -> IF forloop_condition .)
    COMMA           reduce using rule 19 (iftype -> IF forloop_condition .)
    $end            reduce using rule 19 (iftype -> IF forloop_condition .)
    RBRACE          reduce using rule 19 (iftype -> IF forloop_condition .)
    RPAREN          reduce using rule 19 (iftype -> IF forloop_condition .)
    RSPAREN         reduce using rule 19 (iftype -> IF forloop_condition .)
    TO              reduce using rule 19 (iftype -> IF forloop_condition .)
    STEP            reduce using rule 19 (iftype -> IF forloop_condition .)
    DO              reduce using rule 19 (iftype -> IF forloop_condition .)


state 100

    (32) forloop_condition -> LBRACE . booleanexp RBRACE
    (93) booleanexp -> . primaryexp
    (94) booleanexp -> . primaryexp comparisonoperator booleanexp
    (95) booleanexp -> . primaryexp comparisonoperator LBRACE booleanexp RBRACE
    (52) primaryexp -> . number
    (53) primaryexp -> . identifier
    (54) primaryexp -> . helpertype
    (55) primaryexp -> . unaryexp
    (56) primaryexp -> . nularexp
    (57) primaryexp -> . string
    (58) primaryexp -> . binaryexp
    (59) primaryexp -> . bracedexp
    (60) primaryexp -> . LPAREN binaryexp RPAREN
    (61) primaryexp -> . array
    (98) number -> . NUMBER_REAL
    (99) number -> . NUMBER_EXP
    (100) number -> . NUMBER_HEX
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (74) unaryexp -> . UNARY_FNC primaryexp
    (75) unaryexp -> . PLUS primaryexp
    (76) unaryexp -> . MINUS primaryexp
    (77) unaryexp -> . NOT primaryexp
    (78) unaryexp -> . vardefinition
    (72) nularexp -> . NULAR_FNC
    (73) nularexp -> . identifier
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE
    (49) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (50) binaryexp -> . primaryexp comparisonoperator primaryexp
    (51) binaryexp -> . primaryexp mathoperator primaryexp
    (62) bracedexp -> . LBRACE new_scope code RBRACE
    (64) array -> . LSPAREN RSPAREN
    (65) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF forloop_condition
    (26) whiletype -> . WHILE forloop_condition
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (35) vardefinition -> . definition
    (36) vardefinition -> . arraydefinition
    (43) definition -> . PRIVATE PRIVATE_ID
    (44) definition -> . PRIVATE string
    (42) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 44
    NUMBER_EXP      shift and go to state 45
    NUMBER_HEX      shift and go to state 46
    PRIVATE_ID      shift and go to state 78
    GLOBAL_ID       shift and go to state 79
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 42
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    WITH            shift and go to state 49
    PRIVATE         shift and go to state 30

    booleanexp                     shift and go to state 128
    primaryexp                     shift and go to state 129
    number                         shift and go to state 34
    identifier                     shift and go to state 74
    helpertype                     shift and go to state 35
    unaryexp                       shift and go to state 75
    nularexp                       shift and go to state 76
    string                         shift and go to state 32
    binaryexp                      shift and go to state 77
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 80
    whiletype                      shift and go to state 81
    fortype                        shift and go to state 82
    withtype                       shift and go to state 83
    vardefinition                  shift and go to state 23
    definition                     shift and go to state 84
    arraydefinition                shift and go to state 38

state 101

    (33) forloop_condition -> identifier .

    THEN            reduce using rule 33 (forloop_condition -> identifier .)
    EXITWITH        reduce using rule 33 (forloop_condition -> identifier .)
    BINARY_FNC      reduce using rule 33 (forloop_condition -> identifier .)
    LT              reduce using rule 33 (forloop_condition -> identifier .)
    GT              reduce using rule 33 (forloop_condition -> identifier .)
    LTE             reduce using rule 33 (forloop_condition -> identifier .)
    GTE             reduce using rule 33 (forloop_condition -> identifier .)
    EQUALITY        reduce using rule 33 (forloop_condition -> identifier .)
    INEQUALITY      reduce using rule 33 (forloop_condition -> identifier .)
    AND             reduce using rule 33 (forloop_condition -> identifier .)
    OR              reduce using rule 33 (forloop_condition -> identifier .)
    PLUS            reduce using rule 33 (forloop_condition -> identifier .)
    MINUS           reduce using rule 33 (forloop_condition -> identifier .)
    TIMES           reduce using rule 33 (forloop_condition -> identifier .)
    DIVIDE          reduce using rule 33 (forloop_condition -> identifier .)
    MOD             reduce using rule 33 (forloop_condition -> identifier .)
    POW             reduce using rule 33 (forloop_condition -> identifier .)
    SEMI_COLON      reduce using rule 33 (forloop_condition -> identifier .)
    COMMA           reduce using rule 33 (forloop_condition -> identifier .)
    $end            reduce using rule 33 (forloop_condition -> identifier .)
    RBRACE          reduce using rule 33 (forloop_condition -> identifier .)
    RPAREN          reduce using rule 33 (forloop_condition -> identifier .)
    RSPAREN         reduce using rule 33 (forloop_condition -> identifier .)
    TO              reduce using rule 33 (forloop_condition -> identifier .)
    STEP            reduce using rule 33 (forloop_condition -> identifier .)
    DO              reduce using rule 33 (forloop_condition -> identifier .)


state 102

    (26) whiletype -> WHILE forloop_condition .

    DO              reduce using rule 26 (whiletype -> WHILE forloop_condition .)
    BINARY_FNC      reduce using rule 26 (whiletype -> WHILE forloop_condition .)
    LT              reduce using rule 26 (whiletype -> WHILE forloop_condition .)
    GT              reduce using rule 26 (whiletype -> WHILE forloop_condition .)
    LTE             reduce using rule 26 (whiletype -> WHILE forloop_condition .)
    GTE             reduce using rule 26 (whiletype -> WHILE forloop_condition .)
    EQUALITY        reduce using rule 26 (whiletype -> WHILE forloop_condition .)
    INEQUALITY      reduce using rule 26 (whiletype -> WHILE forloop_condition .)
    AND             reduce using rule 26 (whiletype -> WHILE forloop_condition .)
    OR              reduce using rule 26 (whiletype -> WHILE forloop_condition .)
    PLUS            reduce using rule 26 (whiletype -> WHILE forloop_condition .)
    MINUS           reduce using rule 26 (whiletype -> WHILE forloop_condition .)
    TIMES           reduce using rule 26 (whiletype -> WHILE forloop_condition .)
    DIVIDE          reduce using rule 26 (whiletype -> WHILE forloop_condition .)
    MOD             reduce using rule 26 (whiletype -> WHILE forloop_condition .)
    POW             reduce using rule 26 (whiletype -> WHILE forloop_condition .)
    SEMI_COLON      reduce using rule 26 (whiletype -> WHILE forloop_condition .)
    COMMA           reduce using rule 26 (whiletype -> WHILE forloop_condition .)
    $end            reduce using rule 26 (whiletype -> WHILE forloop_condition .)
    RBRACE          reduce using rule 26 (whiletype -> WHILE forloop_condition .)
    RPAREN          reduce using rule 26 (whiletype -> WHILE forloop_condition .)
    RSPAREN         reduce using rule 26 (whiletype -> WHILE forloop_condition .)
    TO              reduce using rule 26 (whiletype -> WHILE forloop_condition .)
    STEP            reduce using rule 26 (whiletype -> WHILE forloop_condition .)


state 103

    (28) fortype -> FOR new_scope . string FROM primaryexp TO primaryexp
    (29) fortype -> FOR new_scope . string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> FOR new_scope . LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE

    LSPAREN         shift and go to state 131
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48

    string                         shift and go to state 130

state 104

    (64) array -> LSPAREN RSPAREN .

    BINARY_FNC      reduce using rule 64 (array -> LSPAREN RSPAREN .)
    LT              reduce using rule 64 (array -> LSPAREN RSPAREN .)
    GT              reduce using rule 64 (array -> LSPAREN RSPAREN .)
    LTE             reduce using rule 64 (array -> LSPAREN RSPAREN .)
    GTE             reduce using rule 64 (array -> LSPAREN RSPAREN .)
    EQUALITY        reduce using rule 64 (array -> LSPAREN RSPAREN .)
    INEQUALITY      reduce using rule 64 (array -> LSPAREN RSPAREN .)
    AND             reduce using rule 64 (array -> LSPAREN RSPAREN .)
    OR              reduce using rule 64 (array -> LSPAREN RSPAREN .)
    PLUS            reduce using rule 64 (array -> LSPAREN RSPAREN .)
    MINUS           reduce using rule 64 (array -> LSPAREN RSPAREN .)
    TIMES           reduce using rule 64 (array -> LSPAREN RSPAREN .)
    DIVIDE          reduce using rule 64 (array -> LSPAREN RSPAREN .)
    MOD             reduce using rule 64 (array -> LSPAREN RSPAREN .)
    POW             reduce using rule 64 (array -> LSPAREN RSPAREN .)
    SEMI_COLON      reduce using rule 64 (array -> LSPAREN RSPAREN .)
    COMMA           reduce using rule 64 (array -> LSPAREN RSPAREN .)
    $end            reduce using rule 64 (array -> LSPAREN RSPAREN .)
    RBRACE          reduce using rule 64 (array -> LSPAREN RSPAREN .)
    RPAREN          reduce using rule 64 (array -> LSPAREN RSPAREN .)
    RSPAREN         reduce using rule 64 (array -> LSPAREN RSPAREN .)
    TO              reduce using rule 64 (array -> LSPAREN RSPAREN .)
    STEP            reduce using rule 64 (array -> LSPAREN RSPAREN .)
    DO              reduce using rule 64 (array -> LSPAREN RSPAREN .)


state 105

    (65) array -> LSPAREN arrayelement . RSPAREN

    RSPAREN         shift and go to state 132


state 106

    (66) arrayelement -> binaryexp .
    (67) arrayelement -> binaryexp . COMMA arrayelement
    (58) primaryexp -> binaryexp .

    RSPAREN         reduce using rule 66 (arrayelement -> binaryexp .)
    COMMA           shift and go to state 133
    BINARY_FNC      reduce using rule 58 (primaryexp -> binaryexp .)
    LT              reduce using rule 58 (primaryexp -> binaryexp .)
    GT              reduce using rule 58 (primaryexp -> binaryexp .)
    LTE             reduce using rule 58 (primaryexp -> binaryexp .)
    GTE             reduce using rule 58 (primaryexp -> binaryexp .)
    EQUALITY        reduce using rule 58 (primaryexp -> binaryexp .)
    INEQUALITY      reduce using rule 58 (primaryexp -> binaryexp .)
    AND             reduce using rule 58 (primaryexp -> binaryexp .)
    OR              reduce using rule 58 (primaryexp -> binaryexp .)
    PLUS            reduce using rule 58 (primaryexp -> binaryexp .)
    MINUS           reduce using rule 58 (primaryexp -> binaryexp .)
    TIMES           reduce using rule 58 (primaryexp -> binaryexp .)
    DIVIDE          reduce using rule 58 (primaryexp -> binaryexp .)
    MOD             reduce using rule 58 (primaryexp -> binaryexp .)
    POW             reduce using rule 58 (primaryexp -> binaryexp .)


state 107

    (24) withstatementinit -> withtype DO .

    LBRACE          reduce using rule 24 (withstatementinit -> withtype DO .)


state 108

    (23) withtype -> WITH NAMESPACE .

    DO              reduce using rule 23 (withtype -> WITH NAMESPACE .)
    BINARY_FNC      reduce using rule 23 (withtype -> WITH NAMESPACE .)
    LT              reduce using rule 23 (withtype -> WITH NAMESPACE .)
    GT              reduce using rule 23 (withtype -> WITH NAMESPACE .)
    LTE             reduce using rule 23 (withtype -> WITH NAMESPACE .)
    GTE             reduce using rule 23 (withtype -> WITH NAMESPACE .)
    EQUALITY        reduce using rule 23 (withtype -> WITH NAMESPACE .)
    INEQUALITY      reduce using rule 23 (withtype -> WITH NAMESPACE .)
    AND             reduce using rule 23 (withtype -> WITH NAMESPACE .)
    OR              reduce using rule 23 (withtype -> WITH NAMESPACE .)
    PLUS            reduce using rule 23 (withtype -> WITH NAMESPACE .)
    MINUS           reduce using rule 23 (withtype -> WITH NAMESPACE .)
    TIMES           reduce using rule 23 (withtype -> WITH NAMESPACE .)
    DIVIDE          reduce using rule 23 (withtype -> WITH NAMESPACE .)
    MOD             reduce using rule 23 (withtype -> WITH NAMESPACE .)
    POW             reduce using rule 23 (withtype -> WITH NAMESPACE .)
    SEMI_COLON      reduce using rule 23 (withtype -> WITH NAMESPACE .)
    COMMA           reduce using rule 23 (withtype -> WITH NAMESPACE .)
    $end            reduce using rule 23 (withtype -> WITH NAMESPACE .)
    RBRACE          reduce using rule 23 (withtype -> WITH NAMESPACE .)
    RPAREN          reduce using rule 23 (withtype -> WITH NAMESPACE .)
    RSPAREN         reduce using rule 23 (withtype -> WITH NAMESPACE .)
    TO              reduce using rule 23 (withtype -> WITH NAMESPACE .)
    STEP            reduce using rule 23 (withtype -> WITH NAMESPACE .)


state 109

    (3) code -> statement terminator code .

    $end            reduce using rule 3 (code -> statement terminator code .)
    RBRACE          reduce using rule 3 (code -> statement terminator code .)


state 110

    (37) assignment -> assignment_code code RBRACE .

    SEMI_COLON      reduce using rule 37 (assignment -> assignment_code code RBRACE .)
    COMMA           reduce using rule 37 (assignment -> assignment_code code RBRACE .)
    $end            reduce using rule 37 (assignment -> assignment_code code RBRACE .)
    RBRACE          reduce using rule 37 (assignment -> assignment_code code RBRACE .)


state 111

    (38) assignment -> definition EQUAL primaryexp .
    (49) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (50) binaryexp -> primaryexp . comparisonoperator primaryexp
    (51) binaryexp -> primaryexp . mathoperator primaryexp
    (79) comparisonoperator -> . LT
    (80) comparisonoperator -> . GT
    (81) comparisonoperator -> . LTE
    (82) comparisonoperator -> . GTE
    (83) comparisonoperator -> . EQUALITY
    (84) comparisonoperator -> . INEQUALITY
    (85) comparisonoperator -> . AND
    (86) comparisonoperator -> . OR
    (87) mathoperator -> . PLUS
    (88) mathoperator -> . MINUS
    (89) mathoperator -> . TIMES
    (90) mathoperator -> . DIVIDE
    (91) mathoperator -> . MOD
    (92) mathoperator -> . POW

    SEMI_COLON      reduce using rule 38 (assignment -> definition EQUAL primaryexp .)
    COMMA           reduce using rule 38 (assignment -> definition EQUAL primaryexp .)
    $end            reduce using rule 38 (assignment -> definition EQUAL primaryexp .)
    RBRACE          reduce using rule 38 (assignment -> definition EQUAL primaryexp .)
    BINARY_FNC      shift and go to state 55
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61
    EQUALITY        shift and go to state 62
    INEQUALITY      shift and go to state 63
    AND             shift and go to state 64
    OR              shift and go to state 65
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POW             shift and go to state 71

    comparisonoperator             shift and go to state 56
    mathoperator                   shift and go to state 57

state 112

    (40) assignment_code -> definition EQUAL LBRACE .
    (62) bracedexp -> LBRACE . new_scope code RBRACE
    (63) new_scope -> .

  ! reduce/reduce conflict for NULAR_FNC resolved using rule 40 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for UNARY_FNC resolved using rule 40 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for PLUS resolved using rule 40 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for MINUS resolved using rule 40 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for NOT resolved using rule 40 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for PRIVATE resolved using rule 40 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for PRIVATE_ID resolved using rule 40 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for GLOBAL_ID resolved using rule 40 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for LPAREN resolved using rule 40 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for IF resolved using rule 40 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for WHILE resolved using rule 40 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for FOR resolved using rule 40 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for NUMBER_REAL resolved using rule 40 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for NUMBER_EXP resolved using rule 40 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for NUMBER_HEX resolved using rule 40 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for STRING_SINGLE resolved using rule 40 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for STRING_DOUBLE resolved using rule 40 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for LBRACE resolved using rule 40 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for LSPAREN resolved using rule 40 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for WITH resolved using rule 40 (assignment_code -> definition EQUAL LBRACE .)
  ! reduce/reduce conflict for RBRACE resolved using rule 40 (assignment_code -> definition EQUAL LBRACE .)
    NULAR_FNC       reduce using rule 40 (assignment_code -> definition EQUAL LBRACE .)
    UNARY_FNC       reduce using rule 40 (assignment_code -> definition EQUAL LBRACE .)
    PLUS            reduce using rule 40 (assignment_code -> definition EQUAL LBRACE .)
    MINUS           reduce using rule 40 (assignment_code -> definition EQUAL LBRACE .)
    NOT             reduce using rule 40 (assignment_code -> definition EQUAL LBRACE .)
    PRIVATE         reduce using rule 40 (assignment_code -> definition EQUAL LBRACE .)
    PRIVATE_ID      reduce using rule 40 (assignment_code -> definition EQUAL LBRACE .)
    GLOBAL_ID       reduce using rule 40 (assignment_code -> definition EQUAL LBRACE .)
    LPAREN          reduce using rule 40 (assignment_code -> definition EQUAL LBRACE .)
    IF              reduce using rule 40 (assignment_code -> definition EQUAL LBRACE .)
    WHILE           reduce using rule 40 (assignment_code -> definition EQUAL LBRACE .)
    FOR             reduce using rule 40 (assignment_code -> definition EQUAL LBRACE .)
    NUMBER_REAL     reduce using rule 40 (assignment_code -> definition EQUAL LBRACE .)
    NUMBER_EXP      reduce using rule 40 (assignment_code -> definition EQUAL LBRACE .)
    NUMBER_HEX      reduce using rule 40 (assignment_code -> definition EQUAL LBRACE .)
    STRING_SINGLE   reduce using rule 40 (assignment_code -> definition EQUAL LBRACE .)
    STRING_DOUBLE   reduce using rule 40 (assignment_code -> definition EQUAL LBRACE .)
    LBRACE          reduce using rule 40 (assignment_code -> definition EQUAL LBRACE .)
    LSPAREN         reduce using rule 40 (assignment_code -> definition EQUAL LBRACE .)
    WITH            reduce using rule 40 (assignment_code -> definition EQUAL LBRACE .)
    RBRACE          reduce using rule 40 (assignment_code -> definition EQUAL LBRACE .)

  ! NULAR_FNC       [ reduce using rule 63 (new_scope -> .) ]
  ! UNARY_FNC       [ reduce using rule 63 (new_scope -> .) ]
  ! PLUS            [ reduce using rule 63 (new_scope -> .) ]
  ! MINUS           [ reduce using rule 63 (new_scope -> .) ]
  ! NOT             [ reduce using rule 63 (new_scope -> .) ]
  ! PRIVATE         [ reduce using rule 63 (new_scope -> .) ]
  ! PRIVATE_ID      [ reduce using rule 63 (new_scope -> .) ]
  ! GLOBAL_ID       [ reduce using rule 63 (new_scope -> .) ]
  ! LPAREN          [ reduce using rule 63 (new_scope -> .) ]
  ! IF              [ reduce using rule 63 (new_scope -> .) ]
  ! WHILE           [ reduce using rule 63 (new_scope -> .) ]
  ! FOR             [ reduce using rule 63 (new_scope -> .) ]
  ! NUMBER_REAL     [ reduce using rule 63 (new_scope -> .) ]
  ! NUMBER_EXP      [ reduce using rule 63 (new_scope -> .) ]
  ! NUMBER_HEX      [ reduce using rule 63 (new_scope -> .) ]
  ! STRING_SINGLE   [ reduce using rule 63 (new_scope -> .) ]
  ! STRING_DOUBLE   [ reduce using rule 63 (new_scope -> .) ]
  ! LBRACE          [ reduce using rule 63 (new_scope -> .) ]
  ! LSPAREN         [ reduce using rule 63 (new_scope -> .) ]
  ! WITH            [ reduce using rule 63 (new_scope -> .) ]
  ! RBRACE          [ reduce using rule 63 (new_scope -> .) ]

    new_scope                      shift and go to state 93

state 113

    (49) binaryexp -> primaryexp BINARY_FNC primaryexp .
    (49) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (50) binaryexp -> primaryexp . comparisonoperator primaryexp
    (51) binaryexp -> primaryexp . mathoperator primaryexp
    (79) comparisonoperator -> . LT
    (80) comparisonoperator -> . GT
    (81) comparisonoperator -> . LTE
    (82) comparisonoperator -> . GTE
    (83) comparisonoperator -> . EQUALITY
    (84) comparisonoperator -> . INEQUALITY
    (85) comparisonoperator -> . AND
    (86) comparisonoperator -> . OR
    (87) mathoperator -> . PLUS
    (88) mathoperator -> . MINUS
    (89) mathoperator -> . TIMES
    (90) mathoperator -> . DIVIDE
    (91) mathoperator -> . MOD
    (92) mathoperator -> . POW

    SEMI_COLON      reduce using rule 49 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    COMMA           reduce using rule 49 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    $end            reduce using rule 49 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    BINARY_FNC      reduce using rule 49 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    LT              reduce using rule 49 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    GT              reduce using rule 49 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    LTE             reduce using rule 49 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    GTE             reduce using rule 49 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    EQUALITY        reduce using rule 49 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    INEQUALITY      reduce using rule 49 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    AND             reduce using rule 49 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    OR              reduce using rule 49 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    RBRACE          reduce using rule 49 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    RPAREN          reduce using rule 49 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    RSPAREN         reduce using rule 49 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    TO              reduce using rule 49 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    STEP            reduce using rule 49 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    DO              reduce using rule 49 (binaryexp -> primaryexp BINARY_FNC primaryexp .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POW             shift and go to state 71

  ! PLUS            [ reduce using rule 49 (binaryexp -> primaryexp BINARY_FNC primaryexp .) ]
  ! MINUS           [ reduce using rule 49 (binaryexp -> primaryexp BINARY_FNC primaryexp .) ]
  ! TIMES           [ reduce using rule 49 (binaryexp -> primaryexp BINARY_FNC primaryexp .) ]
  ! DIVIDE          [ reduce using rule 49 (binaryexp -> primaryexp BINARY_FNC primaryexp .) ]
  ! MOD             [ reduce using rule 49 (binaryexp -> primaryexp BINARY_FNC primaryexp .) ]
  ! POW             [ reduce using rule 49 (binaryexp -> primaryexp BINARY_FNC primaryexp .) ]
  ! BINARY_FNC      [ shift and go to state 55 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! LTE             [ shift and go to state 60 ]
  ! GTE             [ shift and go to state 61 ]
  ! EQUALITY        [ shift and go to state 62 ]
  ! INEQUALITY      [ shift and go to state 63 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 65 ]

    comparisonoperator             shift and go to state 56
    mathoperator                   shift and go to state 57

state 114

    (50) binaryexp -> primaryexp comparisonoperator primaryexp .
    (49) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (50) binaryexp -> primaryexp . comparisonoperator primaryexp
    (51) binaryexp -> primaryexp . mathoperator primaryexp
    (79) comparisonoperator -> . LT
    (80) comparisonoperator -> . GT
    (81) comparisonoperator -> . LTE
    (82) comparisonoperator -> . GTE
    (83) comparisonoperator -> . EQUALITY
    (84) comparisonoperator -> . INEQUALITY
    (85) comparisonoperator -> . AND
    (86) comparisonoperator -> . OR
    (87) mathoperator -> . PLUS
    (88) mathoperator -> . MINUS
    (89) mathoperator -> . TIMES
    (90) mathoperator -> . DIVIDE
    (91) mathoperator -> . MOD
    (92) mathoperator -> . POW

    SEMI_COLON      reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    COMMA           reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    $end            reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    BINARY_FNC      reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    LT              reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    GT              reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    LTE             reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    GTE             reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    EQUALITY        reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    INEQUALITY      reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    AND             reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    OR              reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    RBRACE          reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    RPAREN          reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    RSPAREN         reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    TO              reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    STEP            reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    DO              reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POW             shift and go to state 71

  ! PLUS            [ reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! MINUS           [ reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! TIMES           [ reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! DIVIDE          [ reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! MOD             [ reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! POW             [ reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! BINARY_FNC      [ shift and go to state 55 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! LTE             [ shift and go to state 60 ]
  ! GTE             [ shift and go to state 61 ]
  ! EQUALITY        [ shift and go to state 62 ]
  ! INEQUALITY      [ shift and go to state 63 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 65 ]

    comparisonoperator             shift and go to state 56
    mathoperator                   shift and go to state 57

state 115

    (51) binaryexp -> primaryexp mathoperator primaryexp .
    (49) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (50) binaryexp -> primaryexp . comparisonoperator primaryexp
    (51) binaryexp -> primaryexp . mathoperator primaryexp
    (79) comparisonoperator -> . LT
    (80) comparisonoperator -> . GT
    (81) comparisonoperator -> . LTE
    (82) comparisonoperator -> . GTE
    (83) comparisonoperator -> . EQUALITY
    (84) comparisonoperator -> . INEQUALITY
    (85) comparisonoperator -> . AND
    (86) comparisonoperator -> . OR
    (87) mathoperator -> . PLUS
    (88) mathoperator -> . MINUS
    (89) mathoperator -> . TIMES
    (90) mathoperator -> . DIVIDE
    (91) mathoperator -> . MOD
    (92) mathoperator -> . POW

    SEMI_COLON      reduce using rule 51 (binaryexp -> primaryexp mathoperator primaryexp .)
    COMMA           reduce using rule 51 (binaryexp -> primaryexp mathoperator primaryexp .)
    $end            reduce using rule 51 (binaryexp -> primaryexp mathoperator primaryexp .)
    BINARY_FNC      reduce using rule 51 (binaryexp -> primaryexp mathoperator primaryexp .)
    LT              reduce using rule 51 (binaryexp -> primaryexp mathoperator primaryexp .)
    GT              reduce using rule 51 (binaryexp -> primaryexp mathoperator primaryexp .)
    LTE             reduce using rule 51 (binaryexp -> primaryexp mathoperator primaryexp .)
    GTE             reduce using rule 51 (binaryexp -> primaryexp mathoperator primaryexp .)
    EQUALITY        reduce using rule 51 (binaryexp -> primaryexp mathoperator primaryexp .)
    INEQUALITY      reduce using rule 51 (binaryexp -> primaryexp mathoperator primaryexp .)
    AND             reduce using rule 51 (binaryexp -> primaryexp mathoperator primaryexp .)
    OR              reduce using rule 51 (binaryexp -> primaryexp mathoperator primaryexp .)
    RBRACE          reduce using rule 51 (binaryexp -> primaryexp mathoperator primaryexp .)
    RPAREN          reduce using rule 51 (binaryexp -> primaryexp mathoperator primaryexp .)
    RSPAREN         reduce using rule 51 (binaryexp -> primaryexp mathoperator primaryexp .)
    TO              reduce using rule 51 (binaryexp -> primaryexp mathoperator primaryexp .)
    STEP            reduce using rule 51 (binaryexp -> primaryexp mathoperator primaryexp .)
    DO              reduce using rule 51 (binaryexp -> primaryexp mathoperator primaryexp .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POW             shift and go to state 71

  ! PLUS            [ reduce using rule 51 (binaryexp -> primaryexp mathoperator primaryexp .) ]
  ! MINUS           [ reduce using rule 51 (binaryexp -> primaryexp mathoperator primaryexp .) ]
  ! TIMES           [ reduce using rule 51 (binaryexp -> primaryexp mathoperator primaryexp .) ]
  ! DIVIDE          [ reduce using rule 51 (binaryexp -> primaryexp mathoperator primaryexp .) ]
  ! MOD             [ reduce using rule 51 (binaryexp -> primaryexp mathoperator primaryexp .) ]
  ! POW             [ reduce using rule 51 (binaryexp -> primaryexp mathoperator primaryexp .) ]
  ! BINARY_FNC      [ shift and go to state 55 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! LTE             [ shift and go to state 60 ]
  ! GTE             [ shift and go to state 61 ]
  ! EQUALITY        [ shift and go to state 62 ]
  ! INEQUALITY      [ shift and go to state 63 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 65 ]

    mathoperator                   shift and go to state 57
    comparisonoperator             shift and go to state 56

state 116

    (39) assignment -> variable EQUAL primaryexp .
    (49) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (50) binaryexp -> primaryexp . comparisonoperator primaryexp
    (51) binaryexp -> primaryexp . mathoperator primaryexp
    (79) comparisonoperator -> . LT
    (80) comparisonoperator -> . GT
    (81) comparisonoperator -> . LTE
    (82) comparisonoperator -> . GTE
    (83) comparisonoperator -> . EQUALITY
    (84) comparisonoperator -> . INEQUALITY
    (85) comparisonoperator -> . AND
    (86) comparisonoperator -> . OR
    (87) mathoperator -> . PLUS
    (88) mathoperator -> . MINUS
    (89) mathoperator -> . TIMES
    (90) mathoperator -> . DIVIDE
    (91) mathoperator -> . MOD
    (92) mathoperator -> . POW

    SEMI_COLON      reduce using rule 39 (assignment -> variable EQUAL primaryexp .)
    COMMA           reduce using rule 39 (assignment -> variable EQUAL primaryexp .)
    $end            reduce using rule 39 (assignment -> variable EQUAL primaryexp .)
    RBRACE          reduce using rule 39 (assignment -> variable EQUAL primaryexp .)
    BINARY_FNC      shift and go to state 55
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61
    EQUALITY        shift and go to state 62
    INEQUALITY      shift and go to state 63
    AND             shift and go to state 64
    OR              shift and go to state 65
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POW             shift and go to state 71

    comparisonoperator             shift and go to state 56
    mathoperator                   shift and go to state 57

state 117

    (41) assignment_code -> variable EQUAL LBRACE .
    (62) bracedexp -> LBRACE . new_scope code RBRACE
    (63) new_scope -> .

  ! reduce/reduce conflict for NULAR_FNC resolved using rule 41 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for UNARY_FNC resolved using rule 41 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for PLUS resolved using rule 41 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for MINUS resolved using rule 41 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for NOT resolved using rule 41 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for PRIVATE resolved using rule 41 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for PRIVATE_ID resolved using rule 41 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for GLOBAL_ID resolved using rule 41 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for LPAREN resolved using rule 41 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for IF resolved using rule 41 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for WHILE resolved using rule 41 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for FOR resolved using rule 41 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for NUMBER_REAL resolved using rule 41 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for NUMBER_EXP resolved using rule 41 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for NUMBER_HEX resolved using rule 41 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for STRING_SINGLE resolved using rule 41 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for STRING_DOUBLE resolved using rule 41 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for LBRACE resolved using rule 41 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for LSPAREN resolved using rule 41 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for WITH resolved using rule 41 (assignment_code -> variable EQUAL LBRACE .)
  ! reduce/reduce conflict for RBRACE resolved using rule 41 (assignment_code -> variable EQUAL LBRACE .)
    NULAR_FNC       reduce using rule 41 (assignment_code -> variable EQUAL LBRACE .)
    UNARY_FNC       reduce using rule 41 (assignment_code -> variable EQUAL LBRACE .)
    PLUS            reduce using rule 41 (assignment_code -> variable EQUAL LBRACE .)
    MINUS           reduce using rule 41 (assignment_code -> variable EQUAL LBRACE .)
    NOT             reduce using rule 41 (assignment_code -> variable EQUAL LBRACE .)
    PRIVATE         reduce using rule 41 (assignment_code -> variable EQUAL LBRACE .)
    PRIVATE_ID      reduce using rule 41 (assignment_code -> variable EQUAL LBRACE .)
    GLOBAL_ID       reduce using rule 41 (assignment_code -> variable EQUAL LBRACE .)
    LPAREN          reduce using rule 41 (assignment_code -> variable EQUAL LBRACE .)
    IF              reduce using rule 41 (assignment_code -> variable EQUAL LBRACE .)
    WHILE           reduce using rule 41 (assignment_code -> variable EQUAL LBRACE .)
    FOR             reduce using rule 41 (assignment_code -> variable EQUAL LBRACE .)
    NUMBER_REAL     reduce using rule 41 (assignment_code -> variable EQUAL LBRACE .)
    NUMBER_EXP      reduce using rule 41 (assignment_code -> variable EQUAL LBRACE .)
    NUMBER_HEX      reduce using rule 41 (assignment_code -> variable EQUAL LBRACE .)
    STRING_SINGLE   reduce using rule 41 (assignment_code -> variable EQUAL LBRACE .)
    STRING_DOUBLE   reduce using rule 41 (assignment_code -> variable EQUAL LBRACE .)
    LBRACE          reduce using rule 41 (assignment_code -> variable EQUAL LBRACE .)
    LSPAREN         reduce using rule 41 (assignment_code -> variable EQUAL LBRACE .)
    WITH            reduce using rule 41 (assignment_code -> variable EQUAL LBRACE .)
    RBRACE          reduce using rule 41 (assignment_code -> variable EQUAL LBRACE .)

  ! NULAR_FNC       [ reduce using rule 63 (new_scope -> .) ]
  ! UNARY_FNC       [ reduce using rule 63 (new_scope -> .) ]
  ! PLUS            [ reduce using rule 63 (new_scope -> .) ]
  ! MINUS           [ reduce using rule 63 (new_scope -> .) ]
  ! NOT             [ reduce using rule 63 (new_scope -> .) ]
  ! PRIVATE         [ reduce using rule 63 (new_scope -> .) ]
  ! PRIVATE_ID      [ reduce using rule 63 (new_scope -> .) ]
  ! GLOBAL_ID       [ reduce using rule 63 (new_scope -> .) ]
  ! LPAREN          [ reduce using rule 63 (new_scope -> .) ]
  ! IF              [ reduce using rule 63 (new_scope -> .) ]
  ! WHILE           [ reduce using rule 63 (new_scope -> .) ]
  ! FOR             [ reduce using rule 63 (new_scope -> .) ]
  ! NUMBER_REAL     [ reduce using rule 63 (new_scope -> .) ]
  ! NUMBER_EXP      [ reduce using rule 63 (new_scope -> .) ]
  ! NUMBER_HEX      [ reduce using rule 63 (new_scope -> .) ]
  ! STRING_SINGLE   [ reduce using rule 63 (new_scope -> .) ]
  ! STRING_DOUBLE   [ reduce using rule 63 (new_scope -> .) ]
  ! LBRACE          [ reduce using rule 63 (new_scope -> .) ]
  ! LSPAREN         [ reduce using rule 63 (new_scope -> .) ]
  ! WITH            [ reduce using rule 63 (new_scope -> .) ]
  ! RBRACE          [ reduce using rule 63 (new_scope -> .) ]

    new_scope                      shift and go to state 93

state 118

    (20) ifstatement -> iftype THEN bracedexp .
    (22) ifstatement -> iftype THEN bracedexp . ELSE bracedexp

    SEMI_COLON      reduce using rule 20 (ifstatement -> iftype THEN bracedexp .)
    COMMA           reduce using rule 20 (ifstatement -> iftype THEN bracedexp .)
    $end            reduce using rule 20 (ifstatement -> iftype THEN bracedexp .)
    RBRACE          reduce using rule 20 (ifstatement -> iftype THEN bracedexp .)
    ELSE            shift and go to state 134


state 119

    (21) ifstatement -> iftype EXITWITH bracedexp .

    SEMI_COLON      reduce using rule 21 (ifstatement -> iftype EXITWITH bracedexp .)
    COMMA           reduce using rule 21 (ifstatement -> iftype EXITWITH bracedexp .)
    $end            reduce using rule 21 (ifstatement -> iftype EXITWITH bracedexp .)
    RBRACE          reduce using rule 21 (ifstatement -> iftype EXITWITH bracedexp .)


state 120

    (27) whileloop -> whiletype DO bracedexp .

    SEMI_COLON      reduce using rule 27 (whileloop -> whiletype DO bracedexp .)
    COMMA           reduce using rule 27 (whileloop -> whiletype DO bracedexp .)
    $end            reduce using rule 27 (whileloop -> whiletype DO bracedexp .)
    RBRACE          reduce using rule 27 (whileloop -> whiletype DO bracedexp .)


state 121

    (31) forloop -> fortype DO bracedexp_noscope .

    SEMI_COLON      reduce using rule 31 (forloop -> fortype DO bracedexp_noscope .)
    COMMA           reduce using rule 31 (forloop -> fortype DO bracedexp_noscope .)
    $end            reduce using rule 31 (forloop -> fortype DO bracedexp_noscope .)
    RBRACE          reduce using rule 31 (forloop -> fortype DO bracedexp_noscope .)


state 122

    (34) bracedexp_noscope -> LBRACE . code RBRACE
    (1) code -> . empty
    (2) code -> . statement
    (3) code -> . statement terminator code
    (103) empty -> .
    (4) statement -> . controlstructure
    (5) statement -> . assignment
    (6) statement -> . binaryexp
    (7) statement -> . nularexp
    (8) statement -> . unaryexp
    (11) controlstructure -> . ifstatement
    (12) controlstructure -> . whileloop
    (13) controlstructure -> . forloop
    (14) controlstructure -> . withstatement
    (37) assignment -> . assignment_code code RBRACE
    (38) assignment -> . definition EQUAL primaryexp
    (39) assignment -> . variable EQUAL primaryexp
    (49) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (50) binaryexp -> . primaryexp comparisonoperator primaryexp
    (51) binaryexp -> . primaryexp mathoperator primaryexp
    (72) nularexp -> . NULAR_FNC
    (73) nularexp -> . identifier
    (74) unaryexp -> . UNARY_FNC primaryexp
    (75) unaryexp -> . PLUS primaryexp
    (76) unaryexp -> . MINUS primaryexp
    (77) unaryexp -> . NOT primaryexp
    (78) unaryexp -> . vardefinition
    (20) ifstatement -> . iftype THEN bracedexp
    (21) ifstatement -> . iftype EXITWITH bracedexp
    (22) ifstatement -> . iftype THEN bracedexp ELSE bracedexp
    (27) whileloop -> . whiletype DO bracedexp
    (31) forloop -> . fortype DO bracedexp_noscope
    (25) withstatement -> . withstatementinit bracedexp
    (40) assignment_code -> . definition EQUAL LBRACE
    (41) assignment_code -> . variable EQUAL LBRACE
    (43) definition -> . PRIVATE PRIVATE_ID
    (44) definition -> . PRIVATE string
    (47) variable -> . PRIVATE_ID
    (48) variable -> . GLOBAL_ID
    (52) primaryexp -> . number
    (53) primaryexp -> . identifier
    (54) primaryexp -> . helpertype
    (55) primaryexp -> . unaryexp
    (56) primaryexp -> . nularexp
    (57) primaryexp -> . string
    (58) primaryexp -> . binaryexp
    (59) primaryexp -> . bracedexp
    (60) primaryexp -> . LPAREN binaryexp RPAREN
    (61) primaryexp -> . array
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID
    (35) vardefinition -> . definition
    (36) vardefinition -> . arraydefinition
    (19) iftype -> . IF forloop_condition
    (26) whiletype -> . WHILE forloop_condition
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (24) withstatementinit -> . withtype DO
    (98) number -> . NUMBER_REAL
    (99) number -> . NUMBER_EXP
    (100) number -> . NUMBER_HEX
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE
    (62) bracedexp -> . LBRACE new_scope code RBRACE
    (64) array -> . LSPAREN RSPAREN
    (65) array -> . LSPAREN arrayelement RSPAREN
    (42) arraydefinition -> . PRIVATE stringarray
    (23) withtype -> . WITH NAMESPACE

    RBRACE          reduce using rule 103 (empty -> .)
    NULAR_FNC       shift and go to state 17
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    PRIVATE         shift and go to state 30
    PRIVATE_ID      shift and go to state 31
    GLOBAL_ID       shift and go to state 33
    LPAREN          shift and go to state 36
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    NUMBER_REAL     shift and go to state 44
    NUMBER_EXP      shift and go to state 45
    NUMBER_HEX      shift and go to state 46
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 42
    WITH            shift and go to state 49

    code                           shift and go to state 135
    empty                          shift and go to state 2
    statement                      shift and go to state 3
    controlstructure               shift and go to state 4
    assignment                     shift and go to state 5
    binaryexp                      shift and go to state 6
    nularexp                       shift and go to state 7
    unaryexp                       shift and go to state 8
    ifstatement                    shift and go to state 9
    whileloop                      shift and go to state 10
    forloop                        shift and go to state 11
    withstatement                  shift and go to state 12
    assignment_code                shift and go to state 13
    definition                     shift and go to state 14
    primaryexp                     shift and go to state 15
    variable                       shift and go to state 16
    identifier                     shift and go to state 18
    vardefinition                  shift and go to state 23
    iftype                         shift and go to state 24
    bracedexp                      shift and go to state 25
    whiletype                      shift and go to state 26
    fortype                        shift and go to state 27
    withstatementinit              shift and go to state 28
    string                         shift and go to state 32
    number                         shift and go to state 34
    helpertype                     shift and go to state 35
    array                          shift and go to state 37
    arraydefinition                shift and go to state 38
    withtype                       shift and go to state 43

state 123

    (62) bracedexp -> LBRACE new_scope code . RBRACE

    RBRACE          shift and go to state 136


state 124

    (68) stringarray -> LSPAREN RSPAREN .

    SEMI_COLON      reduce using rule 68 (stringarray -> LSPAREN RSPAREN .)
    COMMA           reduce using rule 68 (stringarray -> LSPAREN RSPAREN .)
    $end            reduce using rule 68 (stringarray -> LSPAREN RSPAREN .)
    BINARY_FNC      reduce using rule 68 (stringarray -> LSPAREN RSPAREN .)
    LT              reduce using rule 68 (stringarray -> LSPAREN RSPAREN .)
    GT              reduce using rule 68 (stringarray -> LSPAREN RSPAREN .)
    LTE             reduce using rule 68 (stringarray -> LSPAREN RSPAREN .)
    GTE             reduce using rule 68 (stringarray -> LSPAREN RSPAREN .)
    EQUALITY        reduce using rule 68 (stringarray -> LSPAREN RSPAREN .)
    INEQUALITY      reduce using rule 68 (stringarray -> LSPAREN RSPAREN .)
    AND             reduce using rule 68 (stringarray -> LSPAREN RSPAREN .)
    OR              reduce using rule 68 (stringarray -> LSPAREN RSPAREN .)
    PLUS            reduce using rule 68 (stringarray -> LSPAREN RSPAREN .)
    MINUS           reduce using rule 68 (stringarray -> LSPAREN RSPAREN .)
    TIMES           reduce using rule 68 (stringarray -> LSPAREN RSPAREN .)
    DIVIDE          reduce using rule 68 (stringarray -> LSPAREN RSPAREN .)
    MOD             reduce using rule 68 (stringarray -> LSPAREN RSPAREN .)
    POW             reduce using rule 68 (stringarray -> LSPAREN RSPAREN .)
    RBRACE          reduce using rule 68 (stringarray -> LSPAREN RSPAREN .)
    RPAREN          reduce using rule 68 (stringarray -> LSPAREN RSPAREN .)
    RSPAREN         reduce using rule 68 (stringarray -> LSPAREN RSPAREN .)
    TO              reduce using rule 68 (stringarray -> LSPAREN RSPAREN .)
    STEP            reduce using rule 68 (stringarray -> LSPAREN RSPAREN .)
    DO              reduce using rule 68 (stringarray -> LSPAREN RSPAREN .)


state 125

    (69) stringarray -> LSPAREN stringarrayelement . RSPAREN

    RSPAREN         shift and go to state 137


state 126

    (70) stringarrayelement -> string .
    (71) stringarrayelement -> string . COMMA stringarrayelement

    RSPAREN         reduce using rule 70 (stringarrayelement -> string .)
    COMMA           shift and go to state 138


state 127

    (60) primaryexp -> LPAREN binaryexp RPAREN .

    BINARY_FNC      reduce using rule 60 (primaryexp -> LPAREN binaryexp RPAREN .)
    LT              reduce using rule 60 (primaryexp -> LPAREN binaryexp RPAREN .)
    GT              reduce using rule 60 (primaryexp -> LPAREN binaryexp RPAREN .)
    LTE             reduce using rule 60 (primaryexp -> LPAREN binaryexp RPAREN .)
    GTE             reduce using rule 60 (primaryexp -> LPAREN binaryexp RPAREN .)
    EQUALITY        reduce using rule 60 (primaryexp -> LPAREN binaryexp RPAREN .)
    INEQUALITY      reduce using rule 60 (primaryexp -> LPAREN binaryexp RPAREN .)
    AND             reduce using rule 60 (primaryexp -> LPAREN binaryexp RPAREN .)
    OR              reduce using rule 60 (primaryexp -> LPAREN binaryexp RPAREN .)
    PLUS            reduce using rule 60 (primaryexp -> LPAREN binaryexp RPAREN .)
    MINUS           reduce using rule 60 (primaryexp -> LPAREN binaryexp RPAREN .)
    TIMES           reduce using rule 60 (primaryexp -> LPAREN binaryexp RPAREN .)
    DIVIDE          reduce using rule 60 (primaryexp -> LPAREN binaryexp RPAREN .)
    MOD             reduce using rule 60 (primaryexp -> LPAREN binaryexp RPAREN .)
    POW             reduce using rule 60 (primaryexp -> LPAREN binaryexp RPAREN .)
    SEMI_COLON      reduce using rule 60 (primaryexp -> LPAREN binaryexp RPAREN .)
    COMMA           reduce using rule 60 (primaryexp -> LPAREN binaryexp RPAREN .)
    $end            reduce using rule 60 (primaryexp -> LPAREN binaryexp RPAREN .)
    RBRACE          reduce using rule 60 (primaryexp -> LPAREN binaryexp RPAREN .)
    RPAREN          reduce using rule 60 (primaryexp -> LPAREN binaryexp RPAREN .)
    RSPAREN         reduce using rule 60 (primaryexp -> LPAREN binaryexp RPAREN .)
    TO              reduce using rule 60 (primaryexp -> LPAREN binaryexp RPAREN .)
    STEP            reduce using rule 60 (primaryexp -> LPAREN binaryexp RPAREN .)
    DO              reduce using rule 60 (primaryexp -> LPAREN binaryexp RPAREN .)


state 128

    (32) forloop_condition -> LBRACE booleanexp . RBRACE

    RBRACE          shift and go to state 139


state 129

    (93) booleanexp -> primaryexp .
    (94) booleanexp -> primaryexp . comparisonoperator booleanexp
    (95) booleanexp -> primaryexp . comparisonoperator LBRACE booleanexp RBRACE
    (49) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (50) binaryexp -> primaryexp . comparisonoperator primaryexp
    (51) binaryexp -> primaryexp . mathoperator primaryexp
    (79) comparisonoperator -> . LT
    (80) comparisonoperator -> . GT
    (81) comparisonoperator -> . LTE
    (82) comparisonoperator -> . GTE
    (83) comparisonoperator -> . EQUALITY
    (84) comparisonoperator -> . INEQUALITY
    (85) comparisonoperator -> . AND
    (86) comparisonoperator -> . OR
    (87) mathoperator -> . PLUS
    (88) mathoperator -> . MINUS
    (89) mathoperator -> . TIMES
    (90) mathoperator -> . DIVIDE
    (91) mathoperator -> . MOD
    (92) mathoperator -> . POW

    RBRACE          reduce using rule 93 (booleanexp -> primaryexp .)
    BINARY_FNC      shift and go to state 55
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61
    EQUALITY        shift and go to state 62
    INEQUALITY      shift and go to state 63
    AND             shift and go to state 64
    OR              shift and go to state 65
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POW             shift and go to state 71

    comparisonoperator             shift and go to state 140
    mathoperator                   shift and go to state 57

state 130

    (28) fortype -> FOR new_scope string . FROM primaryexp TO primaryexp
    (29) fortype -> FOR new_scope string . FROM primaryexp TO primaryexp STEP primaryexp

    FROM            shift and go to state 141


state 131

    (30) fortype -> FOR new_scope LSPAREN . bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (34) bracedexp_noscope -> . LBRACE code RBRACE

    LBRACE          shift and go to state 122

    bracedexp_noscope              shift and go to state 142

state 132

    (65) array -> LSPAREN arrayelement RSPAREN .

    BINARY_FNC      reduce using rule 65 (array -> LSPAREN arrayelement RSPAREN .)
    LT              reduce using rule 65 (array -> LSPAREN arrayelement RSPAREN .)
    GT              reduce using rule 65 (array -> LSPAREN arrayelement RSPAREN .)
    LTE             reduce using rule 65 (array -> LSPAREN arrayelement RSPAREN .)
    GTE             reduce using rule 65 (array -> LSPAREN arrayelement RSPAREN .)
    EQUALITY        reduce using rule 65 (array -> LSPAREN arrayelement RSPAREN .)
    INEQUALITY      reduce using rule 65 (array -> LSPAREN arrayelement RSPAREN .)
    AND             reduce using rule 65 (array -> LSPAREN arrayelement RSPAREN .)
    OR              reduce using rule 65 (array -> LSPAREN arrayelement RSPAREN .)
    PLUS            reduce using rule 65 (array -> LSPAREN arrayelement RSPAREN .)
    MINUS           reduce using rule 65 (array -> LSPAREN arrayelement RSPAREN .)
    TIMES           reduce using rule 65 (array -> LSPAREN arrayelement RSPAREN .)
    DIVIDE          reduce using rule 65 (array -> LSPAREN arrayelement RSPAREN .)
    MOD             reduce using rule 65 (array -> LSPAREN arrayelement RSPAREN .)
    POW             reduce using rule 65 (array -> LSPAREN arrayelement RSPAREN .)
    SEMI_COLON      reduce using rule 65 (array -> LSPAREN arrayelement RSPAREN .)
    COMMA           reduce using rule 65 (array -> LSPAREN arrayelement RSPAREN .)
    $end            reduce using rule 65 (array -> LSPAREN arrayelement RSPAREN .)
    RBRACE          reduce using rule 65 (array -> LSPAREN arrayelement RSPAREN .)
    RPAREN          reduce using rule 65 (array -> LSPAREN arrayelement RSPAREN .)
    RSPAREN         reduce using rule 65 (array -> LSPAREN arrayelement RSPAREN .)
    TO              reduce using rule 65 (array -> LSPAREN arrayelement RSPAREN .)
    STEP            reduce using rule 65 (array -> LSPAREN arrayelement RSPAREN .)
    DO              reduce using rule 65 (array -> LSPAREN arrayelement RSPAREN .)


state 133

    (67) arrayelement -> binaryexp COMMA . arrayelement
    (66) arrayelement -> . binaryexp
    (67) arrayelement -> . binaryexp COMMA arrayelement
    (49) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (50) binaryexp -> . primaryexp comparisonoperator primaryexp
    (51) binaryexp -> . primaryexp mathoperator primaryexp
    (52) primaryexp -> . number
    (53) primaryexp -> . identifier
    (54) primaryexp -> . helpertype
    (55) primaryexp -> . unaryexp
    (56) primaryexp -> . nularexp
    (57) primaryexp -> . string
    (58) primaryexp -> . binaryexp
    (59) primaryexp -> . bracedexp
    (60) primaryexp -> . LPAREN binaryexp RPAREN
    (61) primaryexp -> . array
    (98) number -> . NUMBER_REAL
    (99) number -> . NUMBER_EXP
    (100) number -> . NUMBER_HEX
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (74) unaryexp -> . UNARY_FNC primaryexp
    (75) unaryexp -> . PLUS primaryexp
    (76) unaryexp -> . MINUS primaryexp
    (77) unaryexp -> . NOT primaryexp
    (78) unaryexp -> . vardefinition
    (72) nularexp -> . NULAR_FNC
    (73) nularexp -> . identifier
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE
    (62) bracedexp -> . LBRACE new_scope code RBRACE
    (64) array -> . LSPAREN RSPAREN
    (65) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF forloop_condition
    (26) whiletype -> . WHILE forloop_condition
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (35) vardefinition -> . definition
    (36) vardefinition -> . arraydefinition
    (43) definition -> . PRIVATE PRIVATE_ID
    (44) definition -> . PRIVATE string
    (42) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 44
    NUMBER_EXP      shift and go to state 45
    NUMBER_HEX      shift and go to state 46
    PRIVATE_ID      shift and go to state 78
    GLOBAL_ID       shift and go to state 79
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 42
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    WITH            shift and go to state 49
    PRIVATE         shift and go to state 30

    binaryexp                      shift and go to state 106
    arrayelement                   shift and go to state 143
    primaryexp                     shift and go to state 15
    number                         shift and go to state 34
    identifier                     shift and go to state 74
    helpertype                     shift and go to state 35
    unaryexp                       shift and go to state 75
    nularexp                       shift and go to state 76
    string                         shift and go to state 32
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 80
    whiletype                      shift and go to state 81
    fortype                        shift and go to state 82
    withtype                       shift and go to state 83
    vardefinition                  shift and go to state 23
    definition                     shift and go to state 84
    arraydefinition                shift and go to state 38

state 134

    (22) ifstatement -> iftype THEN bracedexp ELSE . bracedexp
    (62) bracedexp -> . LBRACE new_scope code RBRACE

    LBRACE          shift and go to state 29

    bracedexp                      shift and go to state 144

state 135

    (34) bracedexp_noscope -> LBRACE code . RBRACE

    RBRACE          shift and go to state 145


state 136

    (62) bracedexp -> LBRACE new_scope code RBRACE .

    BINARY_FNC      reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)
    LT              reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)
    GT              reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)
    LTE             reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)
    GTE             reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)
    EQUALITY        reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)
    INEQUALITY      reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)
    AND             reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)
    OR              reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)
    PLUS            reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)
    MINUS           reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)
    TIMES           reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)
    DIVIDE          reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)
    MOD             reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)
    POW             reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)
    SEMI_COLON      reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)
    COMMA           reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)
    $end            reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)
    RBRACE          reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)
    RPAREN          reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)
    RSPAREN         reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)
    TO              reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)
    STEP            reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)
    DO              reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)
    ELSE            reduce using rule 62 (bracedexp -> LBRACE new_scope code RBRACE .)


state 137

    (69) stringarray -> LSPAREN stringarrayelement RSPAREN .

    SEMI_COLON      reduce using rule 69 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    COMMA           reduce using rule 69 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    $end            reduce using rule 69 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    BINARY_FNC      reduce using rule 69 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    LT              reduce using rule 69 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    GT              reduce using rule 69 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    LTE             reduce using rule 69 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    GTE             reduce using rule 69 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    EQUALITY        reduce using rule 69 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    INEQUALITY      reduce using rule 69 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    AND             reduce using rule 69 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    OR              reduce using rule 69 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    PLUS            reduce using rule 69 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    MINUS           reduce using rule 69 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    TIMES           reduce using rule 69 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    DIVIDE          reduce using rule 69 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    MOD             reduce using rule 69 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    POW             reduce using rule 69 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    RBRACE          reduce using rule 69 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    RPAREN          reduce using rule 69 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    RSPAREN         reduce using rule 69 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    TO              reduce using rule 69 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    STEP            reduce using rule 69 (stringarray -> LSPAREN stringarrayelement RSPAREN .)
    DO              reduce using rule 69 (stringarray -> LSPAREN stringarrayelement RSPAREN .)


state 138

    (71) stringarrayelement -> string COMMA . stringarrayelement
    (70) stringarrayelement -> . string
    (71) stringarrayelement -> . string COMMA stringarrayelement
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE

    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48

    string                         shift and go to state 126
    stringarrayelement             shift and go to state 146

state 139

    (32) forloop_condition -> LBRACE booleanexp RBRACE .

    THEN            reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    EXITWITH        reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    BINARY_FNC      reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    LT              reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    GT              reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    LTE             reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    GTE             reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    EQUALITY        reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    INEQUALITY      reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    AND             reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    OR              reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    PLUS            reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    MINUS           reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    TIMES           reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    DIVIDE          reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    MOD             reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    POW             reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    SEMI_COLON      reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    COMMA           reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    $end            reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    RBRACE          reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    RPAREN          reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    RSPAREN         reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    TO              reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    STEP            reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)
    DO              reduce using rule 32 (forloop_condition -> LBRACE booleanexp RBRACE .)


state 140

    (94) booleanexp -> primaryexp comparisonoperator . booleanexp
    (95) booleanexp -> primaryexp comparisonoperator . LBRACE booleanexp RBRACE
    (50) binaryexp -> primaryexp comparisonoperator . primaryexp
    (93) booleanexp -> . primaryexp
    (94) booleanexp -> . primaryexp comparisonoperator booleanexp
    (95) booleanexp -> . primaryexp comparisonoperator LBRACE booleanexp RBRACE
    (52) primaryexp -> . number
    (53) primaryexp -> . identifier
    (54) primaryexp -> . helpertype
    (55) primaryexp -> . unaryexp
    (56) primaryexp -> . nularexp
    (57) primaryexp -> . string
    (58) primaryexp -> . binaryexp
    (59) primaryexp -> . bracedexp
    (60) primaryexp -> . LPAREN binaryexp RPAREN
    (61) primaryexp -> . array
    (98) number -> . NUMBER_REAL
    (99) number -> . NUMBER_EXP
    (100) number -> . NUMBER_HEX
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (74) unaryexp -> . UNARY_FNC primaryexp
    (75) unaryexp -> . PLUS primaryexp
    (76) unaryexp -> . MINUS primaryexp
    (77) unaryexp -> . NOT primaryexp
    (78) unaryexp -> . vardefinition
    (72) nularexp -> . NULAR_FNC
    (73) nularexp -> . identifier
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE
    (49) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (50) binaryexp -> . primaryexp comparisonoperator primaryexp
    (51) binaryexp -> . primaryexp mathoperator primaryexp
    (62) bracedexp -> . LBRACE new_scope code RBRACE
    (64) array -> . LSPAREN RSPAREN
    (65) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF forloop_condition
    (26) whiletype -> . WHILE forloop_condition
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (35) vardefinition -> . definition
    (36) vardefinition -> . arraydefinition
    (43) definition -> . PRIVATE PRIVATE_ID
    (44) definition -> . PRIVATE string
    (42) arraydefinition -> . PRIVATE stringarray

    LBRACE          shift and go to state 149
    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 44
    NUMBER_EXP      shift and go to state 45
    NUMBER_HEX      shift and go to state 46
    PRIVATE_ID      shift and go to state 78
    GLOBAL_ID       shift and go to state 79
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48
    LSPAREN         shift and go to state 42
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    WITH            shift and go to state 49
    PRIVATE         shift and go to state 30

    primaryexp                     shift and go to state 147
    booleanexp                     shift and go to state 148
    number                         shift and go to state 34
    identifier                     shift and go to state 74
    helpertype                     shift and go to state 35
    unaryexp                       shift and go to state 75
    nularexp                       shift and go to state 76
    string                         shift and go to state 32
    binaryexp                      shift and go to state 77
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 80
    whiletype                      shift and go to state 81
    fortype                        shift and go to state 82
    withtype                       shift and go to state 83
    vardefinition                  shift and go to state 23
    definition                     shift and go to state 84
    arraydefinition                shift and go to state 38

state 141

    (28) fortype -> FOR new_scope string FROM . primaryexp TO primaryexp
    (29) fortype -> FOR new_scope string FROM . primaryexp TO primaryexp STEP primaryexp
    (52) primaryexp -> . number
    (53) primaryexp -> . identifier
    (54) primaryexp -> . helpertype
    (55) primaryexp -> . unaryexp
    (56) primaryexp -> . nularexp
    (57) primaryexp -> . string
    (58) primaryexp -> . binaryexp
    (59) primaryexp -> . bracedexp
    (60) primaryexp -> . LPAREN binaryexp RPAREN
    (61) primaryexp -> . array
    (98) number -> . NUMBER_REAL
    (99) number -> . NUMBER_EXP
    (100) number -> . NUMBER_HEX
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (74) unaryexp -> . UNARY_FNC primaryexp
    (75) unaryexp -> . PLUS primaryexp
    (76) unaryexp -> . MINUS primaryexp
    (77) unaryexp -> . NOT primaryexp
    (78) unaryexp -> . vardefinition
    (72) nularexp -> . NULAR_FNC
    (73) nularexp -> . identifier
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE
    (49) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (50) binaryexp -> . primaryexp comparisonoperator primaryexp
    (51) binaryexp -> . primaryexp mathoperator primaryexp
    (62) bracedexp -> . LBRACE new_scope code RBRACE
    (64) array -> . LSPAREN RSPAREN
    (65) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF forloop_condition
    (26) whiletype -> . WHILE forloop_condition
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (35) vardefinition -> . definition
    (36) vardefinition -> . arraydefinition
    (43) definition -> . PRIVATE PRIVATE_ID
    (44) definition -> . PRIVATE string
    (42) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 44
    NUMBER_EXP      shift and go to state 45
    NUMBER_HEX      shift and go to state 46
    PRIVATE_ID      shift and go to state 78
    GLOBAL_ID       shift and go to state 79
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 42
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    WITH            shift and go to state 49
    PRIVATE         shift and go to state 30

    string                         shift and go to state 32
    primaryexp                     shift and go to state 150
    number                         shift and go to state 34
    identifier                     shift and go to state 74
    helpertype                     shift and go to state 35
    unaryexp                       shift and go to state 75
    nularexp                       shift and go to state 76
    binaryexp                      shift and go to state 77
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 80
    whiletype                      shift and go to state 81
    fortype                        shift and go to state 82
    withtype                       shift and go to state 83
    vardefinition                  shift and go to state 23
    definition                     shift and go to state 84
    arraydefinition                shift and go to state 38

state 142

    (30) fortype -> FOR new_scope LSPAREN bracedexp_noscope . COMMA forloop_condition COMMA bracedexp_noscope RSPAREN

    COMMA           shift and go to state 151


state 143

    (67) arrayelement -> binaryexp COMMA arrayelement .

    RSPAREN         reduce using rule 67 (arrayelement -> binaryexp COMMA arrayelement .)


state 144

    (22) ifstatement -> iftype THEN bracedexp ELSE bracedexp .

    SEMI_COLON      reduce using rule 22 (ifstatement -> iftype THEN bracedexp ELSE bracedexp .)
    COMMA           reduce using rule 22 (ifstatement -> iftype THEN bracedexp ELSE bracedexp .)
    $end            reduce using rule 22 (ifstatement -> iftype THEN bracedexp ELSE bracedexp .)
    RBRACE          reduce using rule 22 (ifstatement -> iftype THEN bracedexp ELSE bracedexp .)


state 145

    (34) bracedexp_noscope -> LBRACE code RBRACE .

    SEMI_COLON      reduce using rule 34 (bracedexp_noscope -> LBRACE code RBRACE .)
    COMMA           reduce using rule 34 (bracedexp_noscope -> LBRACE code RBRACE .)
    $end            reduce using rule 34 (bracedexp_noscope -> LBRACE code RBRACE .)
    RBRACE          reduce using rule 34 (bracedexp_noscope -> LBRACE code RBRACE .)
    RSPAREN         reduce using rule 34 (bracedexp_noscope -> LBRACE code RBRACE .)


state 146

    (71) stringarrayelement -> string COMMA stringarrayelement .

    RSPAREN         reduce using rule 71 (stringarrayelement -> string COMMA stringarrayelement .)


state 147

    (50) binaryexp -> primaryexp comparisonoperator primaryexp .
    (93) booleanexp -> primaryexp .
    (94) booleanexp -> primaryexp . comparisonoperator booleanexp
    (95) booleanexp -> primaryexp . comparisonoperator LBRACE booleanexp RBRACE
    (49) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (50) binaryexp -> primaryexp . comparisonoperator primaryexp
    (51) binaryexp -> primaryexp . mathoperator primaryexp
    (79) comparisonoperator -> . LT
    (80) comparisonoperator -> . GT
    (81) comparisonoperator -> . LTE
    (82) comparisonoperator -> . GTE
    (83) comparisonoperator -> . EQUALITY
    (84) comparisonoperator -> . INEQUALITY
    (85) comparisonoperator -> . AND
    (86) comparisonoperator -> . OR
    (87) mathoperator -> . PLUS
    (88) mathoperator -> . MINUS
    (89) mathoperator -> . TIMES
    (90) mathoperator -> . DIVIDE
    (91) mathoperator -> . MOD
    (92) mathoperator -> . POW

  ! reduce/reduce conflict for RBRACE resolved using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    BINARY_FNC      reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    LT              reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    GT              reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    LTE             reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    GTE             reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    EQUALITY        reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    INEQUALITY      reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    AND             reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    OR              reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    RBRACE          reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POW             shift and go to state 71

  ! PLUS            [ reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! MINUS           [ reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! TIMES           [ reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! DIVIDE          [ reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! MOD             [ reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! POW             [ reduce using rule 50 (binaryexp -> primaryexp comparisonoperator primaryexp .) ]
  ! RBRACE          [ reduce using rule 93 (booleanexp -> primaryexp .) ]
  ! BINARY_FNC      [ shift and go to state 55 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! LTE             [ shift and go to state 60 ]
  ! GTE             [ shift and go to state 61 ]
  ! EQUALITY        [ shift and go to state 62 ]
  ! INEQUALITY      [ shift and go to state 63 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 65 ]

    comparisonoperator             shift and go to state 140
    mathoperator                   shift and go to state 57

state 148

    (94) booleanexp -> primaryexp comparisonoperator booleanexp .

    RBRACE          reduce using rule 94 (booleanexp -> primaryexp comparisonoperator booleanexp .)


state 149

    (95) booleanexp -> primaryexp comparisonoperator LBRACE . booleanexp RBRACE
    (62) bracedexp -> LBRACE . new_scope code RBRACE
    (93) booleanexp -> . primaryexp
    (94) booleanexp -> . primaryexp comparisonoperator booleanexp
    (95) booleanexp -> . primaryexp comparisonoperator LBRACE booleanexp RBRACE
    (63) new_scope -> .
    (52) primaryexp -> . number
    (53) primaryexp -> . identifier
    (54) primaryexp -> . helpertype
    (55) primaryexp -> . unaryexp
    (56) primaryexp -> . nularexp
    (57) primaryexp -> . string
    (58) primaryexp -> . binaryexp
    (59) primaryexp -> . bracedexp
    (60) primaryexp -> . LPAREN binaryexp RPAREN
    (61) primaryexp -> . array
    (98) number -> . NUMBER_REAL
    (99) number -> . NUMBER_EXP
    (100) number -> . NUMBER_HEX
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (74) unaryexp -> . UNARY_FNC primaryexp
    (75) unaryexp -> . PLUS primaryexp
    (76) unaryexp -> . MINUS primaryexp
    (77) unaryexp -> . NOT primaryexp
    (78) unaryexp -> . vardefinition
    (72) nularexp -> . NULAR_FNC
    (73) nularexp -> . identifier
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE
    (49) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (50) binaryexp -> . primaryexp comparisonoperator primaryexp
    (51) binaryexp -> . primaryexp mathoperator primaryexp
    (62) bracedexp -> . LBRACE new_scope code RBRACE
    (64) array -> . LSPAREN RSPAREN
    (65) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF forloop_condition
    (26) whiletype -> . WHILE forloop_condition
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (35) vardefinition -> . definition
    (36) vardefinition -> . arraydefinition
    (43) definition -> . PRIVATE PRIVATE_ID
    (44) definition -> . PRIVATE string
    (42) arraydefinition -> . PRIVATE stringarray

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NUMBER_REAL resolved as shift
  ! shift/reduce conflict for NUMBER_EXP resolved as shift
  ! shift/reduce conflict for NUMBER_HEX resolved as shift
  ! shift/reduce conflict for PRIVATE_ID resolved as shift
  ! shift/reduce conflict for GLOBAL_ID resolved as shift
  ! shift/reduce conflict for UNARY_FNC resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NULAR_FNC resolved as shift
  ! shift/reduce conflict for STRING_SINGLE resolved as shift
  ! shift/reduce conflict for STRING_DOUBLE resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for LSPAREN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WITH resolved as shift
  ! shift/reduce conflict for PRIVATE resolved as shift
    RBRACE          reduce using rule 63 (new_scope -> .)
    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 44
    NUMBER_EXP      shift and go to state 45
    NUMBER_HEX      shift and go to state 46
    PRIVATE_ID      shift and go to state 78
    GLOBAL_ID       shift and go to state 79
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 42
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    WITH            shift and go to state 49
    PRIVATE         shift and go to state 30

  ! NULAR_FNC       [ reduce using rule 63 (new_scope -> .) ]
  ! UNARY_FNC       [ reduce using rule 63 (new_scope -> .) ]
  ! PLUS            [ reduce using rule 63 (new_scope -> .) ]
  ! MINUS           [ reduce using rule 63 (new_scope -> .) ]
  ! NOT             [ reduce using rule 63 (new_scope -> .) ]
  ! PRIVATE         [ reduce using rule 63 (new_scope -> .) ]
  ! PRIVATE_ID      [ reduce using rule 63 (new_scope -> .) ]
  ! GLOBAL_ID       [ reduce using rule 63 (new_scope -> .) ]
  ! LPAREN          [ reduce using rule 63 (new_scope -> .) ]
  ! IF              [ reduce using rule 63 (new_scope -> .) ]
  ! WHILE           [ reduce using rule 63 (new_scope -> .) ]
  ! FOR             [ reduce using rule 63 (new_scope -> .) ]
  ! NUMBER_REAL     [ reduce using rule 63 (new_scope -> .) ]
  ! NUMBER_EXP      [ reduce using rule 63 (new_scope -> .) ]
  ! NUMBER_HEX      [ reduce using rule 63 (new_scope -> .) ]
  ! STRING_SINGLE   [ reduce using rule 63 (new_scope -> .) ]
  ! STRING_DOUBLE   [ reduce using rule 63 (new_scope -> .) ]
  ! LBRACE          [ reduce using rule 63 (new_scope -> .) ]
  ! LSPAREN         [ reduce using rule 63 (new_scope -> .) ]
  ! WITH            [ reduce using rule 63 (new_scope -> .) ]

    primaryexp                     shift and go to state 129
    booleanexp                     shift and go to state 152
    new_scope                      shift and go to state 93
    number                         shift and go to state 34
    identifier                     shift and go to state 74
    helpertype                     shift and go to state 35
    unaryexp                       shift and go to state 75
    nularexp                       shift and go to state 76
    string                         shift and go to state 32
    binaryexp                      shift and go to state 77
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 80
    whiletype                      shift and go to state 81
    fortype                        shift and go to state 82
    withtype                       shift and go to state 83
    vardefinition                  shift and go to state 23
    definition                     shift and go to state 84
    arraydefinition                shift and go to state 38

state 150

    (28) fortype -> FOR new_scope string FROM primaryexp . TO primaryexp
    (29) fortype -> FOR new_scope string FROM primaryexp . TO primaryexp STEP primaryexp
    (49) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (50) binaryexp -> primaryexp . comparisonoperator primaryexp
    (51) binaryexp -> primaryexp . mathoperator primaryexp
    (79) comparisonoperator -> . LT
    (80) comparisonoperator -> . GT
    (81) comparisonoperator -> . LTE
    (82) comparisonoperator -> . GTE
    (83) comparisonoperator -> . EQUALITY
    (84) comparisonoperator -> . INEQUALITY
    (85) comparisonoperator -> . AND
    (86) comparisonoperator -> . OR
    (87) mathoperator -> . PLUS
    (88) mathoperator -> . MINUS
    (89) mathoperator -> . TIMES
    (90) mathoperator -> . DIVIDE
    (91) mathoperator -> . MOD
    (92) mathoperator -> . POW

    TO              shift and go to state 153
    BINARY_FNC      shift and go to state 55
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61
    EQUALITY        shift and go to state 62
    INEQUALITY      shift and go to state 63
    AND             shift and go to state 64
    OR              shift and go to state 65
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POW             shift and go to state 71

    comparisonoperator             shift and go to state 56
    mathoperator                   shift and go to state 57

state 151

    (30) fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA . forloop_condition COMMA bracedexp_noscope RSPAREN
    (32) forloop_condition -> . LBRACE booleanexp RBRACE
    (33) forloop_condition -> . identifier
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID

    LBRACE          shift and go to state 100
    PRIVATE_ID      shift and go to state 78
    GLOBAL_ID       shift and go to state 79

    forloop_condition              shift and go to state 154
    identifier                     shift and go to state 101

state 152

    (95) booleanexp -> primaryexp comparisonoperator LBRACE booleanexp . RBRACE

    RBRACE          shift and go to state 155


state 153

    (28) fortype -> FOR new_scope string FROM primaryexp TO . primaryexp
    (29) fortype -> FOR new_scope string FROM primaryexp TO . primaryexp STEP primaryexp
    (52) primaryexp -> . number
    (53) primaryexp -> . identifier
    (54) primaryexp -> . helpertype
    (55) primaryexp -> . unaryexp
    (56) primaryexp -> . nularexp
    (57) primaryexp -> . string
    (58) primaryexp -> . binaryexp
    (59) primaryexp -> . bracedexp
    (60) primaryexp -> . LPAREN binaryexp RPAREN
    (61) primaryexp -> . array
    (98) number -> . NUMBER_REAL
    (99) number -> . NUMBER_EXP
    (100) number -> . NUMBER_HEX
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (74) unaryexp -> . UNARY_FNC primaryexp
    (75) unaryexp -> . PLUS primaryexp
    (76) unaryexp -> . MINUS primaryexp
    (77) unaryexp -> . NOT primaryexp
    (78) unaryexp -> . vardefinition
    (72) nularexp -> . NULAR_FNC
    (73) nularexp -> . identifier
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE
    (49) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (50) binaryexp -> . primaryexp comparisonoperator primaryexp
    (51) binaryexp -> . primaryexp mathoperator primaryexp
    (62) bracedexp -> . LBRACE new_scope code RBRACE
    (64) array -> . LSPAREN RSPAREN
    (65) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF forloop_condition
    (26) whiletype -> . WHILE forloop_condition
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (35) vardefinition -> . definition
    (36) vardefinition -> . arraydefinition
    (43) definition -> . PRIVATE PRIVATE_ID
    (44) definition -> . PRIVATE string
    (42) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 44
    NUMBER_EXP      shift and go to state 45
    NUMBER_HEX      shift and go to state 46
    PRIVATE_ID      shift and go to state 78
    GLOBAL_ID       shift and go to state 79
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 42
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    WITH            shift and go to state 49
    PRIVATE         shift and go to state 30

    string                         shift and go to state 32
    primaryexp                     shift and go to state 156
    number                         shift and go to state 34
    identifier                     shift and go to state 74
    helpertype                     shift and go to state 35
    unaryexp                       shift and go to state 75
    nularexp                       shift and go to state 76
    binaryexp                      shift and go to state 77
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 80
    whiletype                      shift and go to state 81
    fortype                        shift and go to state 82
    withtype                       shift and go to state 83
    vardefinition                  shift and go to state 23
    definition                     shift and go to state 84
    arraydefinition                shift and go to state 38

state 154

    (30) fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition . COMMA bracedexp_noscope RSPAREN

    COMMA           shift and go to state 157


state 155

    (95) booleanexp -> primaryexp comparisonoperator LBRACE booleanexp RBRACE .

    RBRACE          reduce using rule 95 (booleanexp -> primaryexp comparisonoperator LBRACE booleanexp RBRACE .)


state 156

    (28) fortype -> FOR new_scope string FROM primaryexp TO primaryexp .
    (29) fortype -> FOR new_scope string FROM primaryexp TO primaryexp . STEP primaryexp
    (49) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (50) binaryexp -> primaryexp . comparisonoperator primaryexp
    (51) binaryexp -> primaryexp . mathoperator primaryexp
    (79) comparisonoperator -> . LT
    (80) comparisonoperator -> . GT
    (81) comparisonoperator -> . LTE
    (82) comparisonoperator -> . GTE
    (83) comparisonoperator -> . EQUALITY
    (84) comparisonoperator -> . INEQUALITY
    (85) comparisonoperator -> . AND
    (86) comparisonoperator -> . OR
    (87) mathoperator -> . PLUS
    (88) mathoperator -> . MINUS
    (89) mathoperator -> . TIMES
    (90) mathoperator -> . DIVIDE
    (91) mathoperator -> . MOD
    (92) mathoperator -> . POW

  ! shift/reduce conflict for STEP resolved as shift
  ! shift/reduce conflict for BINARY_FNC resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for EQUALITY resolved as shift
  ! shift/reduce conflict for INEQUALITY resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    DO              reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    SEMI_COLON      reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    COMMA           reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    $end            reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    RBRACE          reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    RPAREN          reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    RSPAREN         reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    TO              reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .)
    STEP            shift and go to state 158
    BINARY_FNC      shift and go to state 55
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61
    EQUALITY        shift and go to state 62
    INEQUALITY      shift and go to state 63
    AND             shift and go to state 64
    OR              shift and go to state 65
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POW             shift and go to state 71

  ! BINARY_FNC      [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! LT              [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! GT              [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! LTE             [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! GTE             [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! EQUALITY        [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! INEQUALITY      [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! AND             [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! OR              [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! PLUS            [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! MINUS           [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! TIMES           [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! DIVIDE          [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! MOD             [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! POW             [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]
  ! STEP            [ reduce using rule 28 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp .) ]

    comparisonoperator             shift and go to state 56
    mathoperator                   shift and go to state 57

state 157

    (30) fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA . bracedexp_noscope RSPAREN
    (34) bracedexp_noscope -> . LBRACE code RBRACE

    LBRACE          shift and go to state 122

    bracedexp_noscope              shift and go to state 159

state 158

    (29) fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP . primaryexp
    (52) primaryexp -> . number
    (53) primaryexp -> . identifier
    (54) primaryexp -> . helpertype
    (55) primaryexp -> . unaryexp
    (56) primaryexp -> . nularexp
    (57) primaryexp -> . string
    (58) primaryexp -> . binaryexp
    (59) primaryexp -> . bracedexp
    (60) primaryexp -> . LPAREN binaryexp RPAREN
    (61) primaryexp -> . array
    (98) number -> . NUMBER_REAL
    (99) number -> . NUMBER_EXP
    (100) number -> . NUMBER_HEX
    (45) identifier -> . PRIVATE_ID
    (46) identifier -> . GLOBAL_ID
    (15) helpertype -> . iftype
    (16) helpertype -> . whiletype
    (17) helpertype -> . fortype
    (18) helpertype -> . withtype
    (74) unaryexp -> . UNARY_FNC primaryexp
    (75) unaryexp -> . PLUS primaryexp
    (76) unaryexp -> . MINUS primaryexp
    (77) unaryexp -> . NOT primaryexp
    (78) unaryexp -> . vardefinition
    (72) nularexp -> . NULAR_FNC
    (73) nularexp -> . identifier
    (101) string -> . STRING_SINGLE
    (102) string -> . STRING_DOUBLE
    (49) binaryexp -> . primaryexp BINARY_FNC primaryexp
    (50) binaryexp -> . primaryexp comparisonoperator primaryexp
    (51) binaryexp -> . primaryexp mathoperator primaryexp
    (62) bracedexp -> . LBRACE new_scope code RBRACE
    (64) array -> . LSPAREN RSPAREN
    (65) array -> . LSPAREN arrayelement RSPAREN
    (19) iftype -> . IF forloop_condition
    (26) whiletype -> . WHILE forloop_condition
    (28) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp
    (29) fortype -> . FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp
    (30) fortype -> . FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN
    (23) withtype -> . WITH NAMESPACE
    (35) vardefinition -> . definition
    (36) vardefinition -> . arraydefinition
    (43) definition -> . PRIVATE PRIVATE_ID
    (44) definition -> . PRIVATE string
    (42) arraydefinition -> . PRIVATE stringarray

    LPAREN          shift and go to state 36
    NUMBER_REAL     shift and go to state 44
    NUMBER_EXP      shift and go to state 45
    NUMBER_HEX      shift and go to state 46
    PRIVATE_ID      shift and go to state 78
    GLOBAL_ID       shift and go to state 79
    UNARY_FNC       shift and go to state 19
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    NOT             shift and go to state 22
    NULAR_FNC       shift and go to state 17
    STRING_SINGLE   shift and go to state 47
    STRING_DOUBLE   shift and go to state 48
    LBRACE          shift and go to state 29
    LSPAREN         shift and go to state 42
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    WITH            shift and go to state 49
    PRIVATE         shift and go to state 30

    string                         shift and go to state 32
    primaryexp                     shift and go to state 160
    number                         shift and go to state 34
    identifier                     shift and go to state 74
    helpertype                     shift and go to state 35
    unaryexp                       shift and go to state 75
    nularexp                       shift and go to state 76
    binaryexp                      shift and go to state 77
    bracedexp                      shift and go to state 25
    array                          shift and go to state 37
    iftype                         shift and go to state 80
    whiletype                      shift and go to state 81
    fortype                        shift and go to state 82
    withtype                       shift and go to state 83
    vardefinition                  shift and go to state 23
    definition                     shift and go to state 84
    arraydefinition                shift and go to state 38

state 159

    (30) fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope . RSPAREN

    RSPAREN         shift and go to state 161


state 160

    (29) fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .
    (49) binaryexp -> primaryexp . BINARY_FNC primaryexp
    (50) binaryexp -> primaryexp . comparisonoperator primaryexp
    (51) binaryexp -> primaryexp . mathoperator primaryexp
    (79) comparisonoperator -> . LT
    (80) comparisonoperator -> . GT
    (81) comparisonoperator -> . LTE
    (82) comparisonoperator -> . GTE
    (83) comparisonoperator -> . EQUALITY
    (84) comparisonoperator -> . INEQUALITY
    (85) comparisonoperator -> . AND
    (86) comparisonoperator -> . OR
    (87) mathoperator -> . PLUS
    (88) mathoperator -> . MINUS
    (89) mathoperator -> . TIMES
    (90) mathoperator -> . DIVIDE
    (91) mathoperator -> . MOD
    (92) mathoperator -> . POW

  ! shift/reduce conflict for BINARY_FNC resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for EQUALITY resolved as shift
  ! shift/reduce conflict for INEQUALITY resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    DO              reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    SEMI_COLON      reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    COMMA           reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    $end            reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    RBRACE          reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    RPAREN          reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    RSPAREN         reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    TO              reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    STEP            reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .)
    BINARY_FNC      shift and go to state 55
    LT              shift and go to state 58
    GT              shift and go to state 59
    LTE             shift and go to state 60
    GTE             shift and go to state 61
    EQUALITY        shift and go to state 62
    INEQUALITY      shift and go to state 63
    AND             shift and go to state 64
    OR              shift and go to state 65
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POW             shift and go to state 71

  ! BINARY_FNC      [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! LT              [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! GT              [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! LTE             [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! GTE             [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! EQUALITY        [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! INEQUALITY      [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! AND             [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! OR              [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! PLUS            [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! MINUS           [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! TIMES           [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! DIVIDE          [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! MOD             [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]
  ! POW             [ reduce using rule 29 (fortype -> FOR new_scope string FROM primaryexp TO primaryexp STEP primaryexp .) ]

    comparisonoperator             shift and go to state 56
    mathoperator                   shift and go to state 57

state 161

    (30) fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .

    DO              reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    BINARY_FNC      reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    LT              reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    GT              reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    LTE             reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    GTE             reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    EQUALITY        reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    INEQUALITY      reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    AND             reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    OR              reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    PLUS            reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    MINUS           reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    TIMES           reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    DIVIDE          reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    MOD             reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    POW             reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    SEMI_COLON      reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    COMMA           reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    $end            reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    RBRACE          reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    RPAREN          reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    RSPAREN         reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    TO              reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)
    STEP            reduce using rule 30 (fortype -> FOR new_scope LSPAREN bracedexp_noscope COMMA forloop_condition COMMA bracedexp_noscope RSPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPAREN in state 149 resolved as shift
WARNING: shift/reduce conflict for NUMBER_REAL in state 149 resolved as shift
WARNING: shift/reduce conflict for NUMBER_EXP in state 149 resolved as shift
WARNING: shift/reduce conflict for NUMBER_HEX in state 149 resolved as shift
WARNING: shift/reduce conflict for PRIVATE_ID in state 149 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_ID in state 149 resolved as shift
WARNING: shift/reduce conflict for UNARY_FNC in state 149 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 149 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 149 resolved as shift
WARNING: shift/reduce conflict for NOT in state 149 resolved as shift
WARNING: shift/reduce conflict for NULAR_FNC in state 149 resolved as shift
WARNING: shift/reduce conflict for STRING_SINGLE in state 149 resolved as shift
WARNING: shift/reduce conflict for STRING_DOUBLE in state 149 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 149 resolved as shift
WARNING: shift/reduce conflict for LSPAREN in state 149 resolved as shift
WARNING: shift/reduce conflict for IF in state 149 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 149 resolved as shift
WARNING: shift/reduce conflict for FOR in state 149 resolved as shift
WARNING: shift/reduce conflict for WITH in state 149 resolved as shift
WARNING: shift/reduce conflict for PRIVATE in state 149 resolved as shift
WARNING: shift/reduce conflict for STEP in state 156 resolved as shift
WARNING: shift/reduce conflict for BINARY_FNC in state 156 resolved as shift
WARNING: shift/reduce conflict for LT in state 156 resolved as shift
WARNING: shift/reduce conflict for GT in state 156 resolved as shift
WARNING: shift/reduce conflict for LTE in state 156 resolved as shift
WARNING: shift/reduce conflict for GTE in state 156 resolved as shift
WARNING: shift/reduce conflict for EQUALITY in state 156 resolved as shift
WARNING: shift/reduce conflict for INEQUALITY in state 156 resolved as shift
WARNING: shift/reduce conflict for AND in state 156 resolved as shift
WARNING: shift/reduce conflict for OR in state 156 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 156 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 156 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 156 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 156 resolved as shift
WARNING: shift/reduce conflict for MOD in state 156 resolved as shift
WARNING: shift/reduce conflict for POW in state 156 resolved as shift
WARNING: shift/reduce conflict for BINARY_FNC in state 160 resolved as shift
WARNING: shift/reduce conflict for LT in state 160 resolved as shift
WARNING: shift/reduce conflict for GT in state 160 resolved as shift
WARNING: shift/reduce conflict for LTE in state 160 resolved as shift
WARNING: shift/reduce conflict for GTE in state 160 resolved as shift
WARNING: shift/reduce conflict for EQUALITY in state 160 resolved as shift
WARNING: shift/reduce conflict for INEQUALITY in state 160 resolved as shift
WARNING: shift/reduce conflict for AND in state 160 resolved as shift
WARNING: shift/reduce conflict for OR in state 160 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 160 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 160 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 160 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 160 resolved as shift
WARNING: shift/reduce conflict for MOD in state 160 resolved as shift
WARNING: shift/reduce conflict for POW in state 160 resolved as shift
WARNING: reduce/reduce conflict in state 18 resolved using rule (primaryexp -> identifier)
WARNING: rejected rule (nularexp -> identifier) in state 18
WARNING: reduce/reduce conflict in state 74 resolved using rule (primaryexp -> identifier)
WARNING: rejected rule (nularexp -> identifier) in state 74
WARNING: reduce/reduce conflict in state 112 resolved using rule (assignment_code -> definition EQUAL LBRACE)
WARNING: rejected rule (new_scope -> <empty>) in state 112
WARNING: reduce/reduce conflict in state 117 resolved using rule (assignment_code -> variable EQUAL LBRACE)
WARNING: rejected rule (new_scope -> <empty>) in state 117
WARNING: reduce/reduce conflict in state 147 resolved using rule (binaryexp -> primaryexp comparisonoperator primaryexp)
WARNING: rejected rule (booleanexp -> primaryexp) in state 147
